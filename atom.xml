<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jinhu&#39;s Home</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-09-06T14:58:19.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jinhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 服务器篇 防火墙与NAT服务器</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8ENAT%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2016/09/06/Linux-服务器篇-防火墙与NAT服务器/</id>
    <published>2016-09-06T14:55:56.000Z</published>
    <updated>2016-09-06T14:58:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title=" 前言"></a><a name="ch0"> 前言</a></h2><p>防火墙是整个数据包进入主机前的第一道关卡,那什么是防火墙？防火墙有什么机制？防火墙可以实现与不能实现的功能有哪些？其实Linux防火墙主要通过Netfilter与TCP Wrapper两个机制来管理，通过Netfilter可以实现让<code>Private IP</code>主机上网,也可以让Internet连接到LAN中主机，所以防火墙相当重要</p>
<h2 id="认识防火墙"><a href="#认识防火墙" class="headerlink" title=" 认识防火墙"></a><a name="ch1"> 认识防火墙</a></h2><h3 id="什么是防火墙"><a href="#什么是防火墙" class="headerlink" title=" 什么是防火墙"></a><a name="ch1.1"> 什么是防火墙</a></h3><p>在<a href="https://github.com/HiKumho/blog/issues/39" target="_blank" rel="external">Linux 学习之服务器篇 网络安全与主机基本防护:网络升级/限制端口/SELinux</a>中我们可以知道,数据包进入主机时,会通过防火墙/服务程序/SELinux/文件系统,防火墙作为保护主机的第一道关卡,其主要功能是限制某些服务的数据进出</p>
<p>所以防火墙主要任务是在规划出:</p>
<ul>
<li>切割被信任(LAN)与不被信任(Internet)的网段</li>
<li>划分出可提供Internet的服务与必须受保护的服务</li>
<li>分析出可接受与不可接受的数据包</li>
</ul>
<h3 id="Linux上的防火墙主要类别"><a href="#Linux上的防火墙主要类别" class="headerlink" title=" Linux上的防火墙主要类别"></a><a name="ch1.2"> Linux上的防火墙主要类别</a></h3><p>Linux实现防火墙功能有一些三种形式:</p>
<ul>
<li><code>Netfilter</code> 其通过分析数据包表头信息来限制其访问与处理一些动作(比如转换来源/目标的IP地址或端口信息),主要分析OSI的第二/三/四层</li>
<li><code>TCP Wrapper</code> 控管程序对于数据包的处理OR丢弃,主要以程序名来限制数据包</li>
<li><code>Proxy</code> 通过代理服务器,中转我们主机的数据包,同时起到保护主机的作用</li>
</ul>
<h3 id="Netfilter防火墙的使用限制"><a href="#Netfilter防火墙的使用限制" class="headerlink" title=" Netfilter防火墙的使用限制"></a><a name="ch1.3"> Netfilter防火墙的使用限制</a></h3><p>前面提到Netfilter防火墙主要是分析数据包表头信息,其进行的分析工作主要有:</p>
<ul>
<li>拒绝让Internet的数据包进入主机某些端口</li>
<li>拒绝让某些来源IP的数据包进入</li>
<li>拒绝让带有某些特殊flags的数据包进入</li>
<li>分析主机MAC地址,决定是否连线</li>
</ul>
<p>只不过即使有防火墙的限制,可是也不能说我们主机安全,比如我们向Internet开放WWW服务,由于要允许Internet上主机都可以连接我们主机的80端口,所以这些数据包要通过防火墙,达到服务进程处,这些数据包要是携带病毒,防火墙也是没办法处理的</p>
<h2 id="TCP-Wrappers"><a href="#TCP-Wrappers" class="headerlink" title=" TCP Wrappers"></a><a name="ch2"> TCP Wrappers</a></h2><p>TCP Wrappers是通过客服端想要连接的程序名,然后分析客服端的IP,来决定是否放行的</p>
<p>其通过配置文件<code>/etc/hosts.{allow|deny}</code>来管理</p>
<h3 id="哪些服务支持TCP-Wrappers"><a href="#哪些服务支持TCP-Wrappers" class="headerlink" title=" 哪些服务支持TCP Wrappers"></a><a name="ch2.1"> 哪些服务支持TCP Wrappers</a></h3><p>支持<code>TCP Wrappers</code>服务分为两类,分别是：</p>
<ul>
<li>由<code>super damon(xinted)</code>所管理的服务</li>
<li>有支援<code>libwrap.so</code>函数库的服务(可通过<code>ldd</code>来查看)</li>
</ul>
<h3 id="TCP-Wrappers配置文件"><a href="#TCP-Wrappers配置文件" class="headerlink" title=" TCP Wrappers配置文件"></a><a name="ch2.2"> TCP Wrappers配置文件</a></h3><p><code>TCP Wrappers</code>的配置文件<code>/etc/hosts.{allow|deny}</code>，其语法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;service(program name)&gt;:&lt;ip/domain/hostname&gt;:action</div></pre></td></tr></table></figure>
<p>其中<code>hosts.allow</code>设置程序放行的ip,而<code>hosts.deny</code>则相反,优先级上,<code>hosts.allow</code>高于<code>hosts.deny</code>
当两个文件都不存在时,Linux默认以放行来处理</p>
<h2 id="Netfilter"><a href="#Netfilter" class="headerlink" title=" Netfilter"></a><a name="ch3"> Netfilter</a></h2><p>Linux实现Netfilter功能(数据包过滤)的软件是<code>iptables</code>,其内核所提供，在效能上非常好</p>
<h3 id="数据包进入的流程-规则顺序的重要"><a href="#数据包进入的流程-规则顺序的重要" class="headerlink" title=" 数据包进入的流程:规则顺序的重要"></a><a name="ch3.1"> 数据包进入的流程:规则顺序的重要</a></h3><p>Netfilter防火墙是通过设定一条条<b>规则</b>来过滤数据包的,而这些规则在匹配数据包上有顺序(由上到下识别),匹配成功后就执行相应的<code>action</code>,不再往下匹配</p>
<p>如果都不匹配,那等着此数据包的就是<code>Poliey</code>(预设动作)了</p>
<p>比如下图,当一个数据包匹配<code>rule 01</code>,就满足,执行其action – [DROP],那么该数据包就会被主机给丢弃
<img src="http://ocz7ifqwi.bkt.clouddn.com/netfilter_rules.png" alt=""></p>
<h3 id="iptables的表格-table-与链-chain"><a href="#iptables的表格-table-与链-chain" class="headerlink" title=" iptables的表格(table)与链(chain)"></a><a name="ch3.2"> iptables的表格(table)与链(chain)</a></h3><p>由于防火墙有很多条规则,为了方便则是某类动作,我们将一组规则整合成<code>chain(链)</code>,比如处理进入的数据包的规则组称为<code>INPUT</code>,处理发出的数据包的规则组称为<code>OUTPUT</code>,</p>
<p>而再将这些链组合在一起,专门针对某些功能,那就是<code>table</code>了</p>
<p>iptables预设有以下三个<code>table</code>,如下图</p>
<p><img src="http://ocz7ifqwi.bkt.clouddn.com/netfilter_iptables.png" alt=""></p>
<p>各表相关的功能如下</p>
<ul>
<li><code>filter</code>  主要跟进出主机的数据包有关,预设table为filter<ul>
<li><code>INPUT</code>  主要跟进入主机的数据包有关</li>
<li><code>FORWARD</code>  主要跟转递数据包有关,与<code>nat table</code>相性高</li>
<li><code>OUTPUT</code>  主要跟主机发出的数据包有关</li>
</ul>
</li>
<li><code>nat</code> 主要对数据包中目标/来源的IP与port进行修改<ul>
<li><code>PREROUTING</code>  在路由判断前进行的规则,主要修改目标IP/port</li>
<li><code>POSTROUTING</code> 在路由判断后进行的规则,主要修改来源IP/port</li>
<li><code>OUTPUT</code> 与发出的数据包有关</li>
</ul>
</li>
<li><code>mangle</code> 主要与数据包的flags有关</li>
</ul>
<p>当数据包在防火墙规则匹配过程中,各表与链的相关性如下图</p>
<p><img src="http://ocz7ifqwi.bkt.clouddn.com/netfilter_iptables_relate.gif" alt=""></p>
<p>虽然上图很复杂,但我们可以看出iptables控制的三种数据包的流向:</p>
<ul>
<li>数据包进入Linux主机–使用路线A</li>
<li>数据包由Linux主机转递–使用路线B</li>
<li>数据包由Linux主机发出–使用路线C</li>
</ul>
<h3 id="iptables的语法"><a href="#iptables的语法" class="headerlink" title=" iptables的语法"></a><a name="ch3.3"> iptables的语法</a></h3><h4 id="规则的查看与清除"><a href="#规则的查看与清除" class="headerlink" title="规则的查看与清除"></a>规则的查看与清除</h4><ul>
<li>查看规则  : <code>iptables-save [-t table]</code></li>
<li>清除规则  : <ul>
<li><code>iptables -F</code>  清除所有的已制定的规则</li>
<li><code>iptables -X</code>  清除所有使用者制定的chain</li>
<li><code>iptables -Z</code>  所有chain的计数与流量统计都归0</li>
<li><code>iptables -F INPUT</code> 清空 filter表INPUT所有规则  </li>
<li><code>iptables -D INPUT 3</code>  删除input的第3条规则  </li>
</ul>
</li>
</ul>
<h4 id="设置预设政策"><a href="#设置预设政策" class="headerlink" title="设置预设政策"></a>设置预设政策</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables [-t tables] -P [INPUT,OUTPUT,FORWARD等] [ACCEPT,DROP]</div></pre></td></tr></table></figure>
<h4 id="添加规则：限制IP-network-网络接口"><a href="#添加规则：限制IP-network-网络接口" class="headerlink" title="添加规则：限制IP/network/网络接口"></a>添加规则：限制IP/network/网络接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># iptables [-AI 链名] [-io 网络接口] [-p 协议] \</div><div class="line">&gt; [-s 來源IP/网域] [-d 目标IP/网域] -j [ACCEPT|DROP|REJECT|LOG]</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>AI 链名</code>  针对某条链进行规则的 “插入” 或 “累加”<ul>
<li><code>A</code> 在链的尾部增加一条规则</li>
<li><code>I</code> 在链的头部插入一条规则,成为第一条规则</li>
</ul>
</li>
<li><code>io 网络接口</code>：设置数据包进出的网络接口<ul>
<li><code>i</code>  数据包所进入的接口,如<code>INPUT</code>链搭配</li>
<li><code>o</code> 数据包所出去的接口,如<code>OUTPUT</code>链搭配</li>
</ul>
</li>
<li><code>p 协议</code>：设置此规则适用的数据包格式<ul>
<li>如<code>tcp/udp/icmp等</code></li>
</ul>
</li>
<li><code>s 来源 IP/网域</code>：设定此规则的数据包來源,可指定 IP或网域，例如：    <ul>
<li>IP  ：192.168.0.100      <ul>
<li>网域：192.168.0.0/24, 192.168.0.0/255.255.255.0 均可。     </li>
<li>若规定为[不许]时,加上 ! 即可，例如：     </li>
<li>-s ! 192.168.100.0/24 表示不许192.168.100.0/24 的数据包来源；</li>
</ul>
</li>
</ul>
</li>
<li><code>d 目标IP/网域</code> ： 设置此规则的数据包目标</li>
<li><code>j</code> ：后接动作，主要的动作有接受(ACCEPT)、丢弃(DROP)、拒绝(REJECT)及记录(LOG)</li>
</ul>
<h4 id="添加规则：限制端口"><a href="#添加规则：限制端口" class="headerlink" title="添加规则：限制端口"></a>添加规则：限制端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> iptables [-AI 链] [-io 网络接口] [-p tcp,udp] \</div><div class="line">&gt; [-s 來源IP/网域] [--sport 端口范围] \</div><div class="line">&gt; [-d 目标IP/网域] [--dport 端口范围] -j [ACCEPT|DROP|REJECT]</div></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><code>--sport 端口范围</code>：限制來源的端口，端口可以是连续的，例如 1024:65535</li>
<li><code>--dport 端口范围</code>：限制目标的端口</li>
</ul>
<h4 id="添加规则：匹配mac与state"><a href="#添加规则：匹配mac与state" class="headerlink" title="添加规则：匹配mac与state"></a>添加规则：匹配mac与state</h4><p>匹配数据包的mac地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -A INPUT [-m mac] [--mac-source mac地址 ] -j action</div></pre></td></tr></table></figure>
<p>匹配数据包的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -A INPUT [-m state] [--state 状态] -j action</div></pre></td></tr></table></figure>
<p>数据包的状态有：</p>
<ul>
<li><code>INVALID</code>  无效的数据包,例如资料破损的数据包</li>
<li><code>ESTABLISHED</code> 已经连线成功的连续状态</li>
<li><code>NEW</code> 想要新建立连线的数据包状态</li>
<li><code>RELATED</code> 表示这个数据包是与我们主机发出去的数据包有关</li>
</ul>
<h4 id="添加规则：限制ICMP包的类型"><a href="#添加规则：限制ICMP包的类型" class="headerlink" title="添加规则：限制ICMP包的类型"></a>添加规则：限制ICMP包的类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -A INPUT [-p icmp] [--icmp-type 类型] -j action</div></pre></td></tr></table></figure>
<p>类型是icmp包的类型,比如<code>8</code> 是<code>echo request</code>,用于<code>ping</code>连接</p>
<h4 id="IPv4的内核功能：-prov-sys-net-ipv4"><a href="#IPv4的内核功能：-prov-sys-net-ipv4" class="headerlink" title="IPv4的内核功能：/prov/sys/net/ipv4/*"></a>IPv4的内核功能：/prov/sys/net/ipv4/*</h4><p>内核也一些功能,来处理网络状态：</p>
<ul>
<li><code>/proc/sys/net/ipv4/tcp_syncookies</code> 抵制基于SYN Flooding的DOS攻击</li>
<li><code>/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</code> 抵制基于Ping Flooding的DOS攻击</li>
<li><code>/proc/sys/net/ipv4/conf/*/rp_filter</code>  逆向路径过滤,抵挡一些不合理的数据包 </li>
<li><code>/proc/sys/net/ipv4/conf/*/log_martians</code> 记录不合法的IP来源</li>
</ul>
<h4 id="简单的防火墙规则"><a href="#简单的防火墙规则" class="headerlink" title="简单的防火墙规则"></a>简单的防火墙规则</h4><p>通常一些简单的防火墙规则有以下：</p>
<ul>
<li><code>规则归0</code>： 清除所有已经存在的规则</li>
<li><code>预设政策</code>： 除了INPUT链预设为DROP,其他预设为ACCEPT</li>
<li><code>信任本机</code>： 开放lo接口</li>
<li><code>回应数据包</code> ： 让主机主动向外要求而回应的数据包可以进入本机（ESTABLISHED,RELATED）</li>
<li><code>信任用户</code> ： 非必要，可以让LAN的来源可访问主机资源</li>
</ul>
<p>可以参考
<a href="https://github.com/HiKumho/shell_script_rep/blob/master/iptableRule.sh" target="_blank" rel="external">iptableRule.sh:设置防火墙规则,面向一般服务器</a></p>
<h2 id="NAT服务器的设置"><a href="#NAT服务器的设置" class="headerlink" title=" NAT服务器的设置"></a><a name="ch4"> NAT服务器的设置</a></h2><p>NAT服务在于修改数据包的来源/目标的Socket Pair,其关注的是nat表的PREROUTING链(修改目标的Socket Pair)与POSTROUTING(修改来源的Socket Pair)</p>
<h3 id="SNAT-DNAT以及设置方法"><a href="#SNAT-DNAT以及设置方法" class="headerlink" title=" SNAT/DNAT以及设置方法"></a><a name="ch4.1"> SNAT/DNAT以及设置方法</a></h3><h4 id="SNAT：修改数据包的来源Socket-Pair"><a href="#SNAT：修改数据包的来源Socket-Pair" class="headerlink" title="SNAT：修改数据包的来源Socket Pair"></a>SNAT：修改数据包的来源Socket Pair</h4><p><img src="http://ocz7ifqwi.bkt.clouddn.com/snat.png" alt=""></p>
<p>如上图所示,SNAT通常用于让LAN的主机通过服务器的Public IP连上Internet</p>
<p>设置方法：<code>iptables -t nat -A POSTROUTING -s $innet -o $EXTIF -j MASQUERADE</code></p>
<ul>
<li><code>$innet</code> 是LAN的network,如<code>192.168.100.0/24</code> </li>
<li><code>$EXTIF</code> 是对外的网络接口,如eth0</li>
<li><code>MASQUERADE</code>  让IP伪装成数据包出去(-o)的网络接口上的IP</li>
</ul>
<p>或者设置成,经由eth0出去的数据包,将它们的来源IP改成 192.168.1.210-192.168.1.220
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 192.168.1.210-192.168.1.220</div></pre></td></tr></table></figure></p>
<h4 id="DNAT：修改数据包的目标Socket-Pair"><a href="#DNAT：修改数据包的目标Socket-Pair" class="headerlink" title="DNAT：修改数据包的目标Socket Pair"></a>DNAT：修改数据包的目标Socket Pair</h4><p><img src="http://ocz7ifqwi.bkt.clouddn.com/dnat.png" alt=""></p>
<p>如上图所示,DNAT通过用于Internet主机访问LAN中的主机</p>
<p>设置方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 \</div><div class="line">     -j DNAT --to-destination 192.168.100.10:80 </div></pre></td></tr></table></figure>
<p>将从eth0进入且目标端口是80的数据包，都转移到192.168.100.10:80上</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot; 前言&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch0&quot;&gt; 前言&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;防火墙是整个数据包进入主机前的第一道关卡,那什么是防火墙？防火墙有什么机制？防火墙可以实现与不能实现
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务器篇 路由概念与路由协议</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87-%E8%B7%AF%E7%94%B1%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2016/09/06/Linux-服务器篇-路由概念与路由协议/</id>
    <published>2016-09-06T14:50:57.000Z</published>
    <updated>2016-09-06T14:54:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由"><a href="#路由" class="headerlink" title=" 路由"></a><a name="ch1"> 路由</a></h2><p>路由是规划我们数据包在网络上的传输路径以及方式</p>
<h3 id="路由表产生的类型"><a href="#路由表产生的类型" class="headerlink" title=" 路由表产生的类型"></a><a name="ch1.1"> 路由表产生的类型</a></h3><p>我们每台主机都有自己的路由表,我们可以使用<code>route</code>来查看,那设置路由表有以下方式：</p>
<ul>
<li>直接设置网络接口的路由配置文件<ul>
<li><code>/etc/network/interfaces(Ubuntu)</code>或<code>/etc/sysconfig/network-scripts/route-eth0(CentOS)</code></li>
</ul>
</li>
<li>手动或预设路由<ul>
<li>通过<code>route</code>来设置</li>
<li>预设路由指的是网段的网关IP</li>
</ul>
</li>
<li>动态路由的学习<ul>
<li>通过让路由器间自主学习动态更新路由表</li>
</ul>
</li>
</ul>
<h3 id="网卡虚拟网络接口-IP-Alias的测试用途"><a href="#网卡虚拟网络接口-IP-Alias的测试用途" class="headerlink" title=" 网卡虚拟网络接口:IP Alias的测试用途"></a><a name="ch1.2"> 网卡虚拟网络接口:IP Alias的测试用途</a></h3><p>让一个网卡虚拟出多个网络接口,其形式如<code>eth0:0</code>,这可以供我们设置IP参数,方便我们测试
但要注意的是实体网卡需要启动,虚拟出来网络接口才能使用</p>
<p>同样的,我们也可以通过建议其配置文件来开机启动该网络接口,比如<code>/etc/sysconfig/network-scripts/ifcfg-eth0:0</code></p>
<h3 id="重复路由的问题"><a href="#重复路由的问题" class="headerlink" title=" 重复路由的问题"></a><a name="ch1.3"> 重复路由的问题</a></h3><p>这里有个问题,就是如果我用两张网卡都设置成同一个目标网域的路由,比如像下面
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Destination     Gateway   Genmask         Flags Metric Ref   Use Iface</div><div class="line">192.168.0.0     0.0.0.0   255.255.255.0   U     0      0       0 eth1</div><div class="line">192.168.0.0     0.0.0.0   255.255.255.0   U     0      0       0 eth0</div></pre></td></tr></table></figure></p>
<p>会出现什么问题?</p>
<p>嘿嘿,我们知道数据包查看路由表是由上到下进行的,所以说数据包如果要传送到192.168.0.0/24这个网段的数据包,其实都是通过eth1,eth0没作用</p>
<h2 id="路由器架设"><a href="#路由器架设" class="headerlink" title=" 路由器架设"></a><a name="ch2"> 路由器架设</a></h2><p>我们知道,同一个网段内主机可以通过广播来传递数据包,而不同网段内数据包的传递就需要通过路由器来转交了</p>
<h3 id="什么是路由器与IP分享器"><a href="#什么是路由器与IP分享器" class="headerlink" title=" 什么是路由器与IP分享器"></a><a name="ch2.1"> 什么是路由器与IP分享器</a></h3><h4 id="什么是路由器"><a href="#什么是路由器" class="headerlink" title="什么是路由器?"></a><a name="ch2.1.1"><b>什么是路由器?</b></a></h4><p>上面我们了解到,路由器主要是<code>转递数据包</code>,它通过分享数据包IP表头,获取目标IP,通过其本身的路由表来转递,所以路由器要有两个网络接口以上.</p>
<p>要达成路由器功能,有以下两种方式:</p>
<ul>
<li><code>硬件功能</code> 比如TP-Link等厂商生产的硬件路由器,其内嵌嵌入式操作系统,负责不同网段间的数据包转递与IP转译</li>
<li><code>软件功能</code> 比如使用Linux的内核功能就能提供上面的功能了</li>
</ul>
<p><b>Linux要作为路由器</b>,首先需要启动其数据包转递的功能(<code>IP forward</code>),启动方式有以下两种</p>
<ul>
<li>直接修改内存中的内核功能参数 <code>/proc/sys/net/ipv4/ip_forward</code> (1`为启动 0非)</li>
<li>修改内核功能配置文件 <code>/etc/sysctl.conf</code>中<code>net.ipv4.ip_forward=1</code> 之后让其立即生效 <code>sysctl -p</code></li>
</ul>
<p>然后就是修改Linux路由器的路由表了,同样分为两种方式</p>
<ul>
<li>静态路由<br>通过直接设置路由配置文件或使用route来修改路由表,缺点就是对应大型网络的架设较困难,而且不易变更</li>
<li>动态路由<br>通过使用<code>Quagga</code>或<code>zebra</code>来侦测网域的变化,让路由器自主更改路由表</li>
</ul>
<h4 id="什么是IP分享器"><a href="#什么是IP分享器" class="headerlink" title="什么是IP分享器?"></a><a name="ch2.1.2"><b>什么是IP分享器?</b></a></h4><p>其实IP分享器本身就是一个路由器,在<code>数据包转递</code>这个功能上加入了<code>IP转译</code>,这也就是NAT服务器</p>
<p><code>IP转译</code> 通过修改数据包IP表头的来源或目标IP,可以让内部的私有IP转译成公共IP,连接上Internet</p>
<p>所以说NAT服务器可以沟通内部网段与公共网域</p>
<h4 id="何时需要路由器"><a href="#何时需要路由器" class="headerlink" title="何时需要路由器"></a><a name="ch2.1.3"><b>何时需要路由器</b></a></h4><p>通常需要架设路由器,都是拥有数百台主机的大型企业内部,通常会这么考虑</p>
<ul>
<li>布线与效能考量<ul>
<li>路由器可以分隔网段,所以数据传播更有效(不可能,让随便一台主机发个包就广播给数百台主机的吧)</li>
</ul>
</li>
<li>部门独立与保护资料的考量<ul>
<li>路由器因为可以分隔网段,所以也可以在路由器里加设防火墙,隔断一些数据包</li>
</ul>
</li>
</ul>
<h3 id="静态路由架设"><a href="#静态路由架设" class="headerlink" title=" 静态路由架设"></a><a name="ch2.2"> 静态路由架设</a></h3><p>前面我们提到,静态路由就是我们手工设置路由表,这有以下步骤:</p>
<ol>
<li>规划网段以及路由<ul>
<li>规划好网段以及相应路由/主机等</li>
<li><b>注意:网络传输是双向的,所以路由传递数据包也要双向</b></li>
<li>比如,<code>192.168.1.0</code>这个网段的数据包,route B会传给route A</li>
<li>而<code>192.168.100.0</code>由route A 也传给route B</li>
<li>总之多考虑下</li>
</ul>
</li>
<li>设置各主机/路由的IP参数以及路由表<ul>
<li>IP参数直接修改网络接口配置文件</li>
<li>路由表也修改配置文件</li>
<li>主机们就将默认网关设到其直接到达的路由器上</li>
<li>路由器要设置2个以上的网络接口</li>
</ul>
</li>
<li>路由器启动<code>数据包转递</code>功能<ul>
<li>修改<code>/etc/sysctl.conf</code>配置文件,具体查看上<a href="#ch2.1">2.1部分</a></li>
<li><code>sysctl -p</code>重新加载内核参数</li>
</ul>
</li>
<li>重启网络服务,并进行测试连通性<ul>
<li><code>service network restart</code> 重启网络服务</li>
<li>通过<code>ping</code>来测试各主机的连通</li>
</ul>
</li>
</ol>
<p>具体例子,请查看<a href="http://linux.vbird.org/linux_server/0230router.php#route_static" target="_blank" rel="external">鸟哥私房菜的静态路由部分</a></p>
<h3 id="动态路由架设-quagga-zebar-ripd"><a href="#动态路由架设-quagga-zebar-ripd" class="headerlink" title=" 动态路由架设:quagga(zebar+ripd)"></a><a name="ch2.3"> 动态路由架设:quagga(zebar+ripd)</a></h3><p>静态路由设置上较麻烦,而且需要重新规划时十分痛苦,聪明的人类想到让路由器自己学习路由表的方法(算法),然后就有了动态路由</p>
<p>动态路由架设过程:</p>
<h4 id="路由器们要安装quagga软件包"><a href="#路由器们要安装quagga软件包" class="headerlink" title="路由器们要安装quagga软件包"></a>路由器们要安装quagga软件包</h4><ul>
<li><code>quagga</code> 提供了很多动态路由协议,比如<code>RIPv2/OSPF/BGP</code>等,这些协议放置在<code>/etc/quagga/</code>下</li>
<li><code>zebra</code> quagga提供的软件,其为daemon,用于更新主机的路由表(插入/删除路由规则)</li>
<li><code>ripd</code> quagga提供的软件,其为daemon,用于向附近的路由器交流路由规则与传送</li>
</ul>
<h4 id="设置所有主机-路由器的网络参数"><a href="#设置所有主机-路由器的网络参数" class="headerlink" title="设置所有主机/路由器的网络参数"></a>设置所有主机/路由器的网络参数</h4><p>这个没得说的,注意路由器要启动<code>数据包转递</code></p>
<h4 id="路由器们设置zebra"><a href="#路由器们设置zebra" class="headerlink" title="路由器们设置zebra"></a>路由器们设置zebra</h4><p>修改路由器上的zebra配置文件<code>/etc/quagga/zebra.conf</code>,比如下面
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hostname www.centos.vbird           &lt;==给予这路由器一个主机名称，随便取！</div><div class="line">password linuxz1                    &lt;==给予一个密码！</div><div class="line">enable password linuxz1             &lt;==将这个密码生效！</div><div class="line">log file /var/log/quagga/zebra.log  &lt;==保存zebar的信息至日志文件</div></pre></td></tr></table></figure>
之后重启zebra以及设置开机启动zebra</p>
<p>最后就可以<code>netstat -ntulp | grep zebra</code>查看zebra端口,通过<code>telnet</code>连接测试</p>
<p><b>注意：zebra也可以设置/查看路由表,通过telnet连接上服务即可进行</b></p>
<h4 id="路由器们设置ripd"><a href="#路由器们设置ripd" class="headerlink" title="路由器们设置ripd"></a>路由器们设置ripd</h4><p>首先还是要修改ripd配置文件<code>/etc/quagga/ripd.conf</code>,如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">hostname www.centos.vbird           &lt;==这里设置router主机名</div><div class="line">password linuxz1                    &lt;==设置好密码</div><div class="line">debug rip events                    &lt;==可以记录较多的错误信息</div><div class="line">debug rip packet                    &lt;==通过信息来解决问题</div><div class="line">router rip                          &lt;==启动router 的 rip 功能</div><div class="line"> version 2                          &lt;==启动RIPv2 的服务 (预设值)</div><div class="line"> network 192.168.1.0/24             &lt;==路由器所管理的两个接口</div><div class="line"> network 192.168.100.0/24</div><div class="line">interface eth0                      &lt;==针对对外接口设置略过身份验证的方式</div><div class="line"> no ip rip authentication mode      &lt;==不要验证身份！</div><div class="line">log file /var/log/quagga/zebra.log  &lt;==记录日志信息</div></pre></td></tr></table></figure></p>
<p>之后重启guagga以及设置开机启动guagga</p>
<p>最后就是查看路由表啦！！！ <code>route</code>或者连接上<code>zebra</code></p>
<h3 id="路由器连接同个网段：ARP-Proxy"><a href="#路由器连接同个网段：ARP-Proxy" class="headerlink" title=" 路由器连接同个网段：ARP Proxy"></a><a name="ch2.4"> 路由器连接同个网段：ARP Proxy</a></h3><p>如果我们要强行对同一个网段的主机进行划分出子网(在不改动IP参数等前提下),我们应该怎么做？
我们知道路由器是可以沟通不同网段上的主机,如果让它来分隔同个网段的主机要怎么做？</p>
<p>这就是<code>ARP Proxy</code>,我对其的理解是:</p>
<ul>
<li>让路由器的网卡MAC伪装成某些主机的MAC,让路由器强行接收发给主机们的数据包(比如路由器上有条规则：<code>对与192.168.1.1</code>主机的数据包都发到我eth0上吧,我会处理的)</li>
<li>然后再通过路由器的<code>数据包转递</code>给主机</li>
</ul>
<p>我们可以通过<code>arp</code>与<code>route</code>实现,具体请看<a href="http://linux.vbird.org/linux_server/0230router.php#arp_proxy" target="_blank" rel="external">鸟哥关于ARP Proxy部分</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;headerlink&quot; title=&quot; 路由&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt; 路由&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;路由是规划我们数据包在网络上的传输路径以及方式&lt;/p&gt;
&lt;h3 id=&quot;路由表产生的类型&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务器篇 网络安全与主机基本防护:网络升级/限制端口/SELinux</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%9F%BA%E6%9C%AC%E9%98%B2%E6%8A%A4-%E7%BD%91%E7%BB%9C%E5%8D%87%E7%BA%A7-%E9%99%90%E5%88%B6%E7%AB%AF%E5%8F%A3-SELinux/"/>
    <id>http://yoursite.com/2016/09/06/Linux-服务器篇-网络安全与主机基本防护-网络升级-限制端口-SELinux/</id>
    <published>2016-09-06T14:47:33.000Z</published>
    <updated>2016-09-06T14:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络数据包连线进入主机的过程"><a href="#网络数据包连线进入主机的过程" class="headerlink" title=" 网络数据包连线进入主机的过程"></a><a name="ch1"> 网络数据包连线进入主机的过程</a></h2><p>当网络上一个连线要求进入我们主机获取资源时,这个数据包进入主机整个流程是怎样的?</p>
<h3 id="数据包进入主机的过程"><a href="#数据包进入主机的过程" class="headerlink" title=" 数据包进入主机的过程"></a><a name="ch1.1"> 数据包进入主机的过程</a></h3><p>网络数据包传输是双向的,当数据包进入主机时会被一层层防护筛选,最后才能获取到主机中的资源,下图是数据包进入主机的流程
<img src="https://raw.githubusercontent.com/HiKumho/blog/a5a3591061509bfda8cf412b71b4806d958343d6/img/blog_39_1.gif" alt=""></p>
<ol>
<li>经过防火墙的分析:linux内建两个防火墙机制:<code>netfilter</code>与<code>TCP wrappers</code><ul>
<li>数据包过滤防火墙:NetFilter 由<code>iptables</code>这个组件提供,对TCP/IP包表头信息进行过滤,主要对象是MAC/IP/ICMP/TCP/UDP数据包</li>
<li>TCP wrapper:数据包经过NetFilter后由Super daemons及TCP wrapper检验,主要是抵挡IP或端口,并进报告,<code>/etc/hosts.allow</code>与<code>hosts.deny</code>中设置</li>
</ul>
</li>
<li>服务的基本功能:服务进程同样可以过滤掉某些数据包,比如httpd.conf规范了一些IP不能访问资源,如果服务程序有漏洞,也是很重大的一件事</li>
<li>SElinux对服务进程的权限控制:限制了服务进程能取得资源的范围,即使是root也要遵守规则</li>
<li>文件系统的基本权限控制:能否读取到数据,最后还是由文件系统的基本权限来控制的</li>
</ol>
<h3 id="网络常见攻击手段及保护措施"><a href="#网络常见攻击手段及保护措施" class="headerlink" title=" 网络常见攻击手段及保护措施"></a><a name="ch1.2"> 网络常见攻击手段及保护措施</a></h3><ul>
<li>取得用户账号信息后猜密码<ul>
<li>知道你的主机名,获取到用户账号,通过nmap来扫描主机的服务端口,就可以猜密码</li>
<li>保护措施<ul>
<li>减少信息曝光</li>
<li>建立严格的密码设定规划：比如<code>/etc/shadow</code> <code>/etc/login.defs</code>中设置密码须变更的时间</li>
<li>完善的权限设置</li>
</ul>
</li>
</ul>
</li>
<li>利用系统的程序漏洞主动攻击<ul>
<li>利用我们系统上开启的服务程序漏洞来进行攻击</li>
<li>保护措施<ul>
<li>关闭不需要的网络服务</li>
<li>随时保持更新软件</li>
<li>关闭不需要的软件</li>
</ul>
</li>
</ul>
</li>
<li>利用社交工程欺骗<pre><code>-  一些钓鱼信息等等
-  保护措施
    -  不要随意透露账号/密码等信息
    -  追踪对方
</code></pre></li>
<li>恶意网站<pre><code>- 保护措施
   -  随时更新软件
   -  最小化软件功能
   -  不连接到不明的主机
</code></pre></li>
<li>蠕虫/木马的rootkit<ul>
<li>rootkit是指取得root权限的一群工具组,rootkit主要也是通过程序漏洞来实现的</li>
<li>蠕虫：让你的主机一直发送数据包对外攻击，网络频宽被吃光</li>
<li>木马：让你主机开启后门(开一个port来黑客主动入侵)</li>
<li>保护措施<pre><code>-   定时用rkhunter来追查
-   不下载来路不明的软件/资料
-   减少危险指令的使用,比如SUID/SGID等
</code></pre></li>
</ul>
</li>
<li>DDoS攻击<ul>
<li>分散式阻断服务功能,通过绑架各地的僵尸主机来进行DDos</li>
<li>让僵尸主机不断发送请求(同步连线)至目标服务器</li>
<li>不理会服务器回应,持续发送请求,耗掉服务资源,使其不能提供正常服务</li>
</ul>
</li>
</ul>
<h3 id="主机保护：软件更新-减少网络服务-启动SElinux"><a href="#主机保护：软件更新-减少网络服务-启动SElinux" class="headerlink" title=" 主机保护：软件更新/减少网络服务/启动SElinux"></a><a name="ch1.3"> 主机保护：软件更新/减少网络服务/启动SElinux</a></h3><p>主机保护有以下几个方向:</p>
<ul>
<li>建立完善的用户密码规则</li>
<li>完善的主机权限设置(SElinux与文件系统权限)</li>
<li>设定自动升级与修补软件漏洞,移出软件(软件方面)</li>
<li>强化服务程序的安全设定</li>
<li>利用<code>iptables</code>/<code>tcp wrappers</code>强化网络防火墙</li>
<li>利用日志文件分析主机状态(<code>logwatch</code>)</li>
</ul>
<p>后面部分也会谈到软件更新/减少网络服务(限制端口)等操作,有关SElinux部分请看<a href="https://github.com/HiKumho/blog/issues/27#ch4" target="_blank" rel="external">Linux 学习之程序管理与SELinux</a></p>
<h2 id="网络自动更新软件"><a href="#网络自动更新软件" class="headerlink" title=" 网络自动更新软件"></a><a name="ch2"> 网络自动更新软件</a></h2><h3 id="如何进行软件更新"><a href="#如何进行软件更新" class="headerlink" title=" 如何进行软件更新"></a><a name="ch2.1"> 如何进行软件更新</a></h3><p>通常我们都是通过线上自动升级机制的<code>yum/apt/you/urpmi</code>来更新软件的,它们基于自家的包管理器(如rpm/dpkg)</p>
<p>如果我们以tarball方式安装的软件,要进行升级,就只能自己到相关官网上下载更新的tarball,再次编译安装了</p>
<h3 id="yum软件更新-镜像网站使用的原理"><a href="#yum软件更新-镜像网站使用的原理" class="headerlink" title=" yum软件更新/镜像网站使用的原理"></a><a name="ch2.2"> yum软件更新/镜像网站使用的原理</a></h3><p><code>yum</code>基于RPM软件包管理,<code>yum</code>会连线yum服务器上下载RPM软件清单(记录了各软件的相关信息与依赖关系),通过RPM软件界清单,直接下载我们需要的软件以及前驱软件</p>
<p>yum更新软件流程如下图
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_39_2.gif?raw=true" alt=""></p>
<ol>
<li>由yum配置文件(<code>/etc/yum.rrepos.d/*.repo</code>)判断yum服务器IP地址<ul>
<li>yum服务器可以是官网,或者一些镜像网站(对官网网站内容的拷贝,减轻官网的负担)</li>
<li>比如CentOS镜像列表:<a href="https://www.centos.org/download/mirrors/" target="_blank" rel="external">CentOS Mirror List</a></li>
</ul>
</li>
<li>连接到yum服务器后,先下载新的RPM软件清单</li>
<li>分析比较欲安装/升级的软件包,并提供用户确认</li>
<li>下载软件包到/var/cache/yum中,并进行实际安装</li>
<li>安装完毕,删除下载的软件包, 可以用<code>yum clean</code>手动删除</li>
</ol>
<h3 id="yum的使用-安装-搜索-软件群组-全系统更新"><a href="#yum的使用-安装-搜索-软件群组-全系统更新" class="headerlink" title=" yum的使用:安装/搜索/软件群组/全系统更新"></a><a name="ch2.3"> yum的使用:安装/搜索/软件群组/全系统更新</a></h3><p>yum除了可以安装升级软件外,其还提供了软件搜索以及软件群组等功能</p>
<p>yum指令的用法如下</p>
<ul>
<li>基本格式  <code>yum [options] [相关参数]</code><ul>
<li>一般options<ul>
<li><code>install</code>  安装指定的软件</li>
<li><code>update</code>  升级软件,后接软件名时,表指升级该软件,否则是全系统升级</li>
<li><code>remove</code>  移出软件</li>
<li><code>list</code>  列出所有可获得以及已安装的软件</li>
<li><code>search</code>  在RPM清单中搜索软件(即yum服务器上搜索)  本机搜索用<code>rpm -qa | grep &quot;keyword&quot;</code></li>
<li><code>info</code> 显示软件详细信息</li>
<li><code>clean</code> 清除<code>/var/cache/yum</code>中的安装包</li>
</ul>
</li>
<li>软件组options<ul>
<li><code>grouplist</code>  列出可使用的软件组</li>
<li><code>groupinfo</code> 显示软件组的详细信息</li>
<li><code>groupinstall</code> 安装软件组</li>
<li><code>groupremove</code> 移出软件组</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="选择特定的镜像网站-修改yum配置文件以及清除yum缓存"><a href="#选择特定的镜像网站-修改yum配置文件以及清除yum缓存" class="headerlink" title=" 选择特定的镜像网站:修改yum配置文件以及清除yum缓存"></a><a name="ch2.4"> 选择特定的镜像网站:修改yum配置文件以及清除yum缓存</a></h3><h4 id="找到镜像网站"><a href="#找到镜像网站" class="headerlink" title="找到镜像网站"></a>找到镜像网站</h4><p>首先我们要知道什么样的网站才是镜像网站,比如CentOS的镜像网站列表<a href="https://www.centos.org/download/mirrors/" target="_blank" rel="external">https://www.centos.org/download/mirrors/</a></p>
<p>但是我进入这个镜像网站里有好多目录,我该怎么做,比如下面这个北京理工大学的CentOS镜像网站
<a href="http://mirror.bit.edu.cn/centos/" target="_blank" rel="external">http://mirror.bit.edu.cn/centos/</a></p>
<p>我们先找到相对应的系统版本,比如我是CentOS7,进入后发现有好多目录,其实这些目录称为容器,提供某类型软件,比如操作系统软件<code>os</code>与一般软件<code>updates</code>这两个容器,其下面有一个<code>repodata</code>目录,那就是我们软件列表清单相关数据存放处</p>
<p>经过以上操作,我可以找到一个更新CentOS7的系统的容器<a href="http://mirror.bit.edu.cn/centos/7/os/x86_64/" target="_blank" rel="external">http://mirror.bit.edu.cn/centos/7/os/x86_64/</a></p>
<h4 id="修改配置文件-etc-yum-repos-d-repo"><a href="#修改配置文件-etc-yum-repos-d-repo" class="headerlink" title="修改配置文件/etc/yum.repos.d/*.repo"></a>修改配置文件<code>/etc/yum.repos.d/*.repo</code></h4><p>在<code>/etc/yum.repos.d</code>目录下新建或修改repo文件,比如我这个CentOS-Bit-Base.repo文件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[bit-base]  #容器名 不能同名</div><div class="line">name=CentOS-$releasever -Bit-Base  # 说明容器</div><div class="line">baseurl=http://mirror.bit.edu.cn/centos/7/os/x86_64/  #容器地址</div><div class="line">gpgcheck=1 #公匙相关</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7   </div><div class="line">enable=1   #启动这个容器</div><div class="line"></div><div class="line">#released updates </div><div class="line">[bit-updates]</div><div class="line">name=CentOS-$releasever -Bit-Updates</div><div class="line">baseurl=http://mirror.bit.edu.cn/centos/7/updates/x86_64/</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line">enable=1</div></pre></td></tr></table></figure></p>
<h4 id="查看容器是否启动与清除历史缓存"><a href="#查看容器是否启动与清除历史缓存" class="headerlink" title="查看容器是否启动与清除历史缓存"></a>查看容器是否启动与清除历史缓存</h4><ul>
<li>查看容器是否启动  <code>yum repolist all</code></li>
<li>清除历史缓存  <code>yum clean all</code></li>
</ul>
<h2 id="限制服务端口"><a href="#限制服务端口" class="headerlink" title=" 限制服务端口"></a><a name="ch3"> 限制服务端口</a></h2><h3 id="什么是端口-port"><a href="#什么是端口-port" class="headerlink" title=" 什么是端口(port)"></a><a name="ch3.1"> 什么是端口(port)</a></h3><p>当你启动一个服务时,这个服务根据TCP/IP相关协议启动一个端口(port)在监听,也就是说端口提供服务
端口有以下特点</p>
<ul>
<li>服务器启动的端口以及对应的服务是固定的,<code>/etc/services</code>可以查看</li>
<li>客户端连接服务器端口时,随机启动一个大于1024的端口连接</li>
<li>一个服务器可以同时提供多种服务</li>
<li>一共有65536个端口,TCP/UDP包中端口号占16位,固一台主机有2^16个端口<ul>
<li>只有root才能启动小于1024端口</li>
<li>大于1024端口用于客户端请求</li>
</ul>
</li>
<li>服务器端可以启用非正规端口提供服务,客户端连接时须指定端口</li>
<li>是否要可靠连接TCP</li>
</ul>
<h3 id="查看端口-netstat-nmap"><a href="#查看端口-netstat-nmap" class="headerlink" title=" 查看端口:netstat/nmap"></a><a name="ch3.2"> 查看端口:netstat/nmap</a></h3><ul>
<li><code>netstat</code> ： 查看本机上面启动的端口<ul>
<li>列出正在监听的网络服务 <code>netstat -tulnp</code></li>
<li>列出已连线的网络服务连线状态 <code>netstat -tun</code></li>
<li>删除已连线的网络服务的连线 <code>netstat -tunp</code>+<code>kill -9 pid</code></li>
</ul>
</li>
<li><code>nmap</code> 侦测网络上其他主机启动的端口,通常是同子网内主机的检测(不要去扫其他人主机,会违法的)<ul>
<li>以TCP中的ping扫描主机状态 <code>nmap [ip|hostname|(network/netIDNum)]  -PT</code></li>
<li>以ICMP扫描主机状态  <code>nmap [ip|hostname|(network/netIDNum)]  -sP</code></li>
</ul>
</li>
</ul>
<h3 id="服务的启动-关闭"><a href="#服务的启动-关闭" class="headerlink" title=" 服务的启动/关闭"></a><a name="ch3.3"> 服务的启动/关闭</a></h3><p>请查看<a href="https://github.com/HiKumho/blog/issues/28" target="_blank" rel="external">Linux 学习之认识系统服务(daemon)</a></p>
<h2 id="被攻击后主机修复工作"><a href="#被攻击后主机修复工作" class="headerlink" title=" 被攻击后主机修复工作"></a><a name="ch4"> 被攻击后主机修复工作</a></h2><h3 id="网管应具备的能力"><a href="#网管应具备的能力" class="headerlink" title=" 网管应具备的能力"></a><a name="ch4.1"> 网管应具备的能力</a></h3><ul>
<li>了解什么时需要保护的内容</li>
<li>预防黑客的入侵</li>
<li>主机环境安全化</li>
<li>防火墙规则的设置</li>
<li>即时维护主机</li>
<li>良好的教育训练课程</li>
<li>完善的备份计划</li>
</ul>
<h3 id="主机受攻击后复原工作流程"><a href="#主机受攻击后复原工作流程" class="headerlink" title=" 主机受攻击后复原工作流程"></a><a name="ch4.2"> 主机受攻击后复原工作流程</a></h3><ul>
<li>立即拔除网线</li>
<li>分析日志文件,搜索可能的入侵途径</li>
<li>重要资料备份</li>
<li>重新安装系统</li>
<li>软件漏洞修补</li>
<li>关闭/移出不需要的服务</li>
<li>资料的恢复与服务设置</li>
<li>连上Internet</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网络数据包连线进入主机的过程&quot;&gt;&lt;a href=&quot;#网络数据包连线进入主机的过程&quot; class=&quot;headerlink&quot; title=&quot; 网络数据包连线进入主机的过程&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt; 网络数据包连线进入主机的过程&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;当网
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务器篇 常用的网络指令</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2016/09/06/Linux-服务器篇-常用的网络指令/</id>
    <published>2016-09-06T14:43:20.000Z</published>
    <updated>2016-09-06T14:45:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络参数设置使用的指令"><a href="#网络参数设置使用的指令" class="headerlink" title=" 网络参数设置使用的指令"></a><a name="ch1"> 网络参数设置使用的指令</a></h2><h3 id="设置IP参数与启动-关闭网络接口-ifconfig-ifup-ifdown"><a href="#设置IP参数与启动-关闭网络接口-ifconfig-ifup-ifdown" class="headerlink" title=" 设置IP参数与启动/关闭网络接口:ifconfig/ifup/ifdown"></a><a name="ch1.1"> 设置IP参数与启动/关闭网络接口:ifconfig/ifup/ifdown</a></h3><ul>
<li><code>ifconfig</code>  查看/设置/启动关闭网络接口 (设置的参数保存在<b>内存</b>中)<ul>
<li><code>ifconfig [interface(如eth0/wlan0)]</code>  查看网络接口信息<ul>
<li>注意interface可以是同张网卡的别名,比如<code>eth0:v1</code></li>
</ul>
</li>
<li><code>ifconfig [interface] {up|down}</code>  启动/关闭网络接口,设置时需先关闭网络接口</li>
<li><code>ifconfig [interface] {options}</code> 设置网络接口信息<ul>
<li><code>直接接ip地址</code></li>
<li><code>mtu</code> 后接mtu数值<ul>
<li><code>netmask</code> 子网掩码</li>
<li><code>boradcast</code> 广播地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>ifup/ifdown</code> 启动/关闭网络接口<ul>
<li>与<code>ifconfig</code>的启动关闭不同,其是参考/etc中的网络参数配置文件</li>
<li>当内存中<code>/proc/net</code>与<code>/etc</code>中的配置文件参数不同时,就会报错</li>
<li>格式是<code>ifup/ifdown [interface]</code></li>
</ul>
</li>
</ul>
<h3 id="路由修改-route"><a href="#路由修改-route" class="headerlink" title=" 路由修改:route"></a><a name="ch1.2"> 路由修改:route</a></h3><p><code>route</code> 查看/设置路由表,同样的其设置的参数是保存在内存中的,要静态修改路由可以写入配置文件<code>/etc/sysconfig/network-script/route-interface(CentOS)</code>或<code>/etc/network/interface(Ubuntu)</code></p>
<h4 id="查看路由表-route-n-ee-n是直接用IP和port显示主机名"><a href="#查看路由表-route-n-ee-n是直接用IP和port显示主机名" class="headerlink" title="查看路由表: route {-n|-ee} -n是直接用IP和port显示主机名"></a>查看路由表: <code>route {-n|-ee}</code> -n是直接用IP和port显示主机名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">目标            网关            子网掩码        标志  跃点   引用  使用 接口</div><div class="line">192.168.14.0    0.0.0.0         255.255.254.0   U     1      0        0 eth0</div><div class="line">10.42.0.0       0.0.0.0         255.255.255.0   U     9      0        0 wlan0</div><div class="line">0.0.0.0         192.168.14.1    0.0.0.0         UG    0      0        0 eth0</div></pre></td></tr></table></figure>
<p>上面参数的说明</p>
<ul>
<li><code>目标(Destination)</code> 网段IP地址(network)或主机IP,<code>0.0.0.0</code>表缺省</li>
<li><code>网关(Gateway)</code> 是路由器IP(邮局2333),需同本机同一个子域网内,<code>0.0.0.0</code>表本机</li>
<li><code>子网掩码(Genmask)</code> 标识网段</li>
<li><code>标志(Flags)</code><ul>
<li><code>U</code> 此路由已启动</li>
<li><code>H</code> 目标是一部主机非域网</li>
<li><code>G</code> 通过网关/路由器转包</li>
<li><code>R</code> 使用动态路由时,恢复路由信息</li>
<li><code>D</code> 已被设置为动态路由</li>
<li><code>M</code> 路由已被修改</li>
<li><code>!</code> 此路由不会被接受</li>
</ul>
</li>
<li><code>接口(Iface)</code> 此路由使用的接口</li>
</ul>
<p><b>注意: 路由表的编写应该要有顺序,由上到下从C类IP到A类IP,这样数据包传输时,会更准确</b></p>
<h4 id="路由的增加-删除"><a href="#路由的增加-删除" class="headerlink" title="路由的增加/删除"></a>路由的增加/删除</h4><ul>
<li>增加路由 <code>route add {-net|-host} {网段或主机IP} netmask {mask} dev {interface} [gw] {网关IP}</code></li>
<li>删除路由 <code>route del {-net|-host} {网段或主机IP} netmask {mask} dev {interface}</code></li>
</ul>
<h3 id="网络参数综合指令-ip"><a href="#网络参数综合指令-ip" class="headerlink" title=" 网络参数综合指令:ip"></a><a name="ch1.3"> 网络参数综合指令:ip</a></h3><p><code>ip</code>整合了<code>ifconfig</code>与<code>route</code>,且功能上比它们更多</p>
<p><code>ip</code>可以查看/设置3部分的内容:</p>
<ul>
<li><code>link</code> 关于网卡,包括MAC</li>
<li><code>addr</code> 关于IP参数</li>
<li><code>route</code> 关于路由表</li>
</ul>
<h4 id="查看-设置网卡参数-ip-link"><a href="#查看-设置网卡参数-ip-link" class="headerlink" title="查看/设置网卡参数: ip link"></a>查看/设置网卡参数: ip link</h4><ul>
<li>查看网卡参数 <code>ip [-s] link show</code></li>
<li>设置网卡参数 <code>ip link set {interface} [options]</code><ul>
<li><code>up|down</code> 启动/关闭网卡接口</li>
<li><code>address</code> 修改MAC</li>
<li><code>name</code>  网卡接口的特殊名字</li>
<li><code>mtu</code> 修改mtu</li>
</ul>
</li>
</ul>
<h4 id="查看-设置IP参数-ip-address"><a href="#查看-设置IP参数-ip-address" class="headerlink" title="查看/设置IP参数:ip address"></a>查看/设置IP参数:ip address</h4><ul>
<li>查看网卡参数 <code>ip [-s] address show</code></li>
<li>设置网卡参数 <code>ip address {add|del} {ip地址}  dev {interface} [options]</code><ul>
<li><code>broadcast</code> 广播地址 <code>+</code>表自动计算</li>
<li><code>label</code> 网络接口别名</li>
<li><code>name</code>  网卡接口的特殊名字</li>
<li><code>scope</code><ul>
<li><code>global</code> 允许来自所有来源的连线</li>
<li><code>link</code> 仅允许本接口的自我连线</li>
<li><code>host</code> 仅允许本主机内部的连线</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查看-设置路由表-ip-route"><a href="#查看-设置路由表-ip-route" class="headerlink" title="查看/设置路由表:ip route"></a>查看/设置路由表:ip route</h4><ul>
<li>查看路由表 <code>ip route show</code></li>
<li>设置路由表 <code>ip route [add|del] [子网或主机IP] [via 网关IP] [dev 接口]</code></li>
</ul>
<h3 id="无线网络-iwlist-iwconfig"><a href="#无线网络-iwlist-iwconfig" class="headerlink" title=" 无线网络:iwlist/iwconfig"></a><a name="ch1.4"> 无线网络:iwlist/iwconfig</a></h3><ul>
<li><code>iwconfig</code>   设置无线网络</li>
<li><code>iwlist</code> 侦测无线基站(AP,热点)<ul>
<li><code>iwlist [interface(如wlan0)] scan</code></li>
</ul>
</li>
</ul>
<h3 id="使用dchp自动取得IP参数-dhclient"><a href="#使用dchp自动取得IP参数-dhclient" class="headerlink" title=" 使用dchp自动取得IP参数:dhclient"></a><a name="ch1.5"> 使用dchp自动取得IP参数:dhclient</a></h3><p>让某个网络接口发送dhcp要求取得IP参数:<code>dhclient [interface]</code></p>
<h2 id="网络侦测与观察指令"><a href="#网络侦测与观察指令" class="headerlink" title=" 网络侦测与观察指令"></a><a name="ch2"> 网络侦测与观察指令</a></h2><h3 id="两主机两点连通测试与追踪路径中的MTU最大值：ping"><a href="#两主机两点连通测试与追踪路径中的MTU最大值：ping" class="headerlink" title=" 两主机两点连通测试与追踪路径中的MTU最大值：ping"></a><a name="ch2.1"> 两主机两点连通测试与追踪路径中的MTU最大值：ping</a></h3><h4 id="测试两主机是否连通-ping-IP-hostname"><a href="#测试两主机是否连通-ping-IP-hostname" class="headerlink" title="测试两主机是否连通:ping [IP|hostname]"></a>测试两主机是否连通:<code>ping [IP|hostname]</code></h4><p>ping会发送一个ICMP包(其装入IP包中)来进行网络状态的测试,利用ICMP包返回的信息来进行分析</p>
<p>其中比较重要的是<code>ttl</code>参数,表示数据包经过的路由器数(经过一个就减1)
当目标主机与本机同一个域网内,ttl预设64,否则预设255</p>
<h4 id="测试路径能通过的最大MTU-ping-IP-hostname-s-MTU测试值-M-do-不进行拆包处理"><a href="#测试路径能通过的最大MTU-ping-IP-hostname-s-MTU测试值-M-do-不进行拆包处理" class="headerlink" title="测试路径能通过的最大MTU:ping [IP|hostname] -s MTU测试值 -M do(不进行拆包处理)"></a>测试路径能通过的最大MTU:<code>ping [IP|hostname] -s MTU测试值 -M do(不进行拆包处理)</code></h4><p>如果MTU测试值太大就会报错</p>
<h3 id="两主机间各节点的分析：traceroute"><a href="#两主机间各节点的分析：traceroute" class="headerlink" title=" 两主机间各节点的分析：traceroute"></a><a name="ch2.2"> 两主机间各节点的分析：traceroute</a></h3><p><code>traceroute [IP|hostname]</code> 跟踪两主机间各节点的信息</p>
<p>默认traceroute预设UDP包来进行测试,只是现在很多路由器会过滤UDP/ICMP的回应
我们可以用TCP包来测试,只要加上<code>-T</code>参数 </p>
<h3 id="查看本机的网络连接与后面：netstat"><a href="#查看本机的网络连接与后面：netstat" class="headerlink" title=" 查看本机的网络连接与后面：netstat"></a><a name="ch2.3"> 查看本机的网络连接与后面：netstat</a></h3><ul>
<li><code>netstat -nlptu</code>  输出目前本机已启动的网络服务</li>
<li><code>netstat -atunp</code> 查看本机所有网络连线状态</li>
</ul>
<h3 id="查看主机名与IP：host-nslookup-dig"><a href="#查看主机名与IP：host-nslookup-dig" class="headerlink" title=" 查看主机名与IP：host/nslookup/dig"></a><a name="ch2.4"> 查看主机名与IP：host/nslookup/dig</a></h3><ul>
<li><code>host hostname [DNS IP]</code>: 查看对应主机的IP,默认以<code>/etc/resolv.conf</code>设置的DNS服务器查询</li>
<li><code>nslookup [hostname|IP]</code> 查看主机名或IP的信息</li>
<li><code>dig [hostname|IP]</code> 查看主机名或IP的信息</li>
</ul>
<h2 id="远端连线指令"><a href="#远端连线指令" class="headerlink" title=" 远端连线指令"></a><name="ch3"> 远端连线指令</name="ch3"></h2><p>这里的远端连线,连接到对方的服务器上,获取资源等操作
传统的连线指令有<code>telnet</code>与<code>ftp</code>等,由于其使用明文传输,安全性较低,<code>ssh</code>针对这方面进行加强</p>
<ul>
<li><code>telnet</code>  比较常用与BBS<ul>
<li><code>telnet [host|IP] [port]</code></li>
</ul>
</li>
<li><code>ftp</code>  传输较大的资料<ul>
<li><code>ftp [host|IP] [port]</code></li>
</ul>
</li>
<li><code>lftp</code> 自动化ftp脚本<ul>
<li>由于我们连接到目标的ftp服务器后,其操作都要参考目标服务器的设置,lftp能自动化处理</li>
<li><code>lftp [host|IP] [port] [-u user[,pass]] -c &quot;commands&quot;</code><ul>
<li>我们将要执行的操作写入commands中,每条指令到要分行</li>
</ul>
</li>
</ul>
</li>
<li><code>ssh</code> 为Shell提供安全的传输和使用环境,传输的数据经压缩<ul>
<li><code>ssh [host|IP] [port]</code></li>
</ul>
</li>
</ul>
<h2 id="文字界面网页浏览器-下载器"><a href="#文字界面网页浏览器-下载器" class="headerlink" title=" 文字界面网页浏览器/下载器"></a><a name="ch4"> 文字界面网页浏览器/下载器</a></h2><p>我们在命令行中要想浏览html页面,可以使用<code>links</code></p>
<p>而要下载网络资源可以使用<code>wget</code>或<code>axel</code>
其中<code>axel</code>有断点续传的功能,而<code>wget</code>没有</p>
<h2 id="数据包抓取"><a href="#数据包抓取" class="headerlink" title=" 数据包抓取"></a><a name="ch5"> 数据包抓取</a></h2><h3 id="对网络连线TCP-UDP读写-nc-netcat"><a href="#对网络连线TCP-UDP读写-nc-netcat" class="headerlink" title=" 对网络连线TCP/UDP读写:nc,netcat"></a><a name="ch5.1"> 对网络连线TCP/UDP读写:nc,netcat</a></h3><ul>
<li>启动服务端口:<code>nc -l [ip|hostname] [port]</code></li>
<li>连接服务端口:<code>nc [ip|hostname] [port]</code>(类似telnet)</li>
</ul>
<p>两个端口建立连线后,就可以传输数据,比如:
透过端口3333（-l 监听状态listen）从机器foo复制到机器bar复制档案：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user@bar$ nc -l -p 3333 &gt; backup.iso</div><div class="line">user@foo$ nc bar 3333 &lt; backup.iso</div></pre></td></tr></table></figure></p>
<p>利用零模式I/O（参数 -z）检查192.168.0.1的UDP端口（参数 -u）80-90是否开启：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nc -vzu 192.168.0.1 80-90</div></pre></td></tr></table></figure></p>
<h3 id="抓取TCP数据包-tcpdump-wireshark"><a href="#抓取TCP数据包-tcpdump-wireshark" class="headerlink" title=" 抓取TCP数据包:tcpdump/wireshark"></a><a name="ch5.2"> 抓取TCP数据包:tcpdump/wireshark</a></h3><ul>
<li><code>tcpdump</code>  会监听某个网络接口上传输的数据包,并将其抓取进行分析<ul>
<li>格式 <code>tcpdump [-i 网络接口] [-w 存取本地文件] [-r 读取保存本地的文件] [-Aennqx] [-c 监听数据包数量]</code><ul>
<li><code>A</code> 以ASCII显示数据包内容,通常用于抓取网页数据包</li>
<li><code>e</code>  以MAC帧数据来显示</li>
<li><code>nn</code> 直接以IP/port显示主机名与服务名</li>
<li><code>q</code> 简短的数据包信息</li>
<li><code>X</code> 以十六进制与ASCII显示数据包内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>而wireshark是图形界面下的抓包工具</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网络参数设置使用的指令&quot;&gt;&lt;a href=&quot;#网络参数设置使用的指令&quot; class=&quot;headerlink&quot; title=&quot; 网络参数设置使用的指令&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt; 网络参数设置使用的指令&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;设置IP参数与启动
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务器篇 连接Internet</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87-%E8%BF%9E%E6%8E%A5Internet/"/>
    <id>http://yoursite.com/2016/09/06/Linux-服务器篇-连接Internet/</id>
    <published>2016-09-06T14:39:54.000Z</published>
    <updated>2016-09-06T14:41:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-连接Internet-驱动网卡"><a href="#Linux-连接Internet-驱动网卡" class="headerlink" title=" Linux 连接Internet : 驱动网卡"></a><a name="ch1"> Linux 连接Internet : 驱动网卡</a></h2><p>当我们想要连接上Internet时,首先需要确保Linux已经驱动了网卡,之后才是设置网络参数</p>
<h3 id="查看Linux是否驱动网卡"><a href="#查看Linux是否驱动网卡" class="headerlink" title=" 查看Linux是否驱动网卡"></a><a name="ch1.1"> 查看Linux是否驱动网卡</a></h3><p>要确保自己机器上已经有网卡了,之后使用<code>dmesg | grep eth</code>查看网卡信息(注意有线网卡设备名是eth0…ethN)</p>
<p>比如我机器上的<code>RTL8105e</code>螃蟹卡,而对应的内核模块(驱动程序)是<code>r8169</code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[  1.223558] r8169 0000:09:00.0 eth0: RTL8105e at 0xf845c000, e0:db:55:ab:6b:29, XID 00c00000 IRQ 27</div></pre></td></tr></table></figure></p>
<p>可以通过<code>lsmod | grep r8169</code>查看是否该模块有加载至内核中,如果要查看详细模块信息可以<code>modinfo r8169</code></p>
<h3 id="编译驱动网卡模块"><a href="#编译驱动网卡模块" class="headerlink" title=" 编译驱动网卡模块"></a><a name="ch1.2"> 编译驱动网卡模块</a></h3><p>一般来说,如果我们的网卡被Linux驱动,可能就要去找此张网卡相对的驱动程序,再自行编译。</p>
<p>不太推荐自行编译网卡驱动,毕竟升级内核时,又需要重新编译一次自行编译的程序,通常都是购买Linux支持的网卡</p>
<p>以下说明自行编译网卡驱动程序的过程</p>
<h4 id="取得官方驱动程序包"><a href="#取得官方驱动程序包" class="headerlink" title="取得官方驱动程序包"></a>取得官方驱动程序包</h4><p>比如这里取得的是驱动程序源码</p>
<h4 id="解压缩与编译安装"><a href="#解压缩与编译安装" class="headerlink" title="解压缩与编译安装"></a>解压缩与编译安装</h4><p>解压源码包,通过读README等文件知道编译过程,通常使用config与make编译安装程序(这里是内核模块)</p>
<h4 id="加载内核模块"><a href="#加载内核模块" class="headerlink" title="加载内核模块"></a>加载内核模块</h4><p>利用<code>depmod</code>与<code>modprobe</code>加载内核模块至内核</p>
<p>详细过程请看</p>
<ul>
<li><a href="https://github.com/HiKumho/blog/issues/31#ch1.4" target="_blank" rel="external">什么是软件的tarball及其安装过程</a></li>
<li><a href="https://github.com/HiKumho/blog/issues/30#ch4" target="_blank" rel="external">内核与内核模块</a></li>
</ul>
<h2 id="Linux-连接Internet-设置网络参数"><a href="#Linux-连接Internet-设置网络参数" class="headerlink" title=" Linux 连接Internet : 设置网络参数"></a><a name="ch2"> Linux 连接Internet : 设置网络参数</a></h2><p>我们知道TCP/IP的重要参数主要有:IP/Netmask/Gateway/DNS IP 此外还有主机名(hostname)与本地保存的域名与IP对应关系(host)</p>
<h3 id="Linux的网络参数配置文件"><a href="#Linux的网络参数配置文件" class="headerlink" title=" Linux的网络参数配置文件"></a><a name="ch2.1"> Linux的网络参数配置文件</a></h3><p>CentOS下,它们的配置文件如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">设置的网络参数</th>
<th style="text-align:center">文件名</th>
<th style="text-align:center">重要参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IP/Netmask/DHCP/Gateway等</td>
<td style="text-align:center">/etc/sysconfig/network-scripts/ifcfg-eth0</td>
<td style="text-align:center">DEVICE=网卡设备名(这里是eth0)<br>BOOTPROTO=是否使用dhcp(自动获取网络参数)<br>HWADDR=网卡MAC<br>IPADDR=IP地址<br>NETMASK=子网掩码<br>ONBOOT=预设使用此文件设置的参数<br>GATEWAY=网关IP<br>NM_CONTROLLED=额外的网管软件</td>
</tr>
<tr>
<td style="text-align:center">主机名称</td>
<td style="text-align:center">/etc/sysconfig/network</td>
<td style="text-align:center">NETWORKING=要不要有网络<br>NETWORKING_IPV6=支持IPV6<br>HOSTNAME=主机名</td>
</tr>
<tr>
<td style="text-align:center">DNS IP</td>
<td style="text-align:center">/etc/resolv.conf</td>
<td style="text-align:center">nameserver DNS的IP</td>
</tr>
<tr>
<td style="text-align:center">本地保存的主机名与IP对应表</td>
<td style="text-align:center">/etc/hosts</td>
<td style="text-align:center">IP 主机名称 别名</td>
</tr>
</tbody>
</table>
<p>Ubuntu下,它们的配置文件如上相似,主要是</p>
<ul>
<li><code>IP/Netmask等</code>  在<code>/etc/network/interfaces(默认设置)</code>与<code>/etc/NetworkManager/system-connections/(各网络接口的设置)</code></li>
<li><code>主机名称</code>  在<code>/etc/hostname</code>中</li>
</ul>
<p>以下是一个/etc/network/interfaces配置文件,可以配置dns/路由表/网络接口等参数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># This file describes the network interfaces available on your system</div><div class="line"># and how to activate them. For more information, see interfaces(5).</div><div class="line"></div><div class="line"># The loopback network interface</div><div class="line">auto lo</div><div class="line">iface lo inet loopback</div><div class="line"></div><div class="line"># The primary network interface</div><div class="line">auto eth0</div><div class="line">iface eth0 inet static</div><div class="line">address xxx.xxx.xxx.xxx</div><div class="line">netmask xxx.xxx.xxx.xxx</div><div class="line">gateway xxx.xxx.xxx.xxx</div><div class="line"></div><div class="line">auto eth0:0</div><div class="line">iface eth0:0 inet static</div><div class="line">address xxx.xxx.xxx.xxx</div><div class="line">netmask xxx.xxx.xxx.xxx</div><div class="line"></div><div class="line">#dns-nameservers 202.102.224.68 202.102.227.68</div><div class="line">up route add -net xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx gw xxx.xxx.xxx.xxx eth0</div><div class="line">up route add -net xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx gw xxx.xxx.xxx.xxx eth0</div><div class="line">up route add -net xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx gw xxx.xxx.xxx.xxx eth0</div></pre></td></tr></table></figure></p>
<p>除了上面的文件外,还有以下较重要的文件</p>
<ul>
<li><code>/etc/services</code>  定义服务与端口对应</li>
<li><code>/etc/protocols</code>  定义IP包相关协议资料</li>
</ul>
<h3 id="启动网络服务"><a href="#启动网络服务" class="headerlink" title=" 启动网络服务"></a><a name="ch2.2"> 启动网络服务</a></h3><p>当我们更新好网络参数配置文件后,当然要重启网络服务啦！
有以下两种方式</p>
<ul>
<li><code>/etc/init.d/network restart</code> 重启整个网络服务</li>
<li><code>ifup eth0(ifdown eth0)</code>  只启动或关闭某个网络接口</li>
</ul>
<h3 id="手动设置固定IP参数"><a href="#手动设置固定IP参数" class="headerlink" title=" 手动设置固定IP参数"></a><a name="ch2.3"> 手动设置固定IP参数</a></h3><p>如上面我们可以知道要手动设置固定IP参数,就是修改其的配置文件,以下是修改网络参数涉及到的配置文件/启动脚本和测试命令表</p>
<table>
<thead>
<tr>
<th style="text-align:center">修改的参数</th>
<th style="text-align:center">配置文件与启动脚本</th>
<th style="text-align:center">测试命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IP相关参数</td>
<td style="text-align:center">/etc/sysconfig/network-scripts/ifcfg-eth0<br>/etc/init.d/network restart</td>
<td style="text-align:center">ifconfig(查看IP参数)<br>route(查看网关)<br>ping 网关IP</td>
</tr>
<tr>
<td style="text-align:center">DNS IP</td>
<td style="text-align:center">/etc/reslov.conf</td>
<td style="text-align:center">dig www.google.com</td>
</tr>
<tr>
<td style="text-align:center">主机名称</td>
<td style="text-align:center">/etc/sysconfig/network<br>/etc/hosts</td>
<td style="text-align:center">hostname (获取主机名)<br> ping $(hostname)<br> reboot</td>
</tr>
</tbody>
</table>
<p>这里注意的是IP相关参数时设置的网关,每个接口都有一样(或者只设置一个),避免互相干扰</p>
<h3 id="自动取得IP参数-DHCP"><a href="#自动取得IP参数-DHCP" class="headerlink" title=" 自动取得IP参数:DHCP"></a><a name="ch2.4"> 自动取得IP参数:DHCP</a></h3><p>DHCP就是有一部主机提供DHCP服务给整个网域下的主机,比如IP分享器就是一个DHCP主机,其会提供IP参数与DNS参数,所以不需要额外设置</p>
<p>将<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>中<code>BOOTPROTO</code>设置为<code>dhcp</code>就启动了<code>eth0</code>为DHCP连接,然后将IP/子网掩码/网关等都去掉(特别是网关)</p>
<h3 id="ADSL拨号连网"><a href="#ADSL拨号连网" class="headerlink" title=" ADSL拨号连网"></a><a name="ch2.5"> ADSL拨号连网</a></h3><p>ADSL拨号连网需要使用<code>rp-pppoe</code>这个软件帮忙,其拨号成功后会产生一个<code>ppp0</code>接口,其是架设在以太网卡(<code>eth0</code>)上的,所以<code>eth0</code>不能关闭,但是要一定要将eth0设置的网关去掉,<code>ppp0</code>会提供一个网关</p>
<ul>
<li>当网卡有Private IP又要拨号上网时<ul>
<li>仍是使用此预设启动网卡<code>ONBOOT=yes</code></li>
<li>仍设置IP与子网掩码,都是局域网的参数</li>
<li>不设置网关</li>
<li>之后设置<code>pppoe-setup</code>拨号参数</li>
<li><code>pppoe-start</code>来进行拨号上网</li>
<li>这样局域网内的主机可以通过此网卡连上Internet</li>
</ul>
</li>
<li>如果要两张网卡,就可以<ul>
<li>对外网卡预设不启动<code>ONBOOT=no</code></li>
<li>对外网卡进行拨号</li>
<li>对内网卡设置局域网IP参数</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux-连接Internet-驱动网卡&quot;&gt;&lt;a href=&quot;#Linux-连接Internet-驱动网卡&quot; class=&quot;headerlink&quot; title=&quot; Linux 连接Internet : 驱动网卡&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt; Linux
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务器篇 局域网架设简介</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%9E%B6%E8%AE%BE%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2016/09/06/Linux-服务器篇-局域网架设简介/</id>
    <published>2016-09-06T14:37:24.000Z</published>
    <updated>2016-09-06T14:38:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="局域网的连线"><a href="#局域网的连线" class="headerlink" title=" 局域网的连线"></a><a name="ch1"> 局域网的连线</a></h2><p>以下章节我们是谈到小型局域网的布线规划,而大型企业内部网络的架设需要相当多的专业知识(如线路设计,配线盘,墙上打网线孔等)我们只能放着</p>
<p>以下的布线是以星型连线架构设计的</p>
<h3 id="Linux直接联网-与一般PC同地位"><a href="#Linux直接联网-与一般PC同地位" class="headerlink" title=" Linux直接联网-与一般PC同地位"></a><a name="ch1.1"> Linux直接联网-与一般PC同地位</a></h3><p>当我们拥有多Public IP(ADSL拨接给予多个IP)时可以使用以下的连接方式,Linux与一般PC同地位,<b>它们都具有一个Public IP与Private IP</b>,所以服务器挂机后,不会影响其他PC,这种方式管理上困难</p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/blog_36_1.png?raw=true" alt=""></p>
<h3 id="Linux直接联网-与一般PC分开网域"><a href="#Linux直接联网-与一般PC分开网域" class="headerlink" title=" Linux直接联网-与一般PC分开网域"></a><a name="ch1.2"> Linux直接联网-与一般PC分开网域</a></h3><p>同样是当我们拥有多Public IP时可以使用的连接方式,一般PC放在同一个子网内,内部传输没有问题,外部连接时通过IP分享器,获取Public IP,而Linux在它们的上层网络,更易于管理子网内PC的连接</p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/blog_36_2.png?raw=true" alt=""></p>
<h3 id="Linux直接联网-让Linux直接管理LAN"><a href="#Linux直接联网-让Linux直接管理LAN" class="headerlink" title=" Linux直接联网-让Linux直接管理LAN"></a><a name="ch1.3"> Linux直接联网-让Linux直接管理LAN</a></h3><p>以下连接方式不管你是否有多个Public IP都使用,让Linux直接管理LAN,而且可以作为防火墙,<b>要求是Linux服务器必须具有两张以上的网卡</b>,对外使用Public IP,对内使用Private IP,当然你一张网卡有两个网络接口也行</p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/blog_36_3.png?raw=true" alt=""></p>
<h3 id="Linux放在防火墙后-让Linux使用Private-IP"><a href="#Linux放在防火墙后-让Linux使用Private-IP" class="headerlink" title=" Linux放在防火墙后-让Linux使用Private IP"></a><a name="ch1.4"> Linux放在防火墙后-让Linux使用Private IP</a></h3><p>让Linux服务器在LAN中,让防火墙过滤连接,将数据包重新导向进入服务器,这种连线方式在大型企业内部常见</p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/blog_36_4.png?raw=true" alt=""></p>
<h2 id="网络设备选购建议"><a href="#网络设备选购建议" class="headerlink" title=" 网络设备选购建议"></a><a name="ch2"> 网络设备选购建议</a></h2><ul>
<li><code>主机硬件系统</code>   考虑使用年限/省电/虚拟化功能(虚拟机)等</li>
<li><code>Linux操作系统</code>  考虑稳定/可网络升级/能够快速取得协助支援</li>
<li><code>网卡</code> 考虑服务器用途/是否内建/驱动程序取得等</li>
<li><code>Switch/Hub</code>  考虑主机数量/防火墙/传输频宽</li>
<li><code>网线</code>   考虑与速度相配的等级/线材/施工配线等</li>
<li><code>无线网络相关设备</code>  考虑速度/安全性/标准等</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;局域网的连线&quot;&gt;&lt;a href=&quot;#局域网的连线&quot; class=&quot;headerlink&quot; title=&quot; 局域网的连线&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt; 局域网的连线&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;以下章节我们是谈到小型局域网的布线规划,而大型企业内部网络的架设需要
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Linux 建立虚拟WiFi</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E5%BB%BA%E7%AB%8B%E8%99%9A%E6%8B%9FWiFi/"/>
    <id>http://yoursite.com/2016/09/06/Linux-建立虚拟WiFi/</id>
    <published>2016-09-06T14:35:03.000Z</published>
    <updated>2016-09-06T14:35:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>今天想在Linux下建立虚拟WiFi,共享给手机使用.自己的操作环境是Ubuntu14.04</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="先确保已连上Internet-以及启动WiFi"><a href="#先确保已连上Internet-以及启动WiFi" class="headerlink" title="先确保已连上Internet,以及启动WiFi"></a>先确保已连上Internet,以及启动WiFi</h4><p>在Ubuntu的右上角Network管理中<code>启动联网</code>以及<code>启动Wi-Fi</code></p>
<h4 id="建立一个WiFi连接"><a href="#建立一个WiFi连接" class="headerlink" title="建立一个WiFi连接"></a>建立一个WiFi连接</h4><p>新建一个连接WiFi连接
<img src="https://github.com/HiKumho/blog/blob/master/img/%E5%85%B1%E4%BA%ABWIFI/%E5%85%B1%E4%BA%ABWIFI_1.png?raw=true" alt=""></p>
<h4 id="配置已新建的WiFi连接"><a href="#配置已新建的WiFi连接" class="headerlink" title="配置已新建的WiFi连接"></a>配置已新建的WiFi连接</h4><p>对新建的WiFi连接进行如下配置,其中<code>SSID</code>就是WiFi名  <code>WIFI安全性的密码</code>就是WiFi的密码</p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/%E5%85%B1%E4%BA%ABWIFI/%E5%85%B1%E4%BA%ABWIFI_2.png?raw=true" alt=""></p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/%E5%85%B1%E4%BA%ABWIFI/%E5%85%B1%E4%BA%ABWIFI_3.png?raw=true" alt=""></p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/%E5%85%B1%E4%BA%ABWIFI/%E5%85%B1%E4%BA%ABWIFI_4.png?raw=true" alt=""></p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/%E5%85%B1%E4%BA%ABWIFI/%E5%85%B1%E4%BA%ABWIFI_5.png?raw=true" alt=""></p>
<h4 id="修改新建WiFi的配置文件"><a href="#修改新建WiFi的配置文件" class="headerlink" title="修改新建WiFi的配置文件"></a>修改新建WiFi的配置文件</h4><p>取得root权限,修改上面新建WiFi的配置文件<code>sudo vim /etc/NetworkManager/system-connections/WIFI1</code> 将其中<code>mode</code>属性值改为<code>ap</code>,如<code>mode=ap</code>,保存</p>
<h5 id="连接新建WiFi"><a href="#连接新建WiFi" class="headerlink" title="连接新建WiFi"></a>连接新建WiFi</h5><p>在Network管理上<code>连接到隐藏的Wi-Fi网络</code>选中新建的WiFi,就可以在手机上面扫描并连接上此WiFi</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://ubuntuhandbook.org/index.php/2014/09/3-ways-create-wifi-hotspot-ubuntu/" target="_blank" rel="external">3 Ways to Create Wifi Hotspot in Ubuntu 14.04 (Android Support)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;今天想在Linux下建立虚拟WiFi,共享给手机使用.自己的操作环境是Ubuntu14.04&lt;/p&gt;
&lt;h3 id=&quot;过程&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务器篇 基础网络概念</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87-%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2016/09/06/Linux-服务器篇-基础网络概念/</id>
    <published>2016-09-06T14:02:17.000Z</published>
    <updated>2016-09-06T14:33:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是网络"><a href="#什么是网络" class="headerlink" title=" 什么是网络"></a><a name="ch1"> 什么是网络</a></h2><p>网络是将主机用网线或无线技术连接起来,使主机资源透过网络设备来传输的一种技术,其跨平台,一个标准用于不同操作系统间,这个标准为IEEE标准,其分为硬件标准(以太网络设备)与通信协议(TCP/IP)</p>
<h3 id="网络组成元件"><a href="#网络组成元件" class="headerlink" title=" 网络组成元件"></a><a name="ch1.1"> 网络组成元件</a></h3><p>组成网络的元件有以下:</p>
<ul>
<li>节点: 主要是具有网络地址(IP)的设备</li>
<li>服务器主机:一个提供资料的特殊节点</li>
<li>工作站/客服端:任何可在网络上输入的设备都可是工作站/客服端,比如ATM机</li>
<li>网络卡:以太网卡,内建或外插在主机上的设备,提供网络连线,一个节点至少有一个网络卡</li>
<li>网络接口:提供网络地址,一张网卡至少可以搭配一个以上的网络接口,每台主机都有一个内部网络接口,其提供127.0.0.1/8这个IP</li>
<li>路由或网关:其具有两个以上的网络接口,可连接两个以上的不同网段的设备</li>
<li>网络拓扑:各个节点在网络上的连接方式</li>
</ul>
<h3 id="网络区域范围"><a href="#网络区域范围" class="headerlink" title=" 网络区域范围"></a><a name="ch1.2"> 网络区域范围</a></h3><p>通常以距离来划分网络分为区域网络(Local Area Network,LAN)与广域网络(Wide Area Network,WAN),区域网络通过用较好的设备来连接,而广域网络则用较便宜的设备</p>
<h3 id="网络通信协议-OSI七层协议"><a href="#网络通信协议-OSI七层协议" class="headerlink" title=" 网络通信协议:OSI七层协议"></a><a name="ch1.3"> 网络通信协议:OSI七层协议</a></h3><p>因为网络通信涉及到相当多的环节,如硬件/软件封包等,故将网络通信的实现划分成多个层级,每个层级独立,只负责处理本层的任务</p>
<p>OSI七层模型如下图:
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_34_1_OSI%E6%A8%A1%E5%9E%8B.gif?raw=true" alt=""></p>
<p>七层模型中越接近硬件的层为底层,越接近应用程序的为高层,每层只认识对方同一层的数据,且每层都有自己独特的表头资料(header)</p>
<p>每层负责的任务如下表:</p>
<table style="margin: 1em auto 1em auto;">
<tr>
<th colspan="5">OSI 模型</th>
</tr>
<tr>
<th></th>
<th>数据单元</th>
<th>层</th>
<th colspan="2">功能</th>
</tr>
<tr>
<th rowspan="4">主机层</th>
<td style="background:#d8ec9c;" rowspan="3">Dat（数据）</td>
<td style="background:#d8ec9b;"> 应用层</td>
<td style="background:#d8ec9c;" colspan="2">网络进程到应用程序。提供为应用软件而设的界面，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等</td>
</tr>
<tr>
<td style="background:#d8ec9b;"> 表示层</td>
<td style="background:#d8ec9b;" colspan="2">把数据转换为能与接收者的系统格式兼容并适合传输的格式</td>
</tr>
<tr>
<td style="background:#d8ec9b;"> 会话层</td>
<td style="background:#d8ec9b;" colspan="2">负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接</td>
</tr>
<tr>
<td style="background:#e7ed9c;">Segments（数据段）</td>
<td style="background:#e7ed9c;"> 传输层</td>
<td style="background:#e7ed9c;" colspan="2">把传输表头(TH)加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议(TCP/UDP) 等</td>
</tr>
<tr>
<th rowspan="3">媒介层</th>
<td style="background:#eddc9c;">网络分组/数据报文</td>
<td style="background:#eddc9c;"> 网络层</td>
<td style="background:#eddc9c;" colspan="2">决定数据的路径选择和转寄，将网络表头(NH)加至数据包，以形成分组。网络表头包含了网络数据。例如:互联网协议(IP) 等</td>
</tr>
<tr>
<td style="background:#e9c189;">Frame（数据帧）</td>
<td style="background:#e9c189;">数据链路层</td>
<td style="background:#e9c189;" colspan="2">负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成了帧。数据链表头(DLH)是包含了物理地址和错误侦测及改错的方法。数据链表尾(DLT)是一串指示数据包末端的字符串。例如以太网、无线局域网(Wi-Fi)和通用分组无线服务(GPRS)等</td>
</tr>
<tr>
<td style="background:#e9988a;">Bit（比特）</td>
<td style="background:#e9988a;">物理层</td>
<td style="background:#e9988a;" colspan="2">在局部局域网上传送帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等</td>
</tr>
</table>

<h3 id="网络通信协议：TCP-IP"><a href="#网络通信协议：TCP-IP" class="headerlink" title=" 网络通信协议：TCP/IP"></a><a name="ch1.4"> 网络通信协议：TCP/IP</a></h3><p>由于OSI过于严谨,所以实际使用时会将其简化,那就是TCP/IP协议,其为4层。</p>
<p>TCP/IP与OSI对应关系以及使用协议如下图:
<img src="https://raw.githubusercontent.com/HiKumho/blog/9a69ddba59bac60c5344ddcd982ea6b398b96e2d/img/blog_34_2_TCP-IP%E6%A8%A1%E5%9E%8B.gif" alt=""></p>
<p>TCP/IP如何运行,我们以打开一个网址为例:<br>0. 应用程序阶段: 在浏览器输入网址,此时网址与相关资料被浏览器包装成一个资料,向下传给TCP/IP的应用层<br>1. 应用层阶段:由应用层提供的HTTP协议,将来自浏览器资料包装起来,并给予一个应用层表头,再向传输层送去<br>2. 传输层阶段:由于HTTP为可靠连接,因此该包会被装入TCP封包中,并给予TCP包的表头,向网络层送去<br>3. 网络层阶段:将TCP包装入IP封包,给予IP表头(包含来源IP:port与目的地IP:port),向链接层送去<br>4. 链接层阶段:将IP包依据CSMA/CD标准,包装成MAC帧,并给予MAC表头,最后转换成位元串,利用传输设备送到远端主机上<br>5. 服务器回应:服务器接受到此包后,会进行逆向地拆解,每个层级进行分析,最后取得想要的资料再根据上面的流程送回给客服端       </p>
<h2 id="TCP-IP协议-链接层-Network-Interface-link"><a href="#TCP-IP协议-链接层-Network-Interface-link" class="headerlink" title=" TCP/IP协议:链接层(Network Interface/link)"></a><a name="ch2"> TCP/IP协议:链接层(Network Interface/link)</a></h2><p>TCP/IP最底层的链接层主要与硬件有关,下面会说明WAN/LAN的硬件与以太网络的传输协议:CSMA/CD,以及MAC帧等概念</p>
<h3 id="WAN使用的设备"><a href="#WAN使用的设备" class="headerlink" title=" WAN使用的设备"></a><a name="ch2.1"> WAN使用的设备</a></h3><p>LAN使用的设备较为便宜,但使用的设备非常多,一般用户通常接触到的主要是ADSL或光纤等</p>
<h4 id="传统电话拨号-通过ppp协议"><a href="#传统电话拨号-通过ppp协议" class="headerlink" title="传统电话拨号:通过ppp协议"></a>传统电话拨号:通过ppp协议</h4><p>早期网络只能通过数据机加上电话线以及电脑九针端口，通过点对点协议（Point-to-Point Protocol，PPP，它通常用在两节点间创建直接的连接）,来访问网络,速度非常慢,通过打电话后就不能使用网络了</p>
<h4 id="综合业务数字网-Integrated-Services-Digital-Network，ISDN"><a href="#综合业务数字网-Integrated-Services-Digital-Network，ISDN" class="headerlink" title="综合业务数字网(Integrated Services Digital Network，ISDN)"></a>综合业务数字网(Integrated Services Digital Network，ISDN)</h4><p>利用现有的电话线路来达成网络连线的目的,只是连线两端都需要有ISDN数据机来提供连线功能,其有多种通道可以使用</p>
<h4 id="非对称数字用户线路-Asymmetric-Digital-Subscriber-Line-ADSL"><a href="#非对称数字用户线路-Asymmetric-Digital-Subscriber-Line-ADSL" class="headerlink" title="非对称数字用户线路(Asymmetric Digital Subscriber Line,ADSL)"></a>非对称数字用户线路(Asymmetric Digital Subscriber Line,ADSL)</h4><p>采用频分多路复用技术把普通的电话线分成了电话、上行和下行三个相对独立的信道，从而避免了相互之间的干扰,注意ADSL中速度单位是bits/s,比如下行速度2Mbps,实际是256KB(types)ps</p>
<h4 id="线缆调制解调器-Cable-modem"><a href="#线缆调制解调器-Cable-modem" class="headerlink" title="线缆调制解调器(Cable modem)"></a>线缆调制解调器(Cable modem)</h4><p>是利用有线电视双向同轴电缆提供互联网相关应用服务的技术</p>
<h3 id="LAN使用的设备-以太网"><a href="#LAN使用的设备-以太网" class="headerlink" title=" LAN使用的设备:以太网"></a><a name="ch2.2"> LAN使用的设备:以太网</a></h3><p>在局域网中使用的设备是以太网</p>
<h4 id="以太网速度与标准"><a href="#以太网速度与标准" class="headerlink" title="以太网速度与标准"></a>以太网速度与标准</h4><ul>
<li>10Mbps/100Mbps/1Gbps/10Gbps/100Gbps以太网</li>
<li>从10Gbps以太网标准包含7种不同类型,分别适用于局域网、城域网和广域网</li>
</ul>
<h4 id="以太网网线接口"><a href="#以太网网线接口" class="headerlink" title="以太网网线接口"></a>以太网网线接口</h4><ul>
<li>目前以太网最常见的接口是RJ-45,共有8芯。因为每条芯线的不同RJ4-5分为568A与568B接口</li>
<li>虽然RJ-45有8芯,实际使用的1,2,3,6芯</li>
<li>跳线:一边接568A,一边接568B时称为跳线,用于直接连接两部主机的网卡</li>
<li>平行线:两边同为568A或568B,用于连接主机与集线器的网卡</li>
</ul>
<h3 id="以太网的传输协议-CSMA-CD"><a href="#以太网的传输协议-CSMA-CD" class="headerlink" title=" 以太网的传输协议:CSMA/CD"></a><a name="ch2.3"> 以太网的传输协议:CSMA/CD</a></h3><p>以太网的传输主要就是网卡对网卡间的资料传递，每张网卡出厂时,都有独一无二的卡号,我们称为MAC(物理地址),其中传输遵循CSMA/CD协议</p>
<ul>
<li>CS:载波侦听<br>指任何连接到网络(LAN)上的设备在发送MAC帧前,先对网络进行监听,当通道空闲时,才发送</li>
<li>MA:多点传输<br>一个设备发送的帧会被网络上其他设备所接收,接收的设备根据帧中目的地址来判断是否要处理此帧</li>
<li>CD:碰撞检测<br>网络上帧碰撞时的一种解决方式,发送的帧具有检测功能,若网络上两帧发送碰撞损坏后,其发送端会随机等待一个时间再发送</li>
</ul>
<h3 id="链接层传输单位-帧及其最大传输量-MTU"><a href="#链接层传输单位-帧及其最大传输量-MTU" class="headerlink" title=" 链接层传输单位:帧及其最大传输量:MTU"></a><a name="ch2.4"> 链接层传输单位:帧及其最大传输量:MTU</a></h3><h4 id="链接层传输单位-帧"><a href="#链接层传输单位-帧" class="headerlink" title="链接层传输单位:帧"></a>链接层传输单位:帧</h4><p>CSMA/CD传输的单位就是帧(整个网络硬件上面传输资料的最小单位),一条网路一次只能通过一个帧,其内容如下
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_34_3_%E5%B8%A7.png?raw=true" alt=""></p>
<p>其中目的地址与来源地址就是MAC(物理地址),其范围是<code>00:00:00:00:00:00</code>到<code>FF:FF:FF:FF:FF:FF</code>（6bytes,前3bytes是厂商编号,后3bytes是厂商定义编号） <code>ifconfig</code>可以查到MAC</p>
<p>帧实际数据大小范围:46bytes-MTU(1500bytes)</p>
<h4 id="最大传输量-MTU"><a href="#最大传输量-MTU" class="headerlink" title="最大传输量:MTU"></a>最大传输量:MTU</h4><p>以太网标准能传输的实际数据最大量称为MTU,通常是1500bytes,当IP包过大时,就会将IP包拆包装进帧中.</p>
<p>虽然MTU可以扩大,其需要硬件支持,不仅是自身的设备,还要求接收端的设备支持,所有通常不扩张</p>
<h3 id="集线器与交换机"><a href="#集线器与交换机" class="headerlink" title=" 集线器与交换机"></a><a name="ch2.5"> 集线器与交换机</a></h3><p>集线器与交换机都是以太网常用的设备</p>
<p>集线器：接收到帧,并向所有端口广播出去
交换机: 交换机内部的CPU会在每个端口成功连接时,通过将其MAC地址和端口对应,形成一张MAC表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。</p>
<h2 id="TCP-IP协议-网络层"><a href="#TCP-IP协议-网络层" class="headerlink" title=" TCP/IP协议:网络层"></a><a name="ch3"> TCP/IP协议:网络层</a></h2><p>网络层提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。TCP/IP协议体系中的网络层功能由IP协议规定和实现，故又称IP层</p>
<h3 id="IP数据包"><a href="#IP数据包" class="headerlink" title=" IP数据包"></a><a name="ch3.1"> IP数据包</a></h3><p>前面谈到链接层传输的数据单位是帧,而网络层传输的是IP包,由于IP有不同版本,目前广泛使用的是IPv4,其使用32位表示IP地址(IPv6用128位表示IP地址)</p>
<p>以下是一个IPv4的数据包
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_34_4_IP%E5%8C%85.png?raw=true" alt=""></p>
<ul>
<li><code>Version</code>  IP包的版本,IPv4或IPv6</li>
<li><code>IHL(Internet Header Length)</code>  IP表头长度</li>
<li><code>Type of Service</code>  IP包的服务类型,如高传输T,高可靠R</li>
<li><code>Total Length</code> IP包总大小=表头+实际数据,最大达65535bytes</li>
<li><code>Identification</code> 识别码,用于表示IP包被拆包,分段后,这些小包是否属于同一个IP包</li>
<li><code>Flags</code> 特殊标志,D为0表可分段,1表不可分段等</li>
<li><code>Fragment Offset</code> IP分段在原始IP包中的偏移量</li>
<li><code>Time To Live(TTL)</code> IP包存活时间,取值范围为0-255,通过网络上一个路由器就减1,当TTL为0时,此包会被丢弃</li>
<li><code>Protocol Number</code> 协议代码 记录此包在传输层及网络层使用的协议是什么,如TCP=6，UDP=17等</li>
<li><code>Header Checksum</code> IP表头检查码,用于检查IP包表头的错误</li>
<li><code>Source Address</code> 来源IP地址</li>
<li><code>Destination Address</code> 目的IP地址</li>
<li><code>Options</code> 其他额外功能,如安全处理，路由记录</li>
<li><code>Padding</code> 由于IP每条资料必须是32bit,由于Options没有固定位数,所有Padding用于补齐</li>
</ul>
<h3 id="IP地址的组成与分级"><a href="#IP地址的组成与分级" class="headerlink" title=" IP地址的组成与分级"></a><a name="ch3.2"> IP地址的组成与分级</a></h3><p>如上面提到,IPv4由32位组成,其中我们又将这32位IP划分出Net_ID(用于标识网段)和Host_ID(用于标识同网段下的主机),为了方便记录,我们通常将这32位IP以每8位写成十进制来表示.如<code>11111111 11111111 11111111  @11111111</code>通常写成<code>255.255.255.255</code></p>
<p>我们将Host_ID全为0的IP用来标识某网段地址(Network IP),用Host_ID全为1来标识此网段的广播地址(Broadcast IP)</p>
<h4 id="IP与网段"><a href="#IP与网段" class="headerlink" title="IP与网段"></a>IP与网段</h4><p>前面我们提到Net_ID用于标识网段,首先我们需要明白,网段是在同一个物理网段上划分出来的,不是说你们两IP的Net_ID一样(前提是同一个物理网段)就可以广播通信</p>
<p>当我们确定在同一个网段时,可以通过CSMA/CD直接在此网段上广播自己的数据包出去</p>
<p>当我们确定在同一个物理网,不同的子网段上时,可以路由或者网关,将我们传送的包转交至其他网段上,然后在其他网段上广播到目的主机</p>
<h4 id="IP与门牌"><a href="#IP与门牌" class="headerlink" title="IP与门牌"></a>IP与门牌</h4><p>IP地址中的Net_ID就像我们的街道,Host_ID就像我们的门牌.而Host_ID全为0标识街道的地址,当我们要找街道上某户人时,我们可以在街道的广播设备(Host_ID全为1)上呼叫,目标听到后回应,而当我们写信给不同地方的朋友时,那只能通过邮局了(route),通过这个街道上的邮局都是用Host_ID全为1再减1后的IP来标识</p>
<h4 id="IP分级"><a href="#IP分级" class="headerlink" title="IP分级"></a>IP分级</h4><p>为了规范Net_ID的位数,于是我们将IP进行分级,其中A类IP为<code>0.0.0.0/8-127.255.255.255/8</code> B类IP为<code>128.0.0.0/16-191.255.0.0/16</code> C类IP为<code>192.0.0.0/24-223.255.255.255/24</code>,其中<code>IP/Num</code>的Num是Net_ID的位数</p>
<h3 id="IP的类别与取得方式"><a href="#IP的类别与取得方式" class="headerlink" title=" IP的类别与取得方式"></a><a name="ch3.3"> IP的类别与取得方式</a></h3><h4 id="IP类别"><a href="#IP类别" class="headerlink" title="IP类别"></a>IP类别</h4><p>上面是对IP进行分级,下面我们对IP进行分类,其可以分成公有IP和私有IP,而我们要连上Internet须使用公有IP,私有IP用来构建局域网来划分主机，如果要将私有IP送上Internet,需要架设防火墙与NAT服务</p>
<p>IPv4规划好的私有IP:
A类私有IP : <code>10.0.0.0 - 10.255.255.255</code>
B类私有IP : <code>172.16.0.0 - 172.31.255.255</code>
C类私有IP : <code>192.168.0.0 - 192.168.255.255</code></p>
<p>此外还有一个特殊的IP网段(loopback),用于本地测试使用,就是<code>127.0.0.0/8</code>,本地服务都是在此网段的主机上启动,如<code>127.0.0.1</code>这个IP</p>
<h4 id="IP取得方式"><a href="#IP取得方式" class="headerlink" title="IP取得方式"></a>IP取得方式</h4><ul>
<li>直接手动设置:向网关询问IP相关参数</li>
<li>通过拨号取得</li>
<li>自动取得网络参数(DHCP):在局域网内架设一部主机负责管理所有主机的网络参数</li>
</ul>
<h3 id="子网掩码-Netmask-与无类别域间路由-CIDR"><a href="#子网掩码-Netmask-与无类别域间路由-CIDR" class="headerlink" title=" 子网掩码(Netmask)与无类别域间路由(CIDR)"></a><a name="ch3.4"> 子网掩码(Netmask)与无类别域间路由(CIDR)</a></h3><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>由于我们默认使用的IP地址,可能Host_ID过多,实际使用时,我们并没有这么多主机(如一个A类IP可使用2^24-2个主机),假设我们有这么多主机,如果我们同时向这些主机广播一个数据包,也是很痛苦的一件事</p>
<p>所以我们将我们获取的IP地址再进一步划分出不同的子网段,来管理网络(其实就是从Host_ID中分出子网的ID位)</p>
<p>Netmask就是用32位IP地址中Net_ID全为1,Host_ID全为0来表示</p>
<p>假设我要对<code>192.168.0.0/24</code>这个IP地址划分出2个子网
可以这么做<code>Net_ID+1=24+1=25</code>,由于划分出两个网段,原本<code>192.168.0.0/24</code>有256个IP,每个网段有128个IP,
那么第1个网段地址(Network IP)是<code>192.168.0.0/25</code>  而其广播地址(Broadcast IP)是<code>192.168.0.127/25</code>
第2个网段地址是<code>192.168.0.128/25</code> 而其广播地址是<code>192.168.0.255</code>
子网掩码是<code>255.255.255.128</code></p>
<h4 id="无类别域间路由-CIDR"><a href="#无类别域间路由-CIDR" class="headerlink" title="无类别域间路由(CIDR)"></a>无类别域间路由(CIDR)</h4><p>打破原本IP分级,将Net_ID位用作Host_ID位,使得多个网段写成一个网段</p>
<h3 id="路由概念与查看本机路由表"><a href="#路由概念与查看本机路由表" class="headerlink" title=" 路由概念与查看本机路由表"></a><a name="ch3.5"> 路由概念与查看本机路由表</a></h3><h4 id="路由概念"><a href="#路由概念" class="headerlink" title="路由概念"></a>路由概念</h4><p>在同一个网段内,我们可以通过IP广播来传输数据,而如上面提到的,当你要在不同网段上传输数据时,这时就只能借助邮局(路由或网关)了,路由其实就是路径选择</p>
<p>我们以下图为例
<img src="https://raw.githubusercontent.com/HiKumho/blog/e2e4d7bdce0011158e87d7b8ad5d1ba8cdfe1eb1/img/blog_34_5_route.jpg" alt=""></p>
<p><code>192.168.0.0/24</code>与<code>192.168.1.0/24</code>是不同网段,当PC01传输资料给PC11,其流程如下
1. 查询IP包的目的IP地址
当PC01要传输IP包时,查询到IP包表头的目的IP地址</p>
<p>2. 查询本机的路由
PC01查看其的路由表,发现目的IP与自己处于同网段时,就会广播数据包出去</p>
<p>3. 查询默认路由器(default gateway)
本例中由于PC01与PC11在不同网段,所以PC01会将IP包发给其设置的路由器,由路由器处理此包,本例是server A</p>
<p>4. 路由器转交IP包到目的网段
路由器查看自己的路由信息,将PC01的IP包转交给<code>192.168.1.254</code>,并将IP包在此网段广播出去,给目的IP</p>
<p>由上我们可以知道,每台主机都存在一个路由表,而且会设置其默认的网关/路由器地址,用于不同网段间的通信</p>
<h4 id="查看本机路由表-route"><a href="#查看本机路由表-route" class="headerlink" title="查看本机路由表:route"></a>查看本机路由表:route</h4><p>我们可以使用route来查看本机的路由表,其中第1列是网段地址,而<code>default</code>来表示缺省的网段</p>
<h3 id="IP与MAC-ARP与RARP协议"><a href="#IP与MAC-ARP与RARP协议" class="headerlink" title=" IP与MAC:ARP与RARP协议"></a><a name="ch3.6"> IP与MAC:ARP与RARP协议</a></h3><p>我们知道,网络实际上是利用MAC来传输帧,并不是我们指定的IP,所以我们需要通过IP地址来获取MAC地址,则就是ARP协议</p>
<p>ARP协议:通过广播包含目标IP地址的ARP包出去,目标接收到此包后会返回其MAC地址,发送端接收到目标MAC地址后记录进ARP table中,并开始通信</p>
<p>RARP协议是MAC地址来获取IP地址</p>
<p>查看本机的MAC地址:<code>ifconfig</code></p>
<p>查看本机的ARP table: <code>arp</code></p>
<h3 id="反馈信息-ICMP协议"><a href="#反馈信息-ICMP协议" class="headerlink" title=" 反馈信息:ICMP协议"></a><a name="ch3.7"> 反馈信息:ICMP协议</a></h3><p>网络控制消息协定（Internet Control Message Protocol，ICMP）,通常用于返回的错误信息或是分析路由。ICMP错误消息总是包括了源数据并返回给发送者。 ICMP错误消息的例子之一是TTL值过期。每个路由器在转发数据报的时候都会把IP包头中的TTL值减一。如果TTL值为0，“TTL在传输中过期”的消息将会回报给源地址。 每个ICMP消息都是直接封装在一个IP数据包中的，因此，和UDP一样，ICMP是不可靠的。</p>
<h2 id="TCP-IP协议-传输层"><a href="#TCP-IP协议-传输层" class="headerlink" title=" TCP/IP协议:传输层"></a><a name="ch4"> TCP/IP协议:传输层</a></h2><p>网络层的IP只是负责将数据送到正确的目标上,而数据没有被接收,那是传输层的任务之一,传输层的封包分为连接导向的TCP封包,与非连接导向的UDP封包</p>
<h3 id="可靠连接的TCP协议"><a href="#可靠连接的TCP协议" class="headerlink" title=" 可靠连接的TCP协议"></a><a name="ch4.1"> 可靠连接的TCP协议</a></h3><p>通常传输层会将数据打包成TCP包,然后将其传入网络层,装入IP包中,TCP包/IP包/帧的关系如下图
<img src="https://raw.githubusercontent.com/HiKumho/blog/e15407def84c9f9ee3530a5eb70f26b0c7b1355c/img/blog_35_6_tcp_ip_mac%E5%8C%85.png" alt=""></p>
<p>TCP数据包如下
<img src="https://raw.githubusercontent.com/HiKumho/blog/a02208423e1bd1ce08e8ccf8d1d829795a4c0964/img/blog_35_7_tcp%E5%8C%85.png" alt=""></p>
<ul>
<li><code>source port &amp; destination port</code> ： 来源IP中的端口与目标IP中的服务端口,传输数据时,两个端口需要连接,其中一个IP与一个端口组成socket pair</li>
<li><code>sequence number</code>: TCP包比IP包大时,TCP包进行分段,sequence number就是每个分段的序号</li>
<li><code>acknoledge number</code>:回应代码</li>
<li><code>Data offset</code> 对<code>Options</code>的补齐,保证TCP包的大小</li>
<li><code>Reserved</code> 保留</li>
<li><code>Code</code> 控制码,好让接收端明白这个封包的动作<ul>
<li><code>ACK</code> 回应</li>
<li><code>SYN</code> 表示发送端希望与接收端建立同步连接</li>
<li><code>FIN</code> 表示传输结束</li>
<li><code>URG</code> 表示紧急包,接收端应紧急处理</li>
<li><code>PSH</code> 要求接收端立即传输缓存区的对应的包</li>
<li><code>RST</code> 强制结束连线</li>
</ul>
</li>
<li><code>Window</code> 主要用于控制包的流量</li>
<li><code>Checksum</code> 发送端发送资料前,进行检验动作,检验码写到此项中</li>
<li><code>Urgent pointer</code> 紧急资料，与<code>URG</code>对应,告知紧急资料所在位置</li>
<li><code>Options</code> 表示接收端可以接收的最大数据容量</li>
<li><code>Padding</code> 补齐包的大小</li>
</ul>
<h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title=" TCP的三次握手"></a><a name="ch4.2"> TCP的三次握手</a></h3><p>TCP被称为可靠的连线传输,是因为客服端与接收端建立在同步连接的基础上的,而同步连接是通过三次握手来实现,如下图
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_34_8_TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png?raw=true" alt=""></p>
<p>通过客服端发起SYN连线请求,服务端发起ACK/SYN请求,最后客服端回应ACK建立连接</p>
<h3 id="非连接导向的UDP协议"><a href="#非连接导向的UDP协议" class="headerlink" title=" 非连接导向的UDP协议"></a><a name="ch4.3"> 非连接导向的UDP协议</a></h3><p>在UDP传输过程中,不会建立连线,接收端在接收到包后不会回应(ACK)发送端,直接发送数据给与客服端,不管客服端是否正确接收到数据,UDP较为快速</p>
<p>UDP数据包如下
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_34_9_udp%E5%8C%85.png?raw=true" alt=""></p>
<h3 id="网络防火墙与OSI七层协议"><a href="#网络防火墙与OSI七层协议" class="headerlink" title=" 网络防火墙与OSI七层协议"></a><a name="ch4.4"> 网络防火墙与OSI七层协议</a></h3><p>防火墙针对OSI七层协议来说,每层可以抵挡的方面有:</p>
<ul>
<li>第二层: 可以针对来源与目标的MAC进行抵挡</li>
<li>第三层: 可以针对来源与目标的IP,以及ICMP的类别进行抵挡</li>
<li>第四层: 可以针对TCP/UDP的端口进行抵挡,也可以针对TCP的状态来处理</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是网络&quot;&gt;&lt;a href=&quot;#什么是网络&quot; class=&quot;headerlink&quot; title=&quot; 什么是网络&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt; 什么是网络&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;网络是将主机用网线或无线技术连接起来,使主机资源透过网络设备来传输的一种技术
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核编译</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"/>
    <id>http://yoursite.com/2016/09/06/Linux-内核编译/</id>
    <published>2016-09-06T13:44:20.000Z</published>
    <updated>2016-09-06T14:00:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内核编译过程"><a href="#内核编译过程" class="headerlink" title=" 内核编译过程"></a><a name="ch1"> 内核编译过程</a></h2><h3 id="获取内核源文件"><a href="#获取内核源文件" class="headerlink" title=" 获取内核源文件"></a><a name="ch1.1"> 获取内核源文件</a></h3><p>通过Linux内核官网获取内核源文件: <a href="https://www.kernel.org/" target="_blank" rel="external">https://www.kernel.org/</a> 
(这里我下载到的是linux-4.8.0-rc3)</p>
<p>鸟哥说可以通过获取发行版本的内核源文件,由于自己没有找到,所以不能测试</p>
<h3 id="解压内核源文件"><a href="#解压内核源文件" class="headerlink" title=" 解压内核源文件"></a><a name="ch1.2"> 解压内核源文件</a></h3><p>因为内核文件是用tar的xz工具打包压缩的,xz压缩比比bz2还好,tar中使用-J来标识,解压内核文件到/usr/src中，操作如下
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -Jxv <span class="_">-f</span> linux-4.8.0-rc3 -C /usr/src/</div></pre></td></tr></table></figure> </p>
<h3 id="内核源文件目录"><a href="#内核源文件目录" class="headerlink" title=" 内核源文件目录"></a><a name="ch1.3"> 内核源文件目录</a></h3><p>解压下来的内核源文件,含有的目录说明</p>
<table>
<thead>
<tr>
<th style="text-align:center">目录</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">arch</td>
<td style="text-align:center">与硬件平台有关,大部分指CPU类型,例如x86，x86_64等,编译出的内核文件会在这里</td>
</tr>
<tr>
<td style="text-align:center">block</td>
<td style="text-align:center">与块设备有关的设置数据</td>
</tr>
<tr>
<td style="text-align:center">crypto</td>
<td style="text-align:center">内核所支持的加密技术,例如md5或des等</td>
</tr>
<tr>
<td style="text-align:center">Documentation</td>
<td style="text-align:center">与内核有关的帮助文档,对了解内核相对有用</td>
</tr>
<tr>
<td style="text-align:center">drivers</td>
<td style="text-align:center">一些硬件的驱动程序,如显卡,网卡等PCI相关硬件</td>
</tr>
<tr>
<td style="text-align:center">firmware</td>
<td style="text-align:center">一些旧式硬件的微指令数据</td>
</tr>
<tr>
<td style="text-align:center">fs</td>
<td style="text-align:center">内核所支持的文件系统</td>
</tr>
<tr>
<td style="text-align:center">include</td>
<td style="text-align:center">一些可让其他过程调用的头文件(定义数据)</td>
</tr>
<tr>
<td style="text-align:center">init</td>
<td style="text-align:center">一些内核初始化的定义功能,包括挂载与init程序的调用等</td>
</tr>
<tr>
<td style="text-align:center">ipc</td>
<td style="text-align:center">定义Linux操作系统内各程序的通信</td>
</tr>
<tr>
<td style="text-align:center">kernel</td>
<td style="text-align:center">定义内核程序/内核状态/进程信号量/程序调度等</td>
</tr>
<tr>
<td style="text-align:center">lib</td>
<td style="text-align:center">一些函数库</td>
</tr>
<tr>
<td style="text-align:center">mm</td>
<td style="text-align:center">与内存单元的有关数据包括swap与虚拟内存等</td>
</tr>
<tr>
<td style="text-align:center">net</td>
<td style="text-align:center">与网络有关的各项协议数据,还有防火墙模块(net/ipv4/netfilter)等</td>
</tr>
<tr>
<td style="text-align:center">security</td>
<td style="text-align:center">包括selinux等在内的安全性设置</td>
</tr>
<tr>
<td style="text-align:center">sound</td>
<td style="text-align:center">与音效有关的各项模块</td>
</tr>
<tr>
<td style="text-align:center">virt</td>
<td style="text-align:center">与虚拟化机器有关的信息,如KVM(Kernel-based Virtual Machine)</td>
</tr>
</tbody>
</table>
<h3 id="清理原编译文件和配置文件"><a href="#清理原编译文件和配置文件" class="headerlink" title=" 清理原编译文件和配置文件"></a><a name="ch1.4"> 清理原编译文件和配置文件</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make mrproper #清除.config</div><div class="line">make clean  # 清除目标文件</div></pre></td></tr></table></figure>
<p>make 会参考内核文件目录下的Makefile文件 执行相应的操作</p>
<h3 id="挑选内核功能"><a href="#挑选内核功能" class="headerlink" title=" 挑选内核功能"></a><a name="ch1.5"> 挑选内核功能</a></h3><p>执行<code>make menuconfig</code>会在终端显示一个菜单,帮助我们挑选需要的内核功能。
<code>make menuconfig</code>执行时如果报出如下的错误
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HOSTCC  scripts/kconfig/mconf.o</div><div class="line">In file included from scripts/kconfig/mconf.c:23:0:</div><div class="line">scripts/kconfig/lxdialog/dialog.h:38:20: fatal error: curses.h: 没有那个文件或目录</div></pre></td></tr></table></figure>
需要安装ncurses库,需先安装,操作如下
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</div></pre></td></tr></table></figure></p>
<p>关于内核功能的挑选,不明白时在相应的条目下按<code>h</code>有说明,其中<code>[*]</code>表示此条目功能会编译进内核,<code>[M]</code>表示此条目功能会编译成内核模块</p>
<p>挑选完内核功能后，<code>save</code>保存为配置文件<code>.config</code>,为后面编译准备</p>
<h3 id="编译内核与内核模块"><a href="#编译内核与内核模块" class="headerlink" title=" 编译内核与内核模块"></a><a name="ch1.6"> 编译内核与内核模块</a></h3><p>执行<code>make bzImage</code>编译压缩后的内核文件,其文件会输出为<code>arch/x86/boot/bzImage</code></p>
<p>如果在编译过程中出现<code>如arm-linux-gcc没有找到的相关错误</code>,需先安装ARM-Linux-GCC，执行操作<code>apt-get install gcc-arm-linux-gnueabi</code> 详细说明请看<a href="http://www.cnblogs.com/muyun/p/3370996.html" target="_blank" rel="external">Ubuntu安装ARM架构GCC工具链（ubuntu install ARM toolchain）最简单办法</a></p>
<p>执行<code>make modules</code>编译内核模块</p>
<h3 id="安装内核模块"><a href="#安装内核模块" class="headerlink" title=" 安装内核模块"></a><a name="ch1.7"> 安装内核模块</a></h3><p>执行<code>make modules_install</code>将前面编译号的内核模块安装至<code>/lib/modules</code>下的相应目录</p>
<h2 id="启动内核"><a href="#启动内核" class="headerlink" title=" 启动内核"></a><a name="ch2"> 启动内核</a></h2><p>以下要进行的操作是设置一个启动菜单项,引导新的内核启动。</p>
<p>由于我安装系统时/boot独立分区,而且容量不够大,所以下面的操作我会新建一个分区来安装grub引导程序及相应配置文件,由其启动新的内核</p>
<h3 id="新建分区-安装grub"><a href="#新建分区-安装grub" class="headerlink" title=" 新建分区,安装grub"></a><a name="ch2.1"> 新建分区,安装grub</a></h3><p>使用fdisk工具新建一个分区,并成功挂载至<code>/mnt/boot</code>目录下</p>
<p>使用grub-install安装grub,操作如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">grub-install --root-directory=/mnt/boot /dev/sda10 # 新建的分区是/dev/sda10</div></pre></td></tr></table></figure>
查看/mnt/boot目录会发现grub程序及配置文件成功安装，</p>
<p><b>其实可以不安装grub,不影响,但是仍需要挂载分区</b></p>
<p>由于MBR执行grub的主程序后,会调入其配置文件,所以需要将此分区在开机时挂载起来,修改<code>/etc/fstab</code>文件</p>
<h3 id="将内核文件移到新分区"><a href="#将内核文件移到新分区" class="headerlink" title=" 将内核文件移到新分区"></a><a name="ch2.2"> 将内核文件移到新分区</a></h3><p>记得我们编译好的内核文件是<code>/usr/src/linux-4.8.0-rc3/arch/x86/boot/bzImage</code>,将其移动至新分区,并改名为<code>vmlinuz-4.8.0-rc3</code>(查看我们/boot目录下的内核文件其命名方式也是vmlinuz-版本号)</p>
<h3 id="制作虚拟文件系统Initrd"><a href="#制作虚拟文件系统Initrd" class="headerlink" title=" 制作虚拟文件系统Initrd"></a><a name="ch2.3"> 制作虚拟文件系统Initrd</a></h3><p>我们需要先将<code>/usr/src/linux-4.8.0-rc3/.config</code>移动到/boot目录下,因为使用<code>mkinitramfs</code>工具会参考/boot目录的相应配置文件,注意需要将<code>.config</code>改名为<code>config-版本号</code>(版本号最好与/lib/modules下相应内核模块目录同样)</p>
<p>之后执行<code>mkinitramfs -o /mnt/boot/initrd-版本号 版本号</code></p>
<p>最后将<code>./config</code>移回/mnt/boot下(这个关系不大)</p>
<p>查看我的<code>/mnt/boot</code>目录有以下文件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">config-4.8.0-rc3-kumho-generic  </div><div class="line">vmlinuz-4.8.0-rc3-kumho-generic </div><div class="line">initrd-4.8.0-rc3-kumho-generic</div><div class="line">boot/</div></pre></td></tr></table></figure></p>
<h3 id="编辑grub菜单"><a href="#编辑grub菜单" class="headerlink" title=" 编辑grub菜单"></a><a name="ch2.4"> 编辑grub菜单</a></h3><p>grub2菜单项的标识是<code>menuentry</code>,由于我们只是加载新内核来启动系统,并没有需要改变根目录分区,所有可以直接打开<code>/boot/grub/grub.cfg</code>将第一个<code>menuentry</code>项复制到<code>/etc/grub.d/40_custom</code>文件里</p>
<p>修改其菜单名menuetry的属性值
修改其root属性值为新建分区(这里我修改为 <code>set root=&#39;hd0,msdos10&#39;</code>)
修改其linux属性值为<code>/vmlinuz-4.8.0-rc3-kumho-generic</code>,后接的启动参数可以不修改
修改其initrd属性值为<code>/initrd-4.8.0-rc3-kumho-generic</code></p>
<p>最后使用<code>grub-mkconfig -o /boot/grub/grub.cfg</code>输出新的grub.cfg</p>
<p>重新开机选择新菜单启动后执行<code>uname -r</code>查看当前内核</p>
<p>关于grub2.0配置文件详细说明请看<a href="http://linux.vbird.org/linux_basic/0510osloader.php#grub" target="_blank" rel="external">鸟哥私房菜–grub2.0配置文件</a></p>
<h3 id="启动内核时遇到的问题"><a href="#启动内核时遇到的问题" class="headerlink" title=" 启动内核时遇到的问题"></a><a name="ch2.5"> 启动内核时遇到的问题</a></h3><h4 id="request-module-runaway-loop-modprobe-binfmt-464c"><a href="#request-module-runaway-loop-modprobe-binfmt-464c" class="headerlink" title="request_module: runaway loop modprobe binfmt-464c"></a>request_module: runaway loop modprobe binfmt-464c</h4><p>这是我编译64位内核,启动内核后遇到的问题</p>
<p>网上找到相关资料
<a href="http://blog.sina.com.cn/s/blog_740ccd0401011ivx.html" target="_blank" rel="external">linux启动时出现request_module: runaway loop modprobe binfmt-464c</a></p>
<p>再按上面的步骤(在挑选内核功能时,cross compile prefix中写入arm-linux-)重新编译内核后,出现编译失败,缺少<code>arm-linux-gcc</code>库的原因,重新安装后(安装方法本文前面提到),解决问题</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内核编译过程&quot;&gt;&lt;a href=&quot;#内核编译过程&quot; class=&quot;headerlink&quot; title=&quot; 内核编译过程&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt; 内核编译过程&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;获取内核源文件&quot;&gt;&lt;a href=&quot;#获取内核源文件&quot; c
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 软件安装:软件管理(RPM/yum与DKPG/apt)</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86-RPM-yum%E4%B8%8EDKPG-apt/"/>
    <id>http://yoursite.com/2016/09/06/Linux-软件安装-软件管理-RPM-yum与DKPG-apt/</id>
    <published>2016-09-06T13:40:55.000Z</published>
    <updated>2016-09-06T13:42:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于软件管理可以参考<a href="http://blog.csdn.net/on_1y/article/details/8598385" target="_blank" rel="external">Linux 软件管理(RPM,Dpkg,APT)</a></p>
<p>这里对上文的SRPM进行补充
SRPM(Source RPM)，文件以SRPM打包会软件的源码以及相关配置文件，文件以“.src.rpm”为扩展名</p>
<p>当我们需要安装一个SRPM时，如果是按默认值来安装，可以直接使用
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpmbuild --rebuild *.src.rpm  #编译打包成RPM包</div></pre></td></tr></table></figure>
或
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpmbuild --recompile *.src.rpm  #在--rebuild基础上，安装RPM</div></pre></td></tr></table></figure></p>
<p>如果我们需要修改SRPM的设置文件，需要重新编译，执行以下步骤
1. 解包： rmp -i *.src.rpm
其会将SRPM包解压到以下目录内</p>
<table>
<thead>
<tr>
<th style="text-align:center">目录名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/usr/src/redhat/SPECS</td>
<td style="text-align:center">此软件的设置文件</td>
</tr>
<tr>
<td style="text-align:center">/usr/src/redhat/SOURCES</td>
<td style="text-align:center">存放此软件的源文件与config文件</td>
</tr>
<tr>
<td style="text-align:center">/usr/src/redhat/BUILD</td>
<td style="text-align:center">编译过程中的暂存数据</td>
<td>.</td>
</tr>
<tr>
<td style="text-align:center">/usr/src/redhat/RPMS</td>
<td style="text-align:center">经编译后释出的RPM文件</td>
</tr>
<tr>
<td style="text-align:center">/usr/src/redhat/SRPMS</td>
<td style="text-align:center">经编译后释出的SRPM文件</td>
</tr>
</tbody>
</table>
<p>由于系统差异，可能/usr/src/redhat这个目录有差别</p>
<p>2. 修改SPECS目录下的<em>.spec这个设置文件
关于 </em>.spec设置文件的语法,请看以下链接</p>
<p><a href="http://linux.vbird.org/linux_basic/0520rpm_and_srpm.php#srpmmanager_config" target="_blank" rel="external">鸟哥的Linux私房菜–SRPM的spec设置</a></p>
<p>3. 再编译：rpmbuild (-ba|-bb) *.spec
根据 spec文件对整个目录内的文件进行再编译，<code>-ba</code>是释出RPM与SRPM包 而<code>-bb</code>仅释出RPM包</p>
<p>4. 之后可以通过<code>rpm -ivh</code>来安装RPM包</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于软件管理可以参考&lt;a href=&quot;http://blog.csdn.net/on_1y/article/details/8598385&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux 软件管理(RPM,Dpkg,APT)&lt;/a&gt;&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 软件安装:源码与Tarball</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-%E6%BA%90%E7%A0%81%E4%B8%8ETarball/"/>
    <id>http://yoursite.com/2016/09/06/Linux-软件安装-源码与Tarball/</id>
    <published>2016-09-06T13:34:27.000Z</published>
    <updated>2016-09-06T13:37:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开放源码的软件安装及升级"><a href="#开放源码的软件安装及升级" class="headerlink" title=" 开放源码的软件安装及升级"></a><a name="ch1"> 开放源码的软件安装及升级</a></h2><h3 id="什么是源码-编译程序-可执行文件"><a href="#什么是源码-编译程序-可执行文件" class="headerlink" title=" 什么是源码/编译程序/可执行文件"></a><a name="ch1.1"> 什么是源码/编译程序/可执行文件</a></h3><ul>
<li>源码：遵循某些编译器能识别的语法,编写的一种特殊的纯文本文件</li>
<li>编译程序：源文件到目标文件到可执行文件的过程。<ul>
<li>编译：源文件→目标文件(机器代码或接近机器代码)</li>
<li>链接：目标文件与调用函数或其他目标文件链接整合成可执行文件</li>
</ul>
</li>
<li>可执行文件：二进制程序(shell script并不是程序，其可执行,但只是调用shell的命令或外部的程序)</li>
</ul>
<h3 id="什么是函数库"><a href="#什么是函数库" class="headerlink" title=" 什么是函数库"></a><a name="ch1.2"> 什么是函数库</a></h3><p>函数库：类似子程序的角色，用来调用其某个功能，Linux中一般位于<code>/usr/include</code> <code>/lib</code> <code>/usr/lib</code>中，可以分为静态函数库与动态函数库</p>
<ul>
<li>静态函数库：<ul>
<li>扩展名为.a</li>
<li>编译过程，直接整合到执行文件中，使用静态函数库编译成的文件较大</li>
<li>静态函数库编译成的文件可独立运行</li>
<li>只有静态函数库升级了，使用静态函数库编译出的文件要升级时，只能重新编译</li>
</ul>
</li>
<li>动态函数库<ul>
<li>扩展名为.so</li>
<li>编译过程，不整合到文件中，只提供执行程序一个指向</li>
<li>动态函数编译成的程序不可独立运行，需要动态库</li>
<li>升级动态库，不影响编译出来的程序</li>
</ul>
</li>
</ul>
<p>Linux 倾向使用动态函数库，这样升级方便。</p>
<h4 id="动态函数库加载至内存"><a href="#动态函数库加载至内存" class="headerlink" title=" 动态函数库加载至内存"></a><a name="ch1.2.1"> 动态函数库加载至内存</a></h4><p>我们可以使用ldconfig将动态函数库加载至内存中，这样其他程序调用其函数时，更加有效率
首先将需要加载至内存中的动态函数库目录写到<code>/etc/ld.so.conf</code>中，再执行<code>ldconfig</code>，如果要查看当前内存加载的动态函数库可以使用<code>ldconfig -p</code></p>
<h4 id="解析程序的动态函数库：ldd"><a href="#解析程序的动态函数库：ldd" class="headerlink" title=" 解析程序的动态函数库：ldd"></a><a name="ch1.2.2"> 解析程序的动态函数库：ldd</a></h4><p>当我们想了解一个程序使用什么动态函数库时，可以调用<code>ldd 程序的绝对路径</code>
想了解一个动态函数库的详细信息（比如依赖关系，版本等），可以调用<code>ldd -v 函数库的绝对路径</code></p>
<h3 id="什么是make与configure"><a href="#什么是make与configure" class="headerlink" title=" 什么是make与configure"></a><a name="ch1.3"> 什么是make与configure</a></h3><ul>
<li>make：是编译源文件的一个工具，我们按照一定的规则编写makefile文件，make将按照makefile把程序源文件编译成可执行文件。当然其需要编译器（如gcc）的支持</li>
<li>configure：会检测操作系统环境，是否能支持此程序安装，如果支持则是写出makefile文件，供make使用。（通常开放源码的软件后，提供configure这个shell script）</li>
</ul>
<h3 id="什么是软件的tarball及其安装过程"><a href="#什么是软件的tarball及其安装过程" class="headerlink" title=" 什么是软件的tarball及其安装过程"></a><a name="ch1.4"> 什么是软件的tarball及其安装过程</a></h3><h4 id="软件的tarball"><a href="#软件的tarball" class="headerlink" title=" 软件的tarball"></a><a name="ch1.4.1"> 软件的tarball</a></h4><p>软件释出时使用tar工具进行打包压缩项目文件，形成的打包文件我们称为tarball，一般这个tarball文件会有</p>
<ul>
<li>源文件</li>
<li>检测程序文件（config或configure等）</li>
<li>本软件的简要说明（INSTALL或README）</li>
</ul>
<h4 id="软件的tarball安装过程"><a href="#软件的tarball安装过程" class="headerlink" title=" 软件的tarball安装过程"></a><a name="ch1.4.2"> 软件的tarball安装过程</a></h4><ol>
<li>从软件官网下载tarball文件</li>
<li>解压tarball文件</li>
<li>以gcc进行源码的编译（生成目标文件）</li>
<li>以gcc进行函数库，目标文件的链接，形成主要的执行程序</li>
<li>将执行程序和相关的配置文件放置合适的目录内</li>
</ol>
<p>因为我们可以使用make与configure来简化上面的第3与第4个步骤，所以安装过程变为</p>
<ol>
<li>下载tarball，并解压</li>
<li>在解压的目录里找到configure或config，并执行，通常是<code>config --prefix=安装目录</code>，生成makefile文件</li>
<li>make根据makefile文件执行相应的操作，如<code>make clean</code> <code>make main</code> <code>make install</code>等</li>
<li>安装完毕，目标执行文件已安装到第2步执行的安装目录中</li>
</ol>
<p>如下图描述通过configure与make进行安装的过程
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_31_1.gif?raw=true" alt=""></p>
<h4 id="ntp的tarball安装例子"><a href="#ntp的tarball安装例子" class="headerlink" title=" ntp的tarball安装例子"></a><a name="ch1.4.3"> ntp的tarball安装例子</a></h4><p>以ntp这个时间服务软件为例子，验算安装tarball的过程
1. 下载解压ntp的tarball文件，并查看README/INSTALL
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxv <span class="_">-f</span> ntp-4.2.8p8.tar.gz -C ./</div></pre></td></tr></table></figure></p>
<p>2. 检查configure支持的参数，并生成makefile文件
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ntp</div><div class="line">./configure --help</div><div class="line">./configure --prefix=/usr/<span class="built_in">local</span>/ntp --enable-all-clocks --enable-parse-clocks <span class="comment">#--prefix指定安装目录</span></div></pre></td></tr></table></figure></p>
<p>3. 最后编译安装
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">make clean <span class="comment">#清除之前编译的文件</span></div><div class="line">make </div><div class="line">make install <span class="comment"># 将编译好的程序移到指定目录</span></div></pre></td></tr></table></figure></p>
<p>make与makefile请看<a href="#ch2.2">2.1 make的宏编译</a></p>
<h3 id="软件的tarball的升级"><a href="#软件的tarball的升级" class="headerlink" title=" 软件的tarball的升级"></a><a name="ch1.5"> 软件的tarball的升级</a></h3><p>因为软件以tarball的形式释出，所以我们升级软件时，有很大的自由度。我们可以通过官方释出的补丁文件，再利用patch文件来升级软件</p>
<h4 id="怎么制作补丁文件"><a href="#怎么制作补丁文件" class="headerlink" title=" 怎么制作补丁文件"></a><a name="ch1.5.1"> 怎么制作补丁文件</a></h4><p>我们以hellov1.c与其v2版的hellov2.c为例，通过调用diff工具即可 <code>diff -Naur fromFile toFile</code>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">diff -Naur hellov1.c hellov2.c &gt; hellov1Tov2.patch</div></pre></td></tr></table></figure>
这样我们就成功做出hellov1升级到v2的补丁文件</p>
<h4 id="文件打补丁"><a href="#文件打补丁" class="headerlink" title=" 文件打补丁"></a><a name="ch1.5.2"> 文件打补丁</a></h4><p>我们以hellov1Tov2.patch补丁更新hellov1.c，我们先查看hellov1Tov2.patch的内容
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">--- helloV1.c 2016-08-21 21:30:19.038816459 +0800</div><div class="line">+++ helloV2.c 2016-08-21 21:31:18.262816949 +0800</div><div class="line">@@ -2,6 +2,7 @@</div><div class="line"> </div><div class="line"> int main()</div><div class="line"> &#123;</div><div class="line">+ printf(&quot;This 2nd Version\n&quot;);</div><div class="line">  printf(&quot;Hello World!\n&quot;);</div><div class="line">  return 0;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
因为我们是在helloV1.c与helloV2.c的目录下做出这个补丁文件的，所以其描述的文件都是相对路径
如果我们在使用diff时用其他路径来描述这两个文件，比如<code>diff /home/user/helloV1.c /home/usr/helloV2.c</code>,那其做出来的补丁文件应该会用绝对路径来描述文件，这里会影响patch</p>
<p>我们还是以之前的patch文件为例，我们cd到helloV1.c的目录，通过调用<code>patch -p0 &lt;hellov1Tov2.patch</code>,就将helloV1升级到V2，如果要还原，则使用<code>patch -R &lt;hellov1Tov2.patch</code></p>
<p>如果补丁文件是使用绝对路径来描述的，我们可以通过<code>patch -pNum</code>来描述这个原文件的所在，比如/home/user/helloV1.C <code>-p1</code>表示当前工作目录下<code>home/user/helloV1.C</code> <code>-p2</code>表示当前工作目录下<code>user/helloV1.C</code> <code>-pNum</code>的Num是表示去掉多少层父目录</p>
<h2 id="gcc编译器与make的宏编译"><a href="#gcc编译器与make的宏编译" class="headerlink" title=" gcc编译器与make的宏编译"></a><a name="ch2"> gcc编译器与make的宏编译</a></h2><h3 id="gcc编译器的常见命令"><a href="#gcc编译器的常见命令" class="headerlink" title=" gcc编译器的常见命令"></a><a name="ch2.1"> gcc编译器的常见命令</a></h3><p><code>gcc -c hello.c</code>  # 对hello.c进行编译，生成目标文件hello.o</p>
<p><code>gcc -O -c hello.c</code> # 在上面操作的基础上，进行优化</p>
<p><code>gcc -o hello hello.o hello2.o</code> # 对hello.o hello2.o进行链接，生成执行程序hello</p>
<p><code>gcc -o hello hello.o hello2.o -lm -L /usr/lib -I /usr/include</code> # 在上面操作的基础上，<code>-lm</code>表示添加函数库或头文件 <code>-L</code>是函数库所在的路径 <code>-I</code>是头文件所在的路径</p>
<p><code>gcc -o hello hello.c -Wall</code> # 对hello.c进行编译链接成hello，并将警告信息显示出来</p>
<h3 id="make的宏编译"><a href="#make的宏编译" class="headerlink" title=" make的宏编译"></a><a name="ch2.2"> make的宏编译</a></h3><p><code>make</code>会参考<code>makefile</code>文件来进行编译链接，make有这些特点</p>
<ul>
<li>简化编译时所需的执行命令</li>
<li>若编译完成后，修改某源文件，则make仅会针对被修改的文件进行编译，其他目标文件不会被更改</li>
<li>最后依照相关性来更新执行文件</li>
<li>而且还有使用shell的命令</li>
</ul>
<h4 id="makefile的基本语法与变量"><a href="#makefile的基本语法与变量" class="headerlink" title=" makefile的基本语法与变量"></a><a name="ch2.2.1"> makefile的基本语法与变量</a></h4><p><b>makefile的基本语法是这样的</b>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 备注</div><div class="line">target : 目标文件1 目标文件2....</div><div class="line">&lt;TAB&gt; 执行命令</div></pre></td></tr></table></figure>
target是我们make可执行的一个操作名，target为main是make的默认操作名</p>
<p>例如下面这个例子
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">main ： hello.o hellov2.o</div><div class="line">      gcc -o hello hello.o hellov2.o</div><div class="line"></div><div class="line">clean : </div><div class="line">       rm -r hello hello.o hellov2.o</div></pre></td></tr></table></figure>
我们可以通过<code>make main</code>来编译<code>hello.c</code>与<code>hellov2.c</code>，通过<code>make clean</code>来删除执行文件与目标文件</p>
<p><b>makefile的变量语法与shell类似，但有区别：</b></p>
<ul>
<li>定义变量时，变量名与内容以<code>=</code>隔开，同时两边都要有空格，而且不能有<code>：</code>，变量名左边不能有<tab></tab></li>
<li>调用变量时，以${变量名}或$(变量名)使用</li>
<li>习惯上，变量名以大写</li>
<li>特殊的变量：<ul>
<li><code>$@</code> 表示当前的target</li>
<li><code>CFLAGS</code> gcc的操作选项标识符</li>
</ul>
</li>
<li>环境变量优先度：<ul>
<li>make命令行后面接的环境变量为最优先</li>
<li>其次是makefile指定的环境变量</li>
<li>最后是shell原本具有的环境变量</li>
</ul>
</li>
</ul>
<p>将上面的makefile例子用变量重写
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LIBS = -lm</div><div class="line">OBJS = hello.o hellov2.o</div><div class="line">CFLAGS = -Wall</div><div class="line">main ： $&#123;OBJS&#125;</div><div class="line">    gcc -o hello $&#123;OBJS&#125; $&#123;LIBS&#125;</div><div class="line">clean :</div><div class="line">    rm -r hello $&#123;OBJS&#125;</div></pre></td></tr></table></figure></p>
<h2 id="检验软件或文件的正确性"><a href="#检验软件或文件的正确性" class="headerlink" title=" 检验软件或文件的正确性"></a><a name="ch3"> 检验软件或文件的正确性</a></h2><p>当我们下载一个软件时，官网若提供了MD5或SHA1的指纹编码，我们可以下载好软件，通过md5sum或sha1sum来检验这个下载完的软件的正确性，用<code>md5sum 文件名</code>或<code>sha1sum 文件名</code>，其会返回一个指纹码，然后我们把这个指纹码与官网的指纹码进行匹配，一样则下载的文件无误。</p>
<p>我们也可以用md5sum 或sha1sum来获取文件某一时刻的指纹，当文件在我们不知情时被改动，只有再此获取其指纹，与之前的指纹匹配，就可以知道其文件有误</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开放源码的软件安装及升级&quot;&gt;&lt;a href=&quot;#开放源码的软件安装及升级&quot; class=&quot;headerlink&quot; title=&quot; 开放源码的软件安装及升级&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt; 开放源码的软件安装及升级&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;什么是源码
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统启动</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2016/09/06/Linux-系统启动/</id>
    <published>2016-09-06T13:30:28.000Z</published>
    <updated>2016-09-06T13:34:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux启动流程"><a href="#Linux启动流程" class="headerlink" title=" Linux启动流程"></a><a name="ch1"> Linux启动流程</a></h2><p>Linux启动的过程如下:</p>
<ol>
<li>加载BIOS的硬件信息与进行自我测试,并依据设置取得第一个可启动的设备</li>
<li>读取并执行硬盘第一扇区中MBR的boot loader程序(即grub,spfdisk等)</li>
<li>依据boot loader的设置加载内核,内核会再次检测硬件信息与加载驱动程序</li>
<li>在硬件驱动成功后,内核会主动调用init进程,并对init初始化配置(/etc/inittab)</li>
<li>init执行/etc/rc.d/rc.sysinit文件来准备操作系统环境(如网络/时区等)</li>
<li>init执行run-level的各服务启动</li>
<li>init执行/etc/rc.d/rc.local</li>
<li>init执行终端模拟程序mingetty来启动login进程,等待用户登录</li>
</ol>
<p>详细描述:</p>
<ul>
<li>BIOS,开机自我测试与MBR<ul>
<li>系统加载BIOS,通过BIOS去加载CMOS信息,获取各项硬件的配置信息</li>
<li>BIOS检测硬件,定义出可启动的设备顺序,读取MBR中的数据(boot loader)</li>
</ul>
</li>
<li>Boot loader的功能<ul>
<li>不同操作系统的文件格式不一致,其有属于自己的boot loader</li>
<li>必须要通过其的boot loader才能加载内核,boot loader可以识别多个文件系统</li>
<li>boot loader只能安装在MBR或分区的启动扇区中</li>
<li>安装操作系统时,会将其的boot loader都写在MBR和其启动扇区中</li>
<li>boot loader提供菜单/加载内核/转交其他loader的功能</li>
</ul>
</li>
<li>加载内核,检测硬件与initrd功能<ul>
<li>boot loader读取内核后,内核开始测试与驱动设备,并重新检测硬件(内核文件放置/boot/vmlinuz)</li>
<li>内核还会动态加载独立出来的内核模块,其在/lib/modules中(/lib不能与根目录不同分区)</li>
<li>一些内核模块有USB,SATA等硬盘设备驱动等,但是我们要读取硬盘中/lib/modules,这里形成了个悖论</li>
<li>Linux使用虚拟文件系统(initrd)解决上述的问题,其在/boot/initrd中,包含有Linux启动所需的模块(如硬盘驱动),通过先启动系统,在挂载根目录,读取硬盘中模块,再加载实际系统</li>
</ul>
</li>
</ul>
<p>下图是BIOS/Boot loader/内核的启动阶段
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_30_1.jpg?raw=true" alt=""></p>
<h2 id="Boot-loader-Grub"><a href="#Boot-loader-Grub" class="headerlink" title=" Boot loader:Grub"></a><a name="ch2"> Boot loader:Grub</a></h2><h3 id="boot-loader的两个阶段"><a href="#boot-loader的两个阶段" class="headerlink" title=" boot loader的两个阶段"></a><a name="ch2.1"> boot loader的两个阶段</a></h3><p>由于MBR只有446字节,boot loader的代码与配置数据就大于446字节,所以Linux将loader的启动分为两个阶段</p>
<h4 id="执行loader的主程序"><a href="#执行loader的主程序" class="headerlink" title="执行loader的主程序"></a>执行loader的主程序</h4><p>MBR仅安装boot loader的最小主程序,并没有安装loader的相关配置文件</p>
<h4 id="主程序加载配置文件"><a href="#主程序加载配置文件" class="headerlink" title="主程序加载配置文件"></a>主程序加载配置文件</h4><p>主程序加载所有配置文件与相关环境参数(/boot/grub)中</p>
<h3 id="grub的配置文件"><a href="#grub的配置文件" class="headerlink" title=" grub的配置文件"></a><a name="ch2.2"> grub的配置文件</a></h3><p>grub可以动态查找配置,无需在修改grub配置文件后重新安装grub</p>
<p>####grub1的配置文件/boot/grub/menu.lst
grub中硬盘与分区的代号的规则</p>
<ul>
<li>硬盘代号以()括起来</li>
<li>以hd表示硬盘,后面会接一组数字</li>
<li>以“查找顺序”作为硬盘的编号,而不是依照硬盘插入的接口排序</li>
<li>第一块找到的硬盘为0,第二个为1号,以此类推</li>
<li>每个硬盘的第一个分区为0,以此类推</li>
<li>比如(hd0,0)表示查找的第一块硬盘第一分区,(hd1,1)查找到的第二块硬盘第二分区</li>
</ul>
<p>/boot/grub/menu.lst配置文件:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">default=0  #默认启动的菜单项</div><div class="line">timeout=5  #若5秒内不动键盘,则用默认菜单项启动</div><div class="line">title CentOS  # 第1个菜单项</div><div class="line">   root (hd0,0)  # /boot所在的硬盘分区</div><div class="line">   kernel /vmlinuz-2.6.18-92 root=/dev/sda2 rhgb quiet  #内核文件(相对与/boot所在) 以及 根目录所在分区 与启动参数</div><div class="line">   initrd /intrd-2.6.18-92.img  # initrd文件(相对与/boot所在)</div></pre></td></tr></table></figure></p>
<p>####grub2的配置文件/boot/grub/grub.cfg
grub2不希望用户直接修改grub.cfg文件,而是通过修改/etc/default/grub文件后,调用grub-mkconfig来影响grub.cfg</p>
<p>grub2的硬盘分区号从1开始,菜单项关键字不是title 而是menuentry</p>
<p>关于grub2详细介绍请看以下链接
<a href="http://linux.vbird.org/linux_basic/0510osloader.php#grub" target="_blank" rel="external">鸟哥的Linux私房菜-Grub2</a></p>
<h3 id="grub的安装"><a href="#grub的安装" class="headerlink" title=" grub的安装"></a><a name="ch2.3"> grub的安装</a></h3><p>如果要从其他boot loader转到grub时,需要进行以下步骤:</p>
<ol>
<li>先使用grub-install安装grub(安装第二阶段需要的配置文件)</li>
<li>编写grub的配置文件menu.lst或grub.cfg</li>
<li>通过grub shell将主程序安装到系统中,如MBR(hd0),或分区启动扇区(hd0,0)等(安装第一阶段需要的主程序),以下是执行grub 进入grub shell的命令<ul>
<li>用root (hdx,x)选择含有grub目录的分区代号</li>
<li>用 find /boot/vmlinuz 测试内核文件是否存在</li>
<li>用 setup (hdx,x) 或setup (hdx),将ggrub安装在启动扇区或者MBR中</li>
<li>quit 退出grub shell</li>
</ul>
</li>
</ol>
<h3 id="initrd文件的创建"><a href="#initrd文件的创建" class="headerlink" title=" initrd文件的创建"></a><a name="ch2.4"> initrd文件的创建</a></h3><p>initrd包含Linux系统启动必要的内核模块,当原本的initrd含有的模块不能满足我们需要时,可以通过重新创建一个含有新模块的initrd文件
<code>mkinitrd --with=模块名称 initrd文件名 内核版本</code> </p>
<h2 id="init进程"><a href="#init进程" class="headerlink" title=" init进程"></a><a name="ch3"> init进程</a></h2><p>在内核加载驱动完成后,内核会主动调用init进程(/sbin/init),来完成系统的初始化,init会参考配置文件/etc/inittab来工作,inittab可以设置Linux的运行等级(模块,run level)</p>
<h3 id="第一进程init的配置文件与run-level"><a href="#第一进程init的配置文件与run-level" class="headerlink" title=" 第一进程init的配置文件与run level"></a><a name="ch3.1"> 第一进程init的配置文件与run level</a></h3><p>####run level
run level分为7个等级,可以用runlevel显示当前的等级,与init来切换等级</p>
<ul>
<li>0 直接关机</li>
<li>1 单用用维护模式,用在系统出问题时维护</li>
<li>2 类似3level,无NFS服务</li>
<li>3 完整含有网络功能的纯文本模式</li>
<li>4 系统保留</li>
<li>5 类似3level X window</li>
<li>6 重启</li>
</ul>
<p>Ubuntu默认的[2-5]level是一样功能的</p>
<h4 id="etc-inittab配置文件"><a href="#etc-inittab配置文件" class="headerlink" title="/etc/inittab配置文件"></a>/etc/inittab配置文件</h4><p>/etc/inittab每行用：分隔字段,一共有4个字段,如下格式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[设置选项]:[run level]:[init的操作行为]:[命令选项]</div></pre></td></tr></table></figure></p>
<ul>
<li>设置选项:最多4个字符,代表init的主要工作选项,只是一个简单的代表说明</li>
<li>run level:此选项在哪个run level执行,如35就是在3/5level下执行</li>
<li>init操作行为:<ul>
<li><code>initdefault</code>：代表默认的run level设置值</li>
<li><code>sysinit</code> : 系统初始化的操作选项</li>
<li><code>ctrlaltdel</code> : 代表[ctl]+[alt]+[del]是否可以重新启动的设置</li>
<li><code>wait</code> : 代表后面接的命令须执行完才能继续做下面的选项设置</li>
<li><code>respawn</code> 代表后面接的命令可以无限重新启动</li>
</ul>
</li>
<li>命令选项 ： 即将要执行的命令</li>
</ul>
<p>一个/etc/inittab的例子
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">id：5：initdefault：     #设置默认的run level</div><div class="line"></div><div class="line">si：：syinit：/etc/rc.d/rc.sysinit   # 准备操作系统的环境</div><div class="line"></div><div class="line">10：0：wait：/etc/rc.d/rc 0   #设置run level 0 需要启动/关闭的服务文件在哪</div><div class="line">11：1：wait：/etc/rc.d/rc 1</div><div class="line"></div><div class="line">1 ： 2345 ：respawn：/sbin/mingetty tty1 #设置tty1的终端</div><div class="line">2 ： 2345 ：respawn：/sbin/mingetty tty2 #设置tty2的终端</div><div class="line"></div><div class="line">x : 5：respawn :/etc/X11/prefdm -nodaemon # 设置x window服务</div></pre></td></tr></table></figure></p>
<h3 id="init准备操作系统环境-etc-rc-d-rc-sysinit"><a href="#init准备操作系统环境-etc-rc-d-rc-sysinit" class="headerlink" title=" init准备操作系统环境:/etc/rc.d/rc.sysinit"></a><a name="ch3.2"> init准备操作系统环境:/etc/rc.d/rc.sysinit</a></h3><p>init在开始加载各项系统服务之前,得先设置好整个系统环境，主要利用/etc/rc.d/rc.sysinit这个script来设置系统环境,有以下的工作:</p>
<ul>
<li>取得网络环境与主机类型</li>
<li>测试与挂载内存设备/proc及USB设备/sys</li>
<li>决定是否启动SELinux</li>
<li>启动随机数生成器,做一些密码加密的演算</li>
<li>设置终端的字体</li>
<li>设置显示启动中的欢迎界面</li>
<li>设置系统时间与时区</li>
<li>用户自定义模块的加载</li>
<li>加载内核相关设置</li>
<li>设置主机名与初始化电源管理模块</li>
<li>初始化磁盘阵列</li>
<li>初始化LVM</li>
<li>以fsck检测磁盘文件系统</li>
<li>进行磁盘配额(quota)</li>
<li>重新以可读写模式挂载磁盘</li>
<li>清除启动过程产生的临时文件</li>
<li>将启动信息写到日志文件</li>
</ul>
<h3 id="Upstart方式的init"><a href="#Upstart方式的init" class="headerlink" title=" Upstart方式的init"></a><a name="ch3.3"> Upstart方式的init</a></h3><p>前面介绍的init是System V方式启动的,现在的init是基于Upstart方式启动,所以你在查找/etc/inittab与/etc/rc.d/rc.sysinit应该找不到,只不过你新建/etc/inittab,upstart的init会优先参考其设置</p>
<p>详细的请看以下链接
<a href="http://www.cnblogs.com/cassvin/archive/2011/12/25/ubuntu_init_analysis.html" target="_blank" rel="external">upstart的init</a></p>
<h3 id="启动系统服务-etc-rcN-d"><a href="#启动系统服务-etc-rcN-d" class="headerlink" title=" 启动系统服务(/etc/rcN.d/)"></a><a name="ch3.4"> 启动系统服务(/etc/rcN.d/)</a></h3><p>各run level的需要启动/关闭的系统服务都在各自的/etc/rcN.d/下,比如/etc/rc5.d这个目录</p>
<p>其下会含有以K或S开头的文件,其是连接文件,连接到实际的服务启动脚本文件
K或S后接的数字是其执行顺序,系统会先执行K文件，再执行S文件
实际的执行操作会以/etc/rc5.d/K<em>  stop 或/etc/rc5.d/S</em> start 进行</p>
<h3 id="定义系统开机执行命令-etc-rc-d-rc-local"><a href="#定义系统开机执行命令-etc-rc-d-rc-local" class="headerlink" title=" 定义系统开机执行命令(/etc/rc.d/rc.local)"></a><a name="ch3.5"> 定义系统开机执行命令(/etc/rc.d/rc.local)</a></h3><p>我们只需将命令或脚本文件的绝对路径写入/etc/rc.d/rc.local中,系统在完成系统服务工作后,将会执行rc.local中的命令</p>
<h2 id="内核与内核模块"><a href="#内核与内核模块" class="headerlink" title=" 内核与内核模块"></a><a name="ch4"> 内核与内核模块</a></h2><p>内核与内核模块放在哪？</p>
<ul>
<li>内核:/boot-vmlinuz</li>
<li>内核解压所需RAM Disk：/boot/initrd</li>
<li>内核模块：/lib/modules/version/kernel</li>
<li>内核源码：/usr/src/linux或/usr/src/kernels</li>
<li>内核版本 ： /proc/version</li>
<li>系统内核功能：/proc/sys/kernel</li>
</ul>
<h3 id="查看目前内核加载的模块-lsmod"><a href="#查看目前内核加载的模块-lsmod" class="headerlink" title=" 查看目前内核加载的模块:lsmod"></a><a name="ch4.1"> 查看目前内核加载的模块:lsmod</a></h3><p>lsmod会列出目前内核加载了的模块,显示的内容包括模块名称,大小以及此模块是否被其他模块使用</p>
<h3 id="内核模块的依赖性"><a href="#内核模块的依赖性" class="headerlink" title=" 内核模块的依赖性"></a><a name="ch4.2"> 内核模块的依赖性</a></h3><p>内核模块目录基本上会依照下面几个子目录来分类：</p>
<ul>
<li>arch 与硬件平台有关,如CPU等级等</li>
<li>crypto 内核所支持的加密技术,如MD5</li>
<li>drivers 一些硬件驱动程序,如显卡,网卡,PCI等</li>
<li>fs  内核所支持的文件系统</li>
<li>lib 函数库</li>
<li>net 与网络有关的各项协议数据,还有防火墙模块</li>
<li>sound 与音效有关的各项模块</li>
</ul>
<p>当我们需要添加内核模块时,将内模模块放置相应的分类目录下,在利用depmod制作一个modules.dep文件来描述内核模块的依赖性,为接下来的处理内核模块操作</p>
<h3 id="内核模块的添加删除-modprobe"><a href="#内核模块的添加删除-modprobe" class="headerlink" title=" 内核模块的添加删除:modprobe"></a><a name="ch4.3"> 内核模块的添加删除:modprobe</a></h3><p>添加内核模块：modprobe 模块名
删除内核模块 ： modprobe -r 模块名
modprobe会去参考modules.dep文件</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux启动流程&quot;&gt;&lt;a href=&quot;#Linux启动流程&quot; class=&quot;headerlink&quot; title=&quot; Linux启动流程&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt; Linux启动流程&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Linux启动的过程如下:&lt;/p&gt;
&lt;ol&gt;
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 认识与分析日志文件</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%88%86%E6%9E%90%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2016/09/06/Linux-认识与分析日志文件/</id>
    <published>2016-09-06T13:25:32.000Z</published>
    <updated>2016-09-06T13:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="  日志文件"></a><a name="ch1">  日志文件</a></h2><h3 id="Linux常见日志文件"><a href="#Linux常见日志文件" class="headerlink" title="  Linux常见日志文件"></a><a name="ch1.1">  Linux常见日志文件</a></h3><table>
<thead>
<tr>
<th style="text-align:center">日志文件</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/var/log/cron</td>
<td style="text-align:center">例行工作日志</td>
</tr>
<tr>
<td style="text-align:center">/var/log/dmesg</td>
<td style="text-align:center">内核检测过程中分析的系统硬件信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/lastlog</td>
<td style="text-align:center">记录系统上账号最近一次登录的信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/mailog或/var/log/mail/*</td>
<td style="text-align:center">记录邮件往来信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/messages</td>
<td style="text-align:center">系统发生的重要信息(比如错误信息)</td>
</tr>
<tr>
<td style="text-align:center">/var/log/secure</td>
<td style="text-align:center">记录涉及到输入用户账号密码时的信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/wtmp,/var/log/failog</td>
<td style="text-align:center">记录正确登录的用户信息,记录错误登录的用户信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/httpd/<em>,/var/log/news/</em>,/var/log/samba/*…</td>
<td style="text-align:center">个别服务制定的日志文件</td>
</tr>
</tbody>
</table>
<h3 id="日志文件管理所需服务"><a href="#日志文件管理所需服务" class="headerlink" title="  日志文件管理所需服务"></a><a name="ch1.2">  日志文件管理所需服务</a></h3><p>Linux用于管理日志文件有syslogd/rsyslog,klogd这两个服务与logrotate这个程序</p>
<ul>
<li>syslogd/rsyslog: rsyslog已经代替syslogd,其会把系统各种信息分类,放置到相应的日志文件中.</li>
<li>klogd: 记录内核产生的各项信息</li>
<li>logrotate:日志文件的轮替,由于时间久了,日志文件会越来越大,影响读取,故将旧文件替换</li>
</ul>
<h3 id="日志分析工具-logwatch"><a href="#日志分析工具-logwatch" class="headerlink" title="  日志分析工具:logwatch"></a><a name="ch1.3">  日志分析工具:logwatch</a></h3><p>我们除了可以直接去查看各日志文件信息外,也可以使用一些分析工具,比如logwatch,其会分析特定的日志信息.</p>
<h2 id="rsyslog-记录日志文件服务"><a href="#rsyslog-记录日志文件服务" class="headerlink" title="  rsyslog:记录日志文件服务"></a><a name="ch2">  rsyslog:记录日志文件服务</a></h2><p>rsyslog是常驻内存中的服务,用于记录系统各类信息,并输出到日志文件(或者设备上)</p>
<h3 id="日志文件一般格式"><a href="#日志文件一般格式" class="headerlink" title="  日志文件一般格式"></a><a name="ch2.1">  日志文件一般格式</a></h3><p>系统产生的信息经由rsyslog记录,会产生下面格式的日志信息.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Aug 17 16:36:09 kumho-Inspiron-3421 postfix/pickup[1524]: 6BCA960072: uid=1000 from=&lt;kumho@kumho-Inspiron-3421&gt;</div></pre></td></tr></table></figure>
其记录的几个重要数据,时间发生的日期与时间,发生此事件的主机名,启动此事件的服务名称或函数,该信息的实际数据内容</p>
<h3 id="rsyslog的配置文件"><a href="#rsyslog的配置文件" class="headerlink" title="  rsyslog的配置文件"></a><a name="ch2.2">  rsyslog的配置文件</a></h3><p>rsyslog的配置文件是/etc/rsyslog.conf与/etc/rsyslog.d/<em>,通常/etc/rsyslog.conf负责整体的配置信息,/etc/rsyslog.d/</em>则是负责配置输出的日志信息与日志文件的对应.比如以下是/etc/rsyslog.d/50-default.conf的内容
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">auth,authpriv.*                 /var/log/auth.log</div><div class="line">*.*;auth,authpriv.none          -/var/log/syslog</div><div class="line">cron.*                         /var/log/cron.log</div><div class="line">daemon.*                       -/var/log/daemon.log</div><div class="line">kern.*                          -/var/log/kern.log</div><div class="line">lpr.*                          -/var/log/lpr.log</div><div class="line">mail.*                          -/var/log/mail.log</div><div class="line">mail.err                        /var/log/mail.err</div></pre></td></tr></table></figure>
其分为日志信息与输出文件两部分</p>
<h4 id="日志信息分类"><a href="#日志信息分类" class="headerlink" title="日志信息分类"></a><a name="ch2.2.1">日志信息分类</a></h4><p>因为系统产生的信息各式各样,所以对这些信息进行了分类,如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型名</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">auth(authpriv)</td>
<td style="text-align:center">主要与认证有关的信息,比如login,su,ssh登录时产生的信息</td>
</tr>
<tr>
<td style="text-align:center">cron</td>
<td style="text-align:center">例行工作调度cron/at等信息</td>
</tr>
<tr>
<td style="text-align:center">daemon</td>
<td style="text-align:center">与各个daemon有关的信息</td>
</tr>
<tr>
<td style="text-align:center">kern</td>
<td style="text-align:center">内核产生的信息</td>
</tr>
<tr>
<td style="text-align:center">lpr</td>
<td style="text-align:center">打印相关的信息</td>
</tr>
<tr>
<td style="text-align:center">mail</td>
<td style="text-align:center">邮件相关的信息记录</td>
</tr>
<tr>
<td style="text-align:center">news</td>
<td style="text-align:center">新闻组信息</td>
</tr>
<tr>
<td style="text-align:center">syslog</td>
<td style="text-align:center">就是syslog/rsyslog本身产生的信息</td>
</tr>
<tr>
<td style="text-align:center">user,uucp,local0~local7</td>
<td style="text-align:center">与机器相关的一些信息</td>
</tr>
</tbody>
</table>
<h4 id="日志信息等级及连接符"><a href="#日志信息等级及连接符" class="headerlink" title=" 日志信息等级及连接符"></a><a name="ch2.2.2"> 日志信息等级及连接符</a></h4><p>日志信息等级用来描述事情的情况,如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">等级</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">none</td>
<td style="text-align:center">不输出任何信息</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">debug</td>
<td style="text-align:center">调试信息</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">info</td>
<td style="text-align:center">基本信息说明</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">notice</td>
<td style="text-align:center">注意事项说明</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">waring(warn)</td>
<td style="text-align:center">警告信息,但不影响运行</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">err(error)</td>
<td style="text-align:center">错误信息,已造成不能运行</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">crit</td>
<td style="text-align:center">比err严重,到临界点了</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">alert</td>
<td style="text-align:center">比crit还严重</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">emerg(panic)</td>
<td style="text-align:center">通常是硬件出错,内核已经无法运行的程度</td>
</tr>
</tbody>
</table>
<p>等级连接符是为了方便我们书写配置文件,产生的。有以下：</p>
<ul>
<li><code>.</code> 表示大于等于后接等级的日志信息都会记录<ul>
<li><code>.*</code> 任意等级</li>
</ul>
</li>
<li><code>.=</code> 表示只有等于后接等级的日志信息才记录</li>
<li><code>!=</code> 表示不等于后接等级的日志信息都会记录</li>
</ul>
<h4 id="输出日志文件或设备或主机"><a href="#输出日志文件或设备或主机" class="headerlink" title=" 输出日志文件或设备或主机"></a><a name="ch2.2.3"> 输出日志文件或设备或主机</a></h4><p>我们需要在配置文件中指定日志输出的地方,其可以是如下:</p>
<ul>
<li>一般文件: 以绝对路径书写</li>
<li>设备文件: 比如打印机(/dev/lp0)等</li>
<li>用户名称: 显示给用户</li>
<li>远程主机: @对方IP或@域名,需要对方也支持rsyslog服务</li>
<li><ul>
<li>: 当前系统在线的用户(相当于wall)</li>
</ul>
</li>
</ul>
<p>当输出文件前有<code>-</code>,表示日志信息先存在内存中,等数据量大才写入硬盘中.</p>
<h3 id="自定义日志文件"><a href="#自定义日志文件" class="headerlink" title="  自定义日志文件"></a><a name="ch2.3">  自定义日志文件</a></h3><p>我们只有在/etc/rsyslog.d/下新建相对的配置文件,配置文件格式如上说明,在重启rsyslog服务即可.(我在测试时,发觉输出日志文件定义在用户目录下没有输出日志信息,写在/var/log/下就有,很奇怪)</p>
<h2 id="logrotate-日志文件轮替"><a href="#logrotate-日志文件轮替" class="headerlink" title="  logrotate:日志文件轮替"></a><a name="ch3">  logrotate:日志文件轮替</a></h2><p>前面我们提到logrotate是进行日志文件轮替的一个程序,其挂在crond服务下.例行检测日志文件是否需要替换,其主要工作是新建一个新文件记录之后的日志信息,之前的日志文件改名(<em>.1/</em>.2/*.3等),当备份的日志文件一定量后,就会将最旧的文件删除</p>
<p>我们可以用<code>logrotate -vf logroate的配置文件</code>进行强制的轮替工作</p>
<h3 id="logrotate的配置文件"><a href="#logrotate的配置文件" class="headerlink" title="  logrotate的配置文件"></a><a name="ch3.1">  logrotate的配置文件</a></h3><p>logrotate针对日志文件(即前一节提到日志输出文件)进行轮替,所以其配置文件作用对象也是日志文件</p>
<p>logrotate的配置文件有/etc/logrotate.conf与/etc/logrotate.d/*
这两个文件的格式类型,如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">日志文件的绝对路径名&#123;</div><div class="line">      参数设置</div><div class="line">&#125;</div></pre></td></tr></table></figure>
相关参数说明可以<code>man logrotate.conf</code>,注意logrotate配置文件可以写入shell命令,使用特殊参数,如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sharedscripts</div><div class="line">    prerotate</div><div class="line">       /usr/bin/chattr -a /var/log/message</div><div class="line">endscript</div><div class="line"></div><div class="line">sharedscripts</div><div class="line">    postrotate</div><div class="line">       /usr/bin/chattr +a /var/log/message</div><div class="line">endscript</div></pre></td></tr></table></figure>
上面的配置文件的意思是在进行轮替工作前,将/var/log/message的a权限去掉,轮替后,再加上a权限</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;日志文件&quot;&gt;&lt;a href=&quot;#日志文件&quot; class=&quot;headerlink&quot; title=&quot;  日志文件&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt;  日志文件&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;Linux常见日志文件&quot;&gt;&lt;a href=&quot;#Linux常见日志文件&quot;
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 认识系统服务(daemon)</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E8%AE%A4%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1-daemon/"/>
    <id>http://yoursite.com/2016/09/06/Linux-认识系统服务-daemon/</id>
    <published>2016-09-06T13:19:41.000Z</published>
    <updated>2016-09-06T13:23:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是daemon"><a href="#什么是daemon" class="headerlink" title=" 什么是daemon"></a><a name="ch1"> 什么是daemon</a></h2><p>daemon是在后台运行,并提供某项服务的程序,通过以服务名+字符<code>d</code>来规定daemon的名称</p>
<h3 id="daemon的主要分类"><a href="#daemon的主要分类" class="headerlink" title=" daemon的主要分类"></a><a name="ch1.1"> daemon的主要分类</a></h3><p>daemon根据启动与管理方式,可分为独立启动的stand_alone,与通过一个super daemon来统一管理</p>
<ul>
<li>stand_alone:此类型daemon可自行独立启动<br>一直在内存中持续提供服务,对于客服端的请求,响应较快,常见的此类型daemon有提供WWW服务的daemon(httpd)与FTP服务的daemon(vsftpd)等</li>
<li>super daemon：一个stand_alone的daemon(xinetd,早期是inetd)管理<br>其内部提供多种服务,当客服端请求时,xinetd才会去唤醒相应的daemon提供服务,请求结束后,此唤醒的daemon也会关闭</li>
</ul>
<p>super daemon运行示意图如下:
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_28_1.png?raw=true" alt=""></p>
<p>daemon根据对请求的处理可分为单进程和多进程</p>
<p>daemon根据提供服务的工作状态可分为singal-control与interval-control</p>
<ul>
<li>singal-control:此类daemon通过信号管理<br>接收到客服端的请求,daemon就会去处理</li>
<li>interval-control:此类daemon每隔一段时间就主动去执行工作,我们需要在配置文件指定daemon的服务时间与工作内容,如周期例行工作调度的crond</li>
</ul>
<h3 id="服务与端口"><a href="#服务与端口" class="headerlink" title=" 服务与端口"></a><a name="ch1.2"> 服务与端口</a></h3><p>因为我们主机仅有一个IP,当要提供各种服务时,应该如何处理,我们想要的是用户可访问的是主机上的某项服务,而不是直接开放主机资源出来</p>
<p>如果我们在指定通道上提供一个服务,用户只要访问我们主机上的这个通道,就可以使用服务.那么这个通道(窗口)就是端口.</p>
<p>为了规范服务与端口的对应,所以我们有了协议,约定某服务的指定端口,我们可以查看<code>/etc/services</code>的内容,里面有各服务的协议端口信息</p>
<h3 id="daemon相关文件"><a href="#daemon相关文件" class="headerlink" title=" daemon相关文件"></a><a name="ch1.3"> daemon相关文件</a></h3><p>daemon不同与一般的进程,其启动除了需要执行文件外,还需配置文件,执行环境,运行数据存储等.
一个daemon的相关文件如下:</p>
<ul>
<li><code>/etc/init.d/*</code> : 放置stand_alone的daemon启动脚本<br>该脚本会进行环境检测,配置文件分析等工作,可以用来管理daemon的状态</li>
<li><code>/etc/sysconfig/*(RedHat) /etc/default/*(Debian)</code>:服务初始化环境配置文件
存放服务初始化的参数设置的文件,比如网络设置写在/etc/sysconfig/network中</li>
<li><code>/etc/*</code>：各服务的配置文件</li>
<li><code>/etc/xinetd.conf  /etc/xinetd.d/*</code>:super daemon及所属daemon的配置文件<br>/etc/xinted.conf是super daemon的配置文件,其是所属daemon最上级的配置文件,当所属daemon的配置文件(/etc/xinetd.d/*)中与xinetd.conf有相同项的配置,参考所属daemon</li>
<li><code>/var/lib/*</code>: 各服务产生的数据<br>一些会产生数据的服务将其数据写入/var/lib中,比如Mysql</li>
<li><code>/var/run/*</code>: 各服务的PID记录<br>为了能简单地管理各服务的进程,所以daemon会将其PID写入/var/run中</li>
</ul>
<h3 id="daemon的启动-关闭"><a href="#daemon的启动-关闭" class="headerlink" title=" daemon的启动/关闭"></a><a name="ch1.4"> daemon的启动/关闭</a></h3><h4 id="stand-alone的-etc-init-d-的启动-关闭"><a href="#stand-alone的-etc-init-d-的启动-关闭" class="headerlink" title="stand_alone的/etc/init.d/*的启动/关闭"></a>stand_alone的/etc/init.d/*的启动/关闭</h4><p>因为daemon的启动脚本帮我们完成了很多工作(检测环境,查找配置文件等),所以我们直接使用启动脚本来管理daemon
直接输入/etc/init.d/daemon名,会提示此脚本能接受的参数
比如启动/关闭syslog这个服务可以<code>/etc/init.d/syslog start</code>   <code>/etc/init.d/syslog stop</code></p>
<p>我们也可以用<code>services</code>来管理daemon,其用法如下:</p>
<ul>
<li><code>service [service name] (start|stop|restart...)</code></li>
<li><code>service --status-all</code>  //查看目前系统所有stand_alone服务状态</li>
</ul>
<h4 id="super-daemon所属daemon的启动-关闭"><a href="#super-daemon所属daemon的启动-关闭" class="headerlink" title="super daemon所属daemon的启动/关闭"></a>super daemon所属daemon的启动/关闭</h4><p>super daemon所属daemon在/etc/xinetd.d/*中有配置文件,当要启动daemon时,需要将其配置文件中的<code>disable</code>属性设置<code>no</code>,在通过/etc/init.d/xinetd重启xinetd,要关闭daemon也是这样做,将<code>disable</code>设为<code>yes</code></p>
<h2 id="super-daemon的配置"><a href="#super-daemon的配置" class="headerlink" title=" super daemon的配置"></a><a name="ch2"> super daemon的配置</a></h2><h3 id="解析super-daemon配置文件"><a href="#解析super-daemon配置文件" class="headerlink" title=" 解析super daemon配置文件"></a><a name="ch2.1"> 解析super daemon配置文件</a></h3><p>super daemon配置文件(/etc/xinetd.conf)与其属的daemon的配置文件(/etc/xinetd.d/*)格式上类似.</p>
<p>xinetd.conf的配置文件形如
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">defaults</div><div class="line">&#123;</div><div class="line">    instaces  =  50  #同一服务的最大同时连接数</div><div class="line">    per_source = 10 #同一来源的客服端最大连接数</div><div class="line">    cap  =  50 10 #同一秒内的最大连接数为50个,若超过则暂停服务10秒</div><div class="line">&#125;</div><div class="line"></div><div class="line">includedir /etc/xinetd.d   # 更多设置值在/etc/xinetd.d目录内</div></pre></td></tr></table></figure></p>
<p>而/etc/xinetd.d下的服务配置文件形如
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">service &lt;service name&gt;</div><div class="line">&#123;</div><div class="line">    属性       操作符     值</div><div class="line">&#125;</div><div class="line">其中操作符有= +=  -=</div></pre></td></tr></table></figure></p>
<p>相关的属性与值的说明可以查看 <code>man xinetd.conf</code></p>
<h3 id="etc-hosts管理"><a href="#etc-hosts管理" class="headerlink" title=" /etc/hosts管理"></a><a name="ch2.2"> /etc/hosts管理</a></h3><p>我们在xinetd配置文件中有两个值<code>only_from</code>与<code>no_access</code>其是用来限制IP访问的,<code>only_from</code>是允许访问的IP,<code>no_access</code>是限制访问的IP</p>
<p>除此之外,我们也可以通过/etc/hosts.allow与/etc/hosts.deny文件限制IP访问(hosts.allow优先与hosts.deny)
hosts.allow与hosts.deny的文件格式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;service name&gt; ： &lt;IP,domain,hostname&gt;：&lt;atcion&gt;</div></pre></td></tr></table></figure></p>
<ul>
<li><action> : 有allow/deny(允许/限制) 还有其他额外的操作(比如spawn与twist分析数据包,并加以处理)</action></li>
<li>特殊的参数(第一/二个字段):<ul>
<li>ALL : 代表全部的service或IP都接受</li>
<li>LOCAL:代表本机</li>
<li>UNKOWN:代表不可解析的IP等</li>
<li>KNOWN: 可解析的IP等</li>
</ul>
</li>
</ul>
<h2 id="系统已启动的服务与开机启动服务"><a href="#系统已启动的服务与开机启动服务" class="headerlink" title=" 系统已启动的服务与开机启动服务"></a><a name="ch3"> 系统已启动的服务与开机启动服务</a></h2><h3 id="查看系统已启动的服务"><a href="#查看系统已启动的服务" class="headerlink" title=" 查看系统已启动的服务"></a><a name="ch3.1"> 查看系统已启动的服务</a></h3><h4 id="查看目前系统正在监听的网络服务"><a href="#查看目前系统正在监听的网络服务" class="headerlink" title="查看目前系统正在监听的网络服务"></a>查看目前系统正在监听的网络服务</h4><p>netstat -lnp</p>
<h4 id="查看目前系统的服务状态"><a href="#查看目前系统的服务状态" class="headerlink" title="查看目前系统的服务状态"></a>查看目前系统的服务状态</h4><p>service –status-all</p>
<h3 id="开机启动服务"><a href="#开机启动服务" class="headerlink" title=" 开机启动服务"></a><a name="ch3.2"> 开机启动服务</a></h3><p>当我们要设置开机启动的服务时,可以通过<code>chkconfig</code>或<code>sysv-rc-conf</code></p>
<p>要了解开机的启动服务,需要知道开机的执行等级,执行等级可以理解成Linux的执行模式,共有[0-6]个等级,0为关机 3为命令模式 5为X window 6为重启</p>
<h4 id="查看系统已设置的开机启动服务"><a href="#查看系统已设置的开机启动服务" class="headerlink" title="查看系统已设置的开机启动服务"></a>查看系统已设置的开机启动服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig --list [服务名]</div></pre></td></tr></table></figure>
<p>其会列出各服务的不同等级的开启/关闭状态</p>
<h4 id="设置服务各等级的开机状态"><a href="#设置服务各等级的开机状态" class="headerlink" title="设置服务各等级的开机状态"></a>设置服务各等级的开机状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig --level [0-6] [服务名] [on|off]</div></pre></td></tr></table></figure>
<h4 id="Linux开机流程说明"><a href="#Linux开机流程说明" class="headerlink" title="Linux开机流程说明"></a>Linux开机流程说明</h4><ol>
<li>打开计算机电源,开机读取BIOS并进行主机的自我测试</li>
<li>通过BIOS取得第一个可开机设备,读取主引导分区(MBR)取得启动装载程序</li>
<li>通过启动装载程序的设置,取得内核并加载内存且检测系统硬件</li>
<li>内核主动调用init进程</li>
<li>init进程开始执行系统初始化(/etc/rc.d/rc.sysinit)</li>
<li>依据init的设置进行daemon start(/etc/rc.d/rc[0-6].d/*)</li>
<li>加载本机设置(/etc/rc.d/rc.local)</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是daemon&quot;&gt;&lt;a href=&quot;#什么是daemon&quot; class=&quot;headerlink&quot; title=&quot; 什么是daemon&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt; 什么是daemon&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;daemon是在后台运行,并提供某项服务的程
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 程序管理与SELinux</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86%E4%B8%8ESELinux/"/>
    <id>http://yoursite.com/2016/09/06/Linux-程序管理与SELinux/</id>
    <published>2016-09-06T13:13:25.000Z</published>
    <updated>2016-09-06T13:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作管理-Job-Control"><a href="#工作管理-Job-Control" class="headerlink" title=" 工作管理(Job Control)"></a><a name="ch1"> 工作管理(Job Control)</a></h2><h3 id="什么是工作管理"><a href="#什么是工作管理" class="headerlink" title=" 什么是工作管理"></a><a name="ch1.1"> 什么是工作管理</a></h3><p>工作管理是指在<b>单一终端</b>下同时进行多个工作的行为管理,不能管理其他终端上的工作,只关注自身终端</p>
<p>以下是进行工作管理时的一些限制与概念:</p>
<ul>
<li>只管理自己的bash上的工作(即bash只能管理其子进程的工作)</li>
<li>前台: 用户可以控制与执行命令的环境为前台</li>
<li>后台: 可以自行工作的环境,无法用[ctrl]+c终止工作,可用fg/bg调度工作</li>
</ul>
<h3 id="工作管理"><a href="#工作管理" class="headerlink" title=" 工作管理"></a><a name="ch1.2"> 工作管理</a></h3><h4 id="工作调入后台"><a href="#工作调入后台" class="headerlink" title="工作调入后台"></a>工作调入后台</h4><ul>
<li>将命令丢到后台运行: 命令尾+<code>&amp;</code>  如 <code>vim hello.txt &amp;</code>   </li>
<li>将运行中的工作放置后台暂停: <code>[ctrl]+z</code></li>
</ul>
<h4 id="后台工作的编号与状态"><a href="#后台工作的编号与状态" class="headerlink" title="后台工作的编号与状态"></a>后台工作的编号与状态</h4><p>工作调入后台时会返回一个工作编号(jobNum)给我们处理.
同时会标明工作调入后台后的状态. 其状态可分为<code>Done</code>,<code>Stopped</code>,<code>Killed</code>,<code>Running</code>(其中<code>Killed</code>是不正常终止)</p>
<h4 id="查看目前后台的工作-jobs"><a href="#查看目前后台的工作-jobs" class="headerlink" title="查看目前后台的工作:jobs"></a>查看目前后台的工作:<code>jobs</code></h4><p>我们可以用<code>jobs -l</code>列出当前后台中的工作,同时可以查看到它们的PID</p>
<h4 id="工作调回前台-fg"><a href="#工作调回前台-fg" class="headerlink" title="工作调回前台:fg"></a>工作调回前台:<code>fg</code></h4><p>通过<code>fg %jobNum</code>可以指定调出后台中的工作回前台运行</p>
<h4 id="后台中运行暂停的工作-bg"><a href="#后台中运行暂停的工作-bg" class="headerlink" title="后台中运行暂停的工作:bg"></a>后台中运行暂停的工作:<code>bg</code></h4><p>当我们用<code>[ctrl]+z</code>暂停工作到后台后,我们可以调用<code>bg %jobNum</code>在后台运行指定工作</p>
<h4 id="管理后台工作-kill"><a href="#管理后台工作-kill" class="headerlink" title="管理后台工作: kill"></a>管理后台工作: <code>kill</code></h4><p>通过<code>kill</code>+一个处理信号的方式来管理后台中的工作,形式如<code>kill -signal %jobNum</code>
处理信号可以用<code>kill -l</code>查阅,一些常见的信号: <code>-1 重载入 -9 强制杀死 -15 正常结束</code></p>
<h3 id="脱机工作管理"><a href="#脱机工作管理" class="headerlink" title=" 脱机工作管理"></a><a name="ch1.3"> 脱机工作管理</a></h3><p>当我们脱机或注销后,需要保持某些工作运行,好让我们下次登录时处理.该怎么做?</p>
<p>首先我们要明白<b>脱机/注销后</b>,系统分配给我们的用户进程(理解为登录后取得的终端,图形界面的是gnome-terminal)及子进程会被回收. </p>
<p>而我们需要做的是指定某进程不被系统回收,用<code>nohup</code>,在需要执行的命令前加上<code>nohup</code>即可.
此时输出信息会到<code>～/nohup.out</code>中.</p>
<h2 id="进程"><a href="#进程" class="headerlink" title=" 进程"></a><a name="ch2"> 进程</a></h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title=" 什么是进程"></a><a name="ch2.1"> 什么是进程</a></h3><p>其实我们前面提到的工作就是一个进程,其有一个程序触发,在内存中活动,以PID来标示一个内存单元(维护着程序数据以及执行者权限)</p>
<p>即 进程就是程序执行过程,执行者的权限与属性和程序代码与数据会加载至内存单元,并以PID来标示这个内存单元.</p>
<h3 id="子进程与父进程"><a href="#子进程与父进程" class="headerlink" title=" 子进程与父进程"></a><a name="ch2.2"> 子进程与父进程</a></h3><p>当我们父进程派生一个子进程后,父进程会休眠(关于进程状态,我们后面提),之后进入子进程的环境,通过PPID可以知道.</p>
<p>然后是父进程通过什么方式派生子进程?
父进程是通过<b>fork-and-exec</b>方式来派生子进程,系统先以fork复制一个与父进程相同的进程(数据相同,但PID不同,其PPID指向父进程),再以exec来加载子进程实际需要的数据.
如下图:
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_27_2.gif?raw=true" alt=""></p>
<h3 id="进程查看"><a href="#进程查看" class="headerlink" title=" 进程查看"></a><a name="ch2.3"> 进程查看</a></h3><p>查看当前系统正在运行当中的进程,可以使用ps查看静态数据,或者top动态查看进程,还能以pstree查看进程树</p>
<h4 id="查看自己bash所有进程和某进程-ps-l与ps-l-PID"><a href="#查看自己bash所有进程和某进程-ps-l与ps-l-PID" class="headerlink" title="查看自己bash所有进程和某进程:ps -l与ps -l PID"></a>查看自己bash所有进程和某进程:<code>ps -l</code>与<code>ps -l PID</code></h4><p>当我们使用<code>ps -l</code>查看自己bash,会出现如下信息
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</div><div class="line">0 S  1000  4616  2586  0  80   0 -  1786 wait   pts/13   00:00:00 bash</div><div class="line">4 R  1000  4620  4616  0  80   0 -  1605 -      pts/13   00:00:00 ps</div></pre></td></tr></table></figure>
第一行的各字段解释:</p>
<ul>
<li>F : 进程标志,说明进程权限 常见的<code>4</code>表root权限,<code>1</code>表进程只能fork不能exec,其中<code>0</code>表示没标志适用</li>
<li>S : 进程状态,<code>S</code>:Sleep,可唤醒 <code>R</code>:运行中 <code>D</code>:不可唤醒的睡眠状态 <code>T</code>:停止  <code>Z</code>:僵尸状态,进程终止却无法从内存中删除</li>
<li>UID/PID/PPID: 进程所有者/PID/父进程PID</li>
<li>C:CPU使用率</li>
<li>PRI/NI: 进程优先级,我们通过修改NI还改变PRI值,PRI决定进程优先,越小越优先</li>
<li>ADDR/SZ/WCHAN:内存相关,ADDR指示内存单元位置,SZ表示进程用掉多少内存,WCHAN表示进程是否运行中</li>
<li>TTY:指示终端机</li>
<li>CMD:触发进程的命令</li>
</ul>
<h4 id="查看系统所有进程-ps-Al或ps-aux"><a href="#查看系统所有进程-ps-Al或ps-aux" class="headerlink" title="查看系统所有进程:ps -Al或ps -aux"></a>查看系统所有进程:<code>ps -Al</code>或<code>ps -aux</code></h4><p>以下是用<code>ps -aux</code>以另一种呈现方式输出系统所有进程
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</div><div class="line">root         1  0.0  0.0   4616  3736 ?        Ss   08:08   0:01 /sbin/init</div><div class="line">root         2  0.0  0.0      0     0 ?        S    08:08   0:00 [kthreadd]</div><div class="line">root         3  0.0  0.0      0     0 ?        S    08:08   0:00 [ksoftirqd/0]</div><div class="line">root         5  0.0  0.0      0     0 ?        S&lt;   08:08   0:00 [kworker/0:0H]</div><div class="line">root         7  0.0  0.0      0     0 ?        S    08:08   0:03 [rcu_sched]</div><div class="line">root         8  0.0  0.0      0     0 ?        S    08:08   0:00 [rcu_bh]</div></pre></td></tr></table></figure>
字段的含义以之前类似,其中<code>VSZ</code>与<code>`RSS</code>分别表示进程使用的虚拟内存与固定内存量</p>
<h4 id="动态查看进程的变化-top"><a href="#动态查看进程的变化-top" class="headerlink" title="动态查看进程的变化:top"></a>动态查看进程的变化:top</h4><p>top可以持续监听进程的运行状态
其中选项<code>-d</code>:后接秒数,表示多少秒后更新状态  <code>-p</code>:接PID
在top内我们还可以通过操作来修改进程的状态,以下是一些top操作</p>
<ul>
<li><code>P</code>:以CPU使用率排序进程</li>
<li><code>M</code>:以内存使用率排序进程</li>
<li><code>N</code>:以PID排序进程</li>
<li><code>k</code>:给与某进程一个信号</li>
<li><code>r</code>:修改某进程的NI值(NICE)</li>
</ul>
<p>top的输出信息以下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">### 以下部分描述当前系统状态 load aveage:表示CPU的平均负载(1,5,15分钟)</div><div class="line">top - 10:00:41 up  1:51,  3 users,  load average: 0.37, 0.37, 0.33</div><div class="line">Tasks: 212 total,   1 running, 211 sleeping,   0 stopped,   0 zombie</div><div class="line">%Cpu(s): 14.0 us,  3.7 sy,  0.0 ni, 81.9 id,  0.5 wa,  0.0 hi,  0.0 si,  0.0 st</div><div class="line">KiB Mem:   6075096 total,  2214228 used,  3860868 free,   148028 buffers</div><div class="line">KiB Swap:  3998716 total,        0 used,  3998716 free.  1198676 cached Mem</div><div class="line"></div><div class="line">### top操作命令</div><div class="line">Send pid 4698 signal [15/sigterm] </div><div class="line"></div><div class="line">### 进程信息</div><div class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     </div><div class="line"> 4698 root      20   0       0      0      0 S   0.0  0.0   0:00.06 kworker/u4+ </div><div class="line"> 4697 kumho     20   0    6960   2796   2392 R   0.3  0.0   0:00.34 top   </div></pre></td></tr></table></figure></p>
<h4 id="进程的树结果-pstree"><a href="#进程的树结果-pstree" class="headerlink" title="进程的树结果:pstree"></a>进程的树结果:pstree</h4><p>通过<code>pstree</code>我们可以了解到进程间的相互关系,如果要同时输出PID及进程所有者,可加上<code>-up</code>选项,如果进程所有者是root,则进程树不会显示出来</p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title=" 进程管理"></a><a name="ch2.4"> 进程管理</a></h3><p>与工作管理类似,进程也是通过kill加信号量来管理的,不同的是,进程间可以彼此管理.</p>
<h4 id="需指定PID-kill"><a href="#需指定PID-kill" class="headerlink" title="需指定PID:kill"></a>需指定PID:<code>kill</code></h4><p>kill需要指定进程的PID,才能对进程进行管理,通常配合<code>ps</code>等
格式是<code>kill -signal PID</code>,signal如<code>工作管理</code>中提到,可通过<code>kill -l</code>才查看,
这里再补充下</p>
<ul>
<li><code>1</code>:重新启动</li>
<li><code>2</code>:相当与<code>[ctrl]+c</code></li>
<li><code>9</code>:强制杀死</li>
<li><code>15</code>:正常结束</li>
<li><code>17</code>:相当与<code>[ctrl]+z</code></li>
</ul>
<h4 id="管理指定命令启动的所有进程-killall"><a href="#管理指定命令启动的所有进程-killall" class="headerlink" title="管理指定命令启动的所有进程:killall"></a>管理指定命令启动的所有进程:<code>killall</code></h4><p>killall 格式是<code>killall -signal 命令</code>,其中<code>killall</code>也包含其他的选项 <code>i</code>:询问用户 <code>I</code>忽略命令大小写</p>
<h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title=" 进程优先级"></a><a name="ch2.5"> 进程优先级</a></h3><p>CPU会根据进程优先级来决定某进程的执行频率,一些冗长的进程应该较不优先
进程优先级由PRI值决定,值越低越优先,用户无法直接设置PRI值,而是通过NI值来修改PRI值.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PRI(new)=PRI(old)+Ni #这个加式,不是绝对的,PRI(new)可能会有点偏差,由系统分析后绝对</div></pre></td></tr></table></figure>
Ni值的修改有以下限制:</p>
<ul>
<li>Ni值可调整范围为-20~19</li>
<li>root可以随意调整自己或他人的进程的Ni值,范围是-20~19</li>
<li>一般用户仅可以调整自己进程的Ni值,范围是0~19,且值只能越调越大</li>
</ul>
<p>要调整Ni值有以下两种方式:</p>
<h4 id="nice-给予新执行命令一个NI值"><a href="#nice-给予新执行命令一个NI值" class="headerlink" title="nice: 给予新执行命令一个NI值"></a>nice: 给予新执行命令一个NI值</h4><p>格式<code>nice -n NI值 commad</code></p>
<h4 id="renice-修改已存在的进程的Ni值"><a href="#renice-修改已存在的进程的Ni值" class="headerlink" title="renice:修改已存在的进程的Ni值"></a>renice:修改已存在的进程的Ni值</h4><p>格式<code>renice NI值 PID</code></p>
<h3 id="进程与文件"><a href="#进程与文件" class="headerlink" title=" 进程与文件"></a><a name="ch2.6"> 进程与文件</a></h3><h4 id="查看正在使用某文件的进程-fuser"><a href="#查看正在使用某文件的进程-fuser" class="headerlink" title="查看正在使用某文件的进程:fuser"></a>查看正在使用某文件的进程:fuser</h4><p>fuser的格式: <code>fuser [-umv] [-k -signal] file/dir</code></p>
<ul>
<li><code>u</code> :显示进程执行者</li>
<li><code>m</code> :后接的文件,会上提到其所在的文件系统挂载点,等价与查看正在使用此文件系统的进程</li>
<li><code>v</code> : 显示列出文件与进程的相关数据</li>
<li><code>k</code> : 管理进程</li>
</ul>
<h4 id="列出某进程所打开的文件-lsof"><a href="#列出某进程所打开的文件-lsof" class="headerlink" title="列出某进程所打开的文件: lsof"></a>列出某进程所打开的文件: lsof</h4><p> lsof的格式: <code>lsof [-p PID] [-u username] [+d] [-a] [-U]</code></p>
<ul>
<li><code>a</code> ： 连接词，AND</li>
<li><code>u</code>  :  列出该用户相关进程所打开的文件</li>
<li><code>U</code>  : 列出系统的socket文件</li>
<li><code>+d</code> : 后接目录,列出该目录已被打开的文件</li>
</ul>
<h4 id="查看某命令所启动的进程-pidof"><a href="#查看某命令所启动的进程-pidof" class="headerlink" title="查看某命令所启动的进程: pidof"></a>查看某命令所启动的进程: pidof</h4><p>pidof格式是<code>pidof command</code></p>
<h2 id="系统资源查看"><a href="#系统资源查看" class="headerlink" title=" 系统资源查看"></a><a name="ch3"> 系统资源查看</a></h2><h3 id="free-查看内存使用情况"><a href="#free-查看内存使用情况" class="headerlink" title=" free:查看内存使用情况"></a><a name="ch3.1"> free:查看内存使用情况</a></h3><p>free输出的信息默认以KB为单位,如果我需要其他单位显示容量,可以使用<code>-b|-k|-m|-g</code></p>
<h3 id="uname-查看系统与内核相关信息"><a href="#uname-查看系统与内核相关信息" class="headerlink" title=" uname:查看系统与内核相关信息"></a><a name="ch3.2"> uname:查看系统与内核相关信息</a></h3><p>uname相关选项:</p>
<ul>
<li><code>a</code> : 所有信息</li>
<li><code>s</code> : 内核名称</li>
<li><code>r</code> ： 内核版本</li>
<li><code>m</code> : 本系统的硬件名称,如i686或x86_64</li>
<li><code>i</code> ： 硬件架构,i686等</li>
</ul>
<h3 id="uptime-查看系统启动时间与工作负载"><a href="#uptime-查看系统启动时间与工作负载" class="headerlink" title=" uptime:查看系统启动时间与工作负载"></a><a name="ch3.3"> uptime:查看系统启动时间与工作负载</a></h3><p>uptime所查看的信息就是top描述系统信息的部分</p>
<h3 id="netstat-跟踪网络"><a href="#netstat-跟踪网络" class="headerlink" title=" netstat:跟踪网络"></a><a name="ch3.4"> netstat:跟踪网络</a></h3><p>netstat被用在网络监控方面,以下网络连接,与本地socket的信息
以下是一些选项</p>
<ul>
<li><code>a</code> : 列出目前系统所有连接/socket/监听</li>
<li><code>t</code> : 列出tcp网络数据包的数据</li>
<li><code>u</code>：列出udp网络数据包的数据</li>
<li><code>n</code> : 不列出进程的服务名称,以端口号显示</li>
<li><code>l</code>: 列出目前正在网络监听的服务</li>
<li><code>p</code>:显示PID</li>
</ul>
<p>比如列出目前系统上已在监听的网络连接及PID:<code>netstat -tlnp</code></p>
<h3 id="dmesg-分析内核产生的信息-主机硬件信息"><a href="#dmesg-分析内核产生的信息-主机硬件信息" class="headerlink" title=" dmesg:分析内核产生的信息(主机硬件信息)"></a><a name="ch3.5"> dmesg:分析内核产生的信息(主机硬件信息)</a></h3><p>dmesg是用来查看内核分析出来的主机硬件信息的,通常配合grep一起使用</p>
<h3 id="vmstat-动态跟踪系统资源的变化"><a href="#vmstat-动态跟踪系统资源的变化" class="headerlink" title=" vmstat:动态跟踪系统资源的变化"></a><a name="ch3.6"> vmstat:动态跟踪系统资源的变化</a></h3><p>vmstat可以检测CPU/内存/磁盘的IO状态等.下面是常见的参数说明:</p>
<ul>
<li><code>vmstat time</code>:vmstat默认是检测CPU/内存等信息,time为秒数,表示动态跟踪</li>
<li><code>vmstat -d</code> 磁盘IO总量统计表</li>
<li><code>vmstat -p 分区</code> 显示该分区的IO总量统计表</li>
</ul>
<h3 id="proc目录"><a href="#proc目录" class="headerlink" title=" /proc目录"></a><a name="ch3.7"> /proc目录</a></h3><p>/proc目录存放的是内存中的数据,每一个进度都会在/proc下创建一个以PID为名的子目录,进程目录下存放着相当多的文件,比如cmdline是存放启动此进程的命令,environ是这个进程的环境变量</p>
<h2 id="SELinux"><a href="#SELinux" class="headerlink" title=" SELinux"></a><a name="ch4"> SELinux</a></h2><h3 id="什么是SELinux"><a href="#什么是SELinux" class="headerlink" title=" 什么是SELinux"></a><a name="ch4.1"> 什么是SELinux</a></h3><p>SELinux是在进行程序/文件等权限设置依据的一个内核模块,是程序进程能访问系统资源的一道关卡,通常用于控制网络服务.</p>
<p>SELinux是基于以策略规则制定特定程序访问特定文件的模式,即委托访问控制(MAC),我们之前用户访问文件,直接通过判断文件权限与用户对比,这种访问方式称为自主访问控制(DAC).</p>
<p>DAC的一些缺陷:</p>
<ul>
<li>root具有最高权限</li>
<li>用户取得进程来更改文件资源的访问权限</li>
</ul>
<p>而MAC是针对进程设置对文件的访问权限,通过提供一些策略来管理众多的进程与文件</p>
<h3 id="SELinux运行模式"><a href="#SELinux运行模式" class="headerlink" title=" SELinux运行模式"></a><a name="ch4.2"> SELinux运行模式</a></h3><p>SELinux是通过MAC方式控管进程的,其控管的主体是进程,而目标是文件资源,其相关性如下:</p>
<ul>
<li>主体(Subject)<ul>
<li>进程</li>
</ul>
</li>
<li>目标(Object)<ul>
<li>文件资源</li>
</ul>
</li>
<li>策略(Policy)<ul>
<li>由于进程与文件数量庞大,所有SELinux依据某些服务制定了基本的访问策略,这些策略内还会有详细的规则(rule)来制定不同服务的开放某些资源的程度</li>
<li>targetd: 针对网络服务限制较多,本机限制较少</li>
<li>strict:限制方面较严格</li>
</ul>
</li>
<li>安全上下文(security context)<ul>
<li>安全上下文是描述主体/目标的相关信息,只有当主体与目标的安全上下文匹配时,主体才能去访问目标.(当然,最后还要匹配目标的rwx权限)</li>
</ul>
</li>
</ul>
<p>SELinux 运行各组件的相关性如下图
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_27_1.gif?raw=true" alt=""></p>
<h3 id="安全上下文"><a href="#安全上下文" class="headerlink" title=" 安全上下文"></a><a name="ch4.3"> 安全上下文</a></h3><p>安全上下文存在于文件的inode上,因为进程也是由文件触发的,所以主体进程也有安全上下文
SELinux下,只有当主体通过策略与安全上下文的匹配后,才能得到放行.而最主要的部分就是安全上下文.</p>
<h4 id="安全上下文的查看"><a href="#安全上下文的查看" class="headerlink" title="安全上下文的查看"></a>安全上下文的查看</h4><p><b>文件安全上下文的查看: ls -Z</b>
<b>进程安全上下文的查看: ps -Z</b></p>
<p>安全上下文主要分为3个字段
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Identify:role:type</div></pre></td></tr></table></figure></p>
<ul>
<li><code>Identify</code>：标明数据所有者的身份,值为:<ul>
<li><code>root</code> root所有</li>
<li><code>system_u</code> 系统程序方面的标识,通常指服务进程</li>
<li><code>user_u</code> 一般用户</li>
</ul>
</li>
<li><code>role</code> :表明数据的角色,比如程序,文件资源等<ul>
<li><code>object_r</code>：代表文件资源</li>
<li><code>system_r</code> ： 代表进程</li>
</ul>
</li>
<li><code>type</code>:安全上下文的比较字段<ul>
<li><code>domain</code>:在主体的安全上下文中其type字段称为domain</li>
<li><code>type</code>: 在目标安全上下文其type字段称为type</li>
<li>只有domain与type匹配后,安全上下文才匹配成功</li>
<li>SELinux启动后会写入domain与type的映射表,匹配就是在映射表中搜索</li>
</ul>
</li>
</ul>
<h4 id="安全上下文的修改"><a href="#安全上下文的修改" class="headerlink" title="安全上下文的修改"></a>安全上下文的修改</h4><p>如果已知某文件的安全上下文的type字段错了,需要改回正常可以怎么做？</p>
<ul>
<li><code>chcon</code>:指定修改安全上下文的字段<ul>
<li>格式 <code>chcon [-R] [-t type] [-u user] [-r role] 文件</code>或 <code>chcon [-R] --reference=范例文件 文件</code></li>
<li>参数: <code>-R</code>是级联修改 <code>-t</code>修改type字段 <code>-u</code>修改Identify字段 <code>-r</code>修改role字段</li>
</ul>
</li>
<li><code>restorecon</code>:还原文件的默认安全上下文<ul>
<li>格式 <code>restorecon [-Rv] 文件</code></li>
</ul>
</li>
</ul>
<h3 id="SELinux的启动-关闭-查看"><a href="#SELinux的启动-关闭-查看" class="headerlink" title=" SELinux的启动/关闭/查看"></a><a name="ch4.4"> SELinux的启动/关闭/查看</a></h3><p>SELinux支持3种运行模式(注意与MAC策略模式的区别)</p>
<ul>
<li>enforcing: 强制模式,代表SELinux已正确限制访问</li>
<li>permissive:宽容模式,代表SELinux已启动,但不会限制访问,但会提出警告</li>
<li>disable:SELinux关闭</li>
</ul>
<h4 id="SELinux的查看"><a href="#SELinux的查看" class="headerlink" title="SELinux的查看"></a>SELinux的查看</h4><ul>
<li><code>getenforce</code>:查看SELinux的运行模式</li>
<li><code>sestatus</code>:查看SELinux目前的状态,如运行模式,策略模式等</li>
</ul>
<h4 id="SELinux的启动"><a href="#SELinux的启动" class="headerlink" title="SELinux的启动"></a>SELinux的启动</h4><ol>
<li>首先了解你的系统是否装了SELinux(apt-get install selinux)</li>
<li>打开SELinux的配置文件/etc/selinux/config,将其中的SELINUX项设为enforcing,SELINUXTYPE设为targeted</li>
<li>修改/boot配置文件(/boot/grub/menu.1st或/boot/grub/grub.cfg),将其中的selinux=0改为=1(或者去掉)</li>
<li>重启主机</li>
<li>查看getenforce
(可是我在Ubuntu14.04上进行以上操作,并不能启动SELinux,待解)</li>
</ol>
<h4 id="SELinux的关闭"><a href="#SELinux的关闭" class="headerlink" title="SELinux的关闭"></a>SELinux的关闭</h4><p>只要将SELinux配置文件SELINUX改回disable，重启即可</p>
<h4 id="SELinux运行模式切换"><a href="#SELinux运行模式切换" class="headerlink" title="SELinux运行模式切换"></a>SELinux运行模式切换</h4><p>我们SELinux启动/关闭要进行上面工作,但enforcing与permissive模式的切换只要用<code>setenforce</code>即可</p>
<h3 id="SELinux的错误回报处理"><a href="#SELinux的错误回报处理" class="headerlink" title=" SELinux的错误回报处理"></a><a name="ch4.5"> SELinux的错误回报处理</a></h3><p>当SELinux发生错误时,我们可以通过<code>setroubleshoot</code>或<code>auditd</code>服务收集SELinux的错误信息,并加以分析处理</p>
<h4 id="setroubleshoot：SELinux错误信息写入-var-log-messages"><a href="#setroubleshoot：SELinux错误信息写入-var-log-messages" class="headerlink" title="setroubleshoot：SELinux错误信息写入/var/log/messages"></a>setroubleshoot：SELinux错误信息写入/var/log/messages</h4><p>首先我们需要确认安装setroubleshoot,并将其启动</p>
<p>当SELinux报告错误信息后,我们可以查看/var/log/messages,其会提供解决的方法.</p>
<h4 id="auditd-SELinux日志信息写入-var-log-audit-audit-log"><a href="#auditd-SELinux日志信息写入-var-log-audit-audit-log" class="headerlink" title="auditd:SELinux日志信息写入/var/log/audit/audit.log"></a>auditd:SELinux日志信息写入/var/log/audit/audit.log</h4><p>auditd会收集SELinux的日志信息,由于auditd信息庞大,可以借由audit2why来处理导入的audit信息</p>
<h3 id="SELinuxde的策略与规则管理"><a href="#SELinuxde的策略与规则管理" class="headerlink" title=" SELinuxde的策略与规则管理"></a><a name="ch4.6"> SELinuxde的策略与规则管理</a></h3><p>我们知道,一个主体进程能否读取目标文件的重点在于SELinuxde的策略以及策略下的各项规则,然后在通过该规则的定义去处理各文件的安全上下文.</p>
<h4 id="查看当前策略提供的信息-seinfo"><a href="#查看当前策略提供的信息-seinfo" class="headerlink" title="查看当前策略提供的信息:seinfo"></a>查看当前策略提供的信息:<code>seinfo</code></h4><p>seinfo的参数有以下:</p>
<ul>
<li><code>b</code> 列出当前策略提供的所有规则种类(bool值,表示该规则启动与否)</li>
<li><code>t</code>  列出所能提供的安全上下文中的type种类</li>
<li><code>u</code> 列出所能提供的安全上下文中的Identify种类</li>
<li><code>r</code> 列出所能提供的安全上下文中的role种类</li>
</ul>
<p>比如以下看出所有与httpd有关的规则: <code>seinfo -b | grep httpd</code></p>
<h4 id="查看安全上下文type字段映射表-sesearch"><a href="#查看安全上下文type字段映射表-sesearch" class="headerlink" title="查看安全上下文type字段映射表:sesearch"></a>查看安全上下文type字段映射表:<code>sesearch</code></h4><p>基本格式 <code>sesearch [-a] [-s 主体type] [-t 目标type] [-b 策略bool]</code></p>
<ul>
<li><code>a</code> 列出该类型或布尔值的所有相关信息</li>
</ul>
<p>比如我要查找目标文件类型为httpd_sys_content_t的有关信息
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sesearch -a -t httpd_sys_content_t</div><div class="line"></div><div class="line">输出结果</div><div class="line">allow 主体安全上下文类型 目标安全上下文类型 目标文件资源格式</div></pre></td></tr></table></figure></p>
<h4 id="查看-设置规则的状态-getsebool-a-规则bool与setsebool-P-规则bool-0-1"><a href="#查看-设置规则的状态-getsebool-a-规则bool与setsebool-P-规则bool-0-1" class="headerlink" title="查看/设置规则的状态:getsebool [-a] 规则bool与setsebool [-P] 规则bool=[0|1]"></a>查看/设置规则的状态:<code>getsebool [-a] 规则bool</code>与<code>setsebool [-P] 规则bool=[0|1]</code></h4><p>我们通过<code>getsebool</code>来查看SELinux目前策略下的规则状态,<code>-a</code>是查看所有规则条款
而<code>setsebool</code>来设置规则条款的状态 0-关闭 1-开启 -P直接写入配置文件</p>
<h4 id="默认目录的安全上下文查询与修改-semanage"><a href="#默认目录的安全上下文查询与修改-semanage" class="headerlink" title="默认目录的安全上下文查询与修改:semanage"></a>默认目录的安全上下文查询与修改:<code>semanage</code></h4><p>semanage的查询格式：<code>semanage {user|port|interface|fcontext|login} -l</code> (其中fcontext是用与安全上下文方面)
semanage的修改格式 : <code>semanage fcontext -{a|d|m} [-tru] file_spec</code></p>
<ul>
<li><code>a|d|m</code> 增/删/改 一条安全上下文</li>
<li><code>tru</code>  对于安全上下文的类型/角色/身份上的处理</li>
<li><code>file_spec</code> 针对的目标文件或主体文件的路径名(如/srv/samba(/.*)?)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工作管理-Job-Control&quot;&gt;&lt;a href=&quot;#工作管理-Job-Control&quot; class=&quot;headerlink&quot; title=&quot; 工作管理(Job Control)&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt; 工作管理(Job Control)&lt;/a&gt;
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 例行工作(at/crontab)</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E4%BE%8B%E8%A1%8C%E5%B7%A5%E4%BD%9C-at-crontab/"/>
    <id>http://yoursite.com/2016/09/06/Linux-例行工作-at-crontab/</id>
    <published>2016-09-06T13:08:49.000Z</published>
    <updated>2016-09-06T13:11:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是例行工作"><a href="#什么是例行工作" class="headerlink" title=" 什么是例行工作"></a><a name="ch1"> 什么是例行工作</a></h2><p>例行工作就是一些事先安排要进行的工作,其可能是周期发生,也可能是单次工作的.</p>
<h3 id="Linux工作调度种类"><a href="#Linux工作调度种类" class="headerlink" title=" Linux工作调度种类"></a><a name="ch1.1"> Linux工作调度种类</a></h3><ul>
<li>周期工作: <code>crontab</code>进行周期工作调度,其由<code>cron</code>服务支持</li>
<li>单次工作: <code>at</code>进行单次工作调度,其是一次性的,由<code>atd</code>服务支持</li>
</ul>
<h2 id="单次工作调度-at"><a href="#单次工作调度-at" class="headerlink" title=" 单次工作调度:at"></a><a name="ch2"> 单次工作调度:at</a></h2><h3 id="atd服务的启动"><a href="#atd服务的启动" class="headerlink" title=" atd服务的启动"></a><a name="ch2.1"> atd服务的启动</a></h3><p>单次工作调度：at需有atd服务支持,其启动方法如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/atd restart</div><div class="line"></div><div class="line"># 开机启动atd方法,Ubuntu不支持chkconfig,其会默认启动atd</div><div class="line">chkconfig atd on </div></pre></td></tr></table></figure></p>
<h3 id="at用户限制"><a href="#at用户限制" class="headerlink" title=" at用户限制"></a><a name="ch2.2"> at用户限制</a></h3><p>at进行工作调度,其是针对执行at命令的用户,我们并不想让所有用户都可以执行at(某些用户可能执行破坏系统的命令),所以我们会限制可at的用户.</p>
<p>at工作时会区查找/etc/at.allow和/etc/at.deny中限制的用户名单(通常at.allow与at.deny不同时存在)</p>
<h4 id="etc-at-allow"><a href="#etc-at-allow" class="headerlink" title="/etc/at.allow"></a>/etc/at.allow</h4><p>当其存在时,只有at.allow中的用户才能执行at</p>
<h4 id="etc-at-deny"><a href="#etc-at-deny" class="headerlink" title="/etc/at.deny"></a>/etc/at.deny</h4><p>当/etc/at.allow不存在,at会查找/etc/at.deny,这个文件内的用户都不能执行at</p>
<h4 id="以上两个文件都不存在"><a href="#以上两个文件都不存在" class="headerlink" title="以上两个文件都不存在"></a>以上两个文件都不存在</h4><p>只有root才能执行at</p>
<h3 id="at进行工作调度"><a href="#at进行工作调度" class="headerlink" title=" at进行工作调度"></a><a name="ch2.3"> at进行工作调度</a></h3><p><code>at</code>命令格式如下：
<code>at time</code>: 进行工作调度安排,以[CTRL]+[d]结束工作安排,并返回一个工作编号
<code>at -l</code>: 显示当前存在的工作
<code>at -d 工作编号</code>:取消某个工作
<code>at -c 工作编号</code>:显示某个工作具体的执行过程
其中<code>time</code>的格式可以有<code>HH:MM</code> <code>HH:MM YYYY-MM-DD</code> <code>now + num [minutes| hours | days | weeks]</code>等</p>
<p>一个例子:
主机预计在5小时后关机
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># at now + 5 hours    # 进入at shell的环境</div><div class="line">at &gt;  /bin/sync  #命令最好以绝对路径写,因为at shell的环境是其父进程的环境</div><div class="line">                        #比如我直接新建一个文件,其会在执行at时的目录下新建</div><div class="line">at &gt; /bin/sync</div><div class="line">at &gt; /sbin/shutdown -h 0</div><div class="line">at &gt; &lt;EOF&gt;</div><div class="line">job 5 at 2016-8-11 12:00</div></pre></td></tr></table></figure></p>
<h3 id="batch进行工作调度"><a href="#batch进行工作调度" class="headerlink" title=" batch进行工作调度"></a><a name="ch2.4"> batch进行工作调度</a></h3><p> batch其实就是at,只不过batch要求CPU工作负载低时才会进行工作.(Ubuntu的batch不能加入时间参数)
CPU负载是指单一时间点CPU负责的工作数量.</p>
<h2 id="周期工作调度-crontab"><a href="#周期工作调度-crontab" class="headerlink" title=" 周期工作调度:crontab"></a><a name="ch3"> 周期工作调度:crontab</a></h2><h3 id="cron服务"><a href="#cron服务" class="headerlink" title=" cron服务"></a><a name="ch3.1"> cron服务</a></h3><p>Linux原本就有很多周期性例行工作,所以<code>cron</code>服务会默认启动</p>
<h3 id="crontab用户限制"><a href="#crontab用户限制" class="headerlink" title=" crontab用户限制"></a><a name="ch3.2"> crontab用户限制</a></h3><p>与at用户限制类似,crontab也会限制执行的用户,crontab会去查找/etc/cron.allow与/etc/cron.deny这两个文件,如果这两个文件不存在,我们可自行创建,文件写入的用户名会被限制(一般只保留cron.deny)</p>
<h3 id="用户的周期工作调度"><a href="#用户的周期工作调度" class="headerlink" title=" 用户的周期工作调度"></a><a name="ch3.3"> 用户的周期工作调度</a></h3><p>上面提到的是对执行crontab命令的用户进行限制,当一个用户执行crontab,crontab会在<code>/var/spool/cron/crontabs</code>(Ubuntu)创建一个同用户名的文件,来记录用户的周期工作.
CentOS会在<code>/var/spool/cron</code>目录下创建同用户名的记录文件.</p>
<p>我们可以通过<code>crontab -e</code>来打开这个文件</p>
<p>这个文件的一条工作记录格式如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0   12   *   *    *   echo &quot;Hello World!&quot; &gt; /tmp/test.log</div><div class="line">#一条工作记录由5个字段组成,分别是</div><div class="line">#分 时 日 月 周 命令</div><div class="line">#时间参数可以用特殊值来表示如下:</div><div class="line">*  :  代表任何时刻都接受</div><div class="line">,   :  代表时刻A和时刻B都接受,比如 0 3,6 * * * 每天3点和6点</div><div class="line">-   :  代表某个时间段,比如0,3-6 * * * 每天3点到6点</div><div class="line">/n : 代表间隔n个时间单位,比如*/5 * * * * 每5分钟</div></pre></td></tr></table></figure></p>
<p>如果要删除某个工作,用<code>crontab -e</code>打开文件后删除相应的工作记录即可.</p>
<p>如果root要为某用户安排工作,可以使用<code>crontab -u username -e</code> 或者直接打开用户的工作记录文件.</p>
<h3 id="系统的周期工作调度"><a href="#系统的周期工作调度" class="headerlink" title=" 系统的周期工作调度"></a><a name="ch3.4"> 系统的周期工作调度</a></h3><p>系统的周期工作记录文件在/etc/crontab中,我们打开/etc/crontab,可以看到如下类似的工作记录
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> # m h dom mon dow user  command</div><div class="line">25 6    * * *   root    cd / &amp;&amp;run-parts --report /etc/cron.daily</div><div class="line"></div><div class="line"># 工作记录与用户的工作记录类似,多了一个user字段</div><div class="line"># 上面的工作是每天6时25分钟时执行/etc/cron.daily目录下的所有可执行文件.</div><div class="line"># run-parts是执行指定目录下的所有文件</div><div class="line"># 执行者是root</div><div class="line"># 当然我们可以不进行run-parts,直接执行某个命令.</div><div class="line"># 也可以指定某个目录,放置要执行的script文件,再进行run-parts</div></pre></td></tr></table></figure></p>
<h3 id="唤醒停机期间的工作调度-anacron"><a href="#唤醒停机期间的工作调度-anacron" class="headerlink" title=" 唤醒停机期间的工作调度:anacron"></a><a name="ch3.5"> 唤醒停机期间的工作调度:anacron</a></h3><p>当主机停机期间,安排好的工作并不能执行,哪该怎么办?
<code>anacron</code>会帮我们处理这个问题.其本质也是一个crontab</p>
<h4 id="anacron工作原理"><a href="#anacron工作原理" class="headerlink" title="anacron工作原理"></a>anacron工作原理</h4><p>当我们每次处理crontab安排的工作时,都会先处理anacron安排的工作,anacron安排的工作很简单,就是记录这次处理crontab的时间(时间记录在目录/var/spool/anacront/下的子文件).当我们下次处理anacron工作时,会比较与前一个时间的差值,看它是否满足工作记录的要求,不满足就进行差值时间内之前的crontab工作.</p>
<h4 id="anacron工作记录文件-etc-anacrontab"><a href="#anacron工作记录文件-etc-anacrontab" class="headerlink" title="anacron工作记录文件/etc/anacrontab"></a>anacron工作记录文件/etc/anacrontab</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># These replace cron&apos;s entries</div><div class="line">1       5       cron.daily      run-parts --report /etc/cron.daily</div><div class="line"></div><div class="line"># 上面工作记录表示:此条工作名为cron.daily,其每天执行的(1),执行会延迟5分钟才开始</div><div class="line"># 执行命令是 run-parts --report /etc/cron.daily</div><div class="line"></div><div class="line">7       10      cron.weekly     run-parts --report /etc/cron.weekly</div><div class="line"></div><div class="line"># 还有下面这条工作记录,应该看得懂吧</div></pre></td></tr></table></figure>
<p>如果我们自己要安排一些周期工作,又担心系统停机后没处理到数据,那就可以在/etc/anacrotab中指定.anacron记录的时间在文件/var/spool/anacron/工作名中</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是例行工作&quot;&gt;&lt;a href=&quot;#什么是例行工作&quot; class=&quot;headerlink&quot; title=&quot; 什么是例行工作&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt; 什么是例行工作&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;例行工作就是一些事先安排要进行的工作,其可能是周期发生,也可
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 磁盘额度(Quota)与高级文件系统管理(RAID/LVM)</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E7%A3%81%E7%9B%98%E9%A2%9D%E5%BA%A6-Quota-%E4%B8%8E%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86-RAID-LVM/"/>
    <id>http://yoursite.com/2016/09/06/Linux-磁盘额度-Quota-与高级文件系统管理-RAID-LVM/</id>
    <published>2016-09-06T13:00:58.000Z</published>
    <updated>2016-09-06T13:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="磁盘额度-quota"><a href="#磁盘额度-quota" class="headerlink" title=" 磁盘额度(quota)"></a><a name="ch1"> 磁盘额度(quota)</a></h2><h3 id="什么是quota"><a href="#什么是quota" class="headerlink" title=" 什么是quota"></a><a name="ch1.1"> 什么是quota</a></h3><p>在Linux系统中，多用户多任务的环境会经常抢占资源，quota则是制定用户/用户组，对硬盘资源的进行配额 ， 妥善分配资源。</p>
<ul>
<li>quota的一般用途<ul>
<li>针对WWW server ， 例如：限制用户的网页空间容量</li>
<li>针对 mail server  ， 例如 ： 限制用户的邮件空间</li>
<li>针对 file server ， 例如 ： 限制用户最大的可能网络磁盘空间</li>
<li>限制某用户的最大磁盘配额</li>
<li>限制某用户组的最大磁盘配额</li>
<li>以LINK方式对目录进行用户/用户组配额</li>
</ul>
</li>
<li>quota的使用限制<ul>
<li>仅能针对整个文件系统， 如果某文件系统没有设置quota，其下的文件可以通过link来指向设置了quota的文件系统</li>
<li>内核必须支持quota</li>
<li>只对一般身份用户有效（root没效）</li>
<li>quota的日志文件:kernel2.6的日志文件是aquota.user aquota.group ，文件名比旧版的quota前面多了个a</li>
</ul>
</li>
<li>quota的设置选项<ul>
<li>quota可以限制文件系统的block与inode的大小：限制block的大小就是其使用文件系统容量，限制inode就是限制其可创建的文件数</li>
<li>限制值（soft/hard） ：hard表示用户使用的容量绝对不能超过此值。soft表示用户超过此值就会警告，并倒数宽限时间，超过宽限时间后hard=soft。</li>
<li>宽限时间（grace time） </li>
</ul>
</li>
</ul>
<h3 id="文件系统启用quota"><a href="#文件系统启用quota" class="headerlink" title=" 文件系统启用quota"></a><a name="ch1.2"> 文件系统启用quota</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">下面以/home的文件系统为例</div><div class="line"></div><div class="line"><span class="comment"># 查看/home是否启用quota</span></div><div class="line"><span class="comment"># mount | grep home</span></div><div class="line">/dev/mapper/vg1-lv1 on /home <span class="built_in">type</span> ext4 (rw)  <span class="comment"># 没有</span></div><div class="line"></div><div class="line"><span class="comment"># 启用 quota （用户限制与用户组限制）</span></div><div class="line"><span class="comment"># mount -o remount,usrquota,grpquota /home</span></div><div class="line">/dev/mapper/vg1-lv1 on /home <span class="built_in">type</span> ext4 (rw,usrquota,grpquota)</div><div class="line"></div><div class="line"><span class="comment"># 如果要开机就启用quota</span></div><div class="line"><span class="comment"># 可以修改/etc/fstab文件系统的选项</span></div><div class="line"></div></pre></td></tr></table></figure>
<h3 id="新建quota日志文件"><a href="#新建quota日志文件" class="headerlink" title=" 新建quota日志文件"></a><a name="ch1.3"> 新建quota日志文件</a></h3><p>quota日志文件除了进行日志记录时，也是对用户/用户组的额度进行配置
使用<code>quotacheck</code> ： 扫描文件系统并新建quota日志文件（aquota.user   aquota.group）
命令格式 ： <code>quotacheck -vug /mount_point</code>   :  <code>v</code>：显示进度  <code>u</code>：新建用户日志 <code>g</code>：新建用户组日志</p>
<h3 id="启动-停止quota与限制值设置"><a href="#启动-停止quota与限制值设置" class="headerlink" title=" 启动/停止quota与限制值设置"></a><a name="ch1.4"> 启动/停止quota与限制值设置</a></h3><p>启动quota：quotaon /mount_point
停止quota：quotaoff /mount_point</p>
<p>限制值设置：edquota与setquota
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># 以限制用户额度为例</div><div class="line"># edquota -u user1 [-g groupname]  #其会打开一个关于此用户限值设置的文档</div><div class="line"></div><div class="line">FileSystem Blocks  soft hard Inodes  soft  hard</div><div class="line">/dev/sda9     80    0     0       10     0   0</div><div class="line"></div><div class="line">FileSystem：针对的文件系统</div><div class="line">Blocks：磁盘容量,单位KB</div><div class="line">soft：blocks的soft 单位KB,0表示不限制</div><div class="line">hard：block的hard</div><div class="line">inodes： Inode数量，单位个数</div><div class="line">soft:Inode的soft</div><div class="line">hard: Inode的hard</div><div class="line"></div><div class="line">我们通常只会设置block的soft与hard</div><div class="line"></div><div class="line">setquota可以帮助我们在shell script中设置quota</div><div class="line">其格式为：setquota [-u name][-g name] blockSoft blockHard inodeSoft inodeHard /mount_point</div><div class="line"></div><div class="line">设置宽限时间</div><div class="line">edquota -t </div></pre></td></tr></table></figure></p>
<h3 id="quota当前情况报表以及警告信息"><a href="#quota当前情况报表以及警告信息" class="headerlink" title=" quota当前情况报表以及警告信息"></a><a name="ch1.5"> quota当前情况报表以及警告信息</a></h3><p>针对用户/用户组的报表 ：  quota [-u|-g]vs name
针对文件系统的报表： repquota -augvs</p>
<p>发送警告信息：warnquota（当有用户超过soft时，才会成功送出两份mail，分别给root与该用户），如果要明天定时执行warnquota，可以在/etc/cron.daily/warnquota中写入<code>warnquota命令的绝对路径</code></p>
<h2 id="磁盘阵列-RAID"><a href="#磁盘阵列-RAID" class="headerlink" title=" 磁盘阵列(RAID)"></a><a name="ch2"> 磁盘阵列(RAID)</a></h2><h3 id="什么是RAID"><a href="#什么是RAID" class="headerlink" title=" 什么是RAID"></a><a name="ch2.1"> 什么是RAID</a></h3><p>磁盘阵列(RAID)，即容错廉价磁盘阵列，其有多个较小的磁盘整合成一个较大的磁盘。其不只具有存储功能，还有数据保护和性能优化等功能。 特别是用相同型号等大小的磁盘组成时性能最优，以下是其整合模式。</p>
<h4 id="RAID-0-等量模式-性能最优"><a href="#RAID-0-等量模式-性能最优" class="headerlink" title="RAID-0(等量模式):性能最优"></a>RAID-0(等量模式):性能最优</h4><p>数据依次放到各个磁盘中，由于磁盘是交错放置数据的，所以数据会被等量分到各个磁盘中。此中模式性能最优，但是没有对数据毁坏的处理。</p>
<h4 id="RAID-1-映像模式-完整备份"><a href="#RAID-1-映像模式-完整备份" class="headerlink" title="RAID-1(映像模式):完整备份"></a>RAID-1(映像模式):完整备份</h4><p>一份数据会存放在RAID中存放两次。所以RAID-1的容量只是组成磁盘总容量的一半(或者更小)。优点是完整备份数据，性能较差。</p>
<h4 id="RAID0-1与RAID1-0"><a href="#RAID0-1与RAID1-0" class="headerlink" title="RAID0+1与RAID1+0"></a>RAID0+1与RAID1+0</h4><p>磁盘先组成RAID0或1，再去组成RAID1或0，这种模式优化了性能，又备份了数据。但是组成的硬盘较多，容量也只有这些硬盘的一半。</p>
<h4 id="RAID-5：性能与数据均衡考虑"><a href="#RAID-5：性能与数据均衡考虑" class="headerlink" title="RAID-5：性能与数据均衡考虑"></a>RAID-5：性能与数据均衡考虑</h4><p>RAID-5：至少需要3个硬盘以上。数据以RAID-0方式依次循环写硬盘中，但是一个循环过程会在某个硬盘写入一同步检查码(其可以恢复此轮循环中写入其他盘的数据)，由于检查码会用掉一个硬盘，所以RAID-5的总量等于硬盘-1的容量。</p>
<h4 id="Spare-Disk：-预备盘"><a href="#Spare-Disk：-预备盘" class="headerlink" title="Spare Disk： 预备盘"></a>Spare Disk： 预备盘</h4><p>组成RAID时，会多准备出几个空盘，当RAID中某盘坏掉时，系统会抽出坏盘，抽入一个预备盘。</p>
<h3 id="软磁盘阵列"><a href="#软磁盘阵列" class="headerlink" title=" 软磁盘阵列"></a><a name="ch2.2"> 软磁盘阵列</a></h3><p>软磁盘阵列，相对与硬磁盘阵列，是用软件来模拟出RAID的功能，但实际上盘是不会改变的，坏盘了还是GG.</p>
<h4 id="软磁盘阵列的设置"><a href="#软磁盘阵列的设置" class="headerlink" title=" 软磁盘阵列的设置"></a><a name="ch2.2.1"> 软磁盘阵列的设置</a></h4><p>使用如下的命令
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 创建一个名为md0的RAID,RAID模式5，用sda8,9,10构成RAID,用sda11,12构成预备盘</div><div class="line">mdadm --create --auto=yes /dev/md0   --raid-devices=3 --level=5  --spare-devices=2  /dev/sda&#123;8,9,10,11,12&#125;</div><div class="line"></div><div class="line"># 查看md0情况</div><div class="line">mdadm --detail /dev/md0</div></pre></td></tr></table></figure></p>
<h4 id="软磁盘阵列的管理"><a href="#软磁盘阵列的管理" class="headerlink" title=" 软磁盘阵列的管理"></a><a name="ch2.2.2"> 软磁盘阵列的管理</a></h4><p>使用如下命令对raid进行管理
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mdadm --manage /dev/md0 [--add 设备名] [--remove 设备名] [--fail 设备名]</div><div class="line"># 其中fail是设置raid中的设备出错</div></pre></td></tr></table></figure></p>
<h4 id="软磁盘阵列的开机挂载"><a href="#软磁盘阵列的开机挂载" class="headerlink" title=" 软磁盘阵列的开机挂载"></a><a name="ch2.2.3"> 软磁盘阵列的开机挂载</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先查出raid设备的uuid</span></div><div class="line">mdadm --detail /dev/md0</div><div class="line"></div><div class="line"><span class="comment"># 设置mdadm的映射关系</span></div><div class="line">在/etc/mdadm.conf中添加`ARRAY /dev/md0 UUID=值</div><div class="line"></div><div class="line"><span class="comment"># 设置etc/fstab</span></div></pre></td></tr></table></figure>
<h4 id="软磁盘阵列的关闭"><a href="#软磁盘阵列的关闭" class="headerlink" title=" 软磁盘阵列的关闭"></a><a name="ch2.2.4"> 软磁盘阵列的关闭</a></h4><p>首先先停止RAID的挂载，再执行<code>mdadm --stop</code>，最后可能会要修改回/etc/mdadm.conf</p>
<h2 id="逻辑卷管理-LVM"><a href="#逻辑卷管理-LVM" class="headerlink" title=" 逻辑卷管理(LVM)"></a><a name="ch3"> 逻辑卷管理(LVM)</a></h2><h3 id="什么是LVM"><a href="#什么是LVM" class="headerlink" title=" 什么是LVM"></a><a name="ch3.1"> 什么是LVM</a></h3><p>LVM可以弹性调整文件系统的容量,其可以整合多个物理分区成为一个逻辑分区,当然也可以从逻辑分区中删除物理分区。</p>
<p>其作法是:将几个物理分区(PV)组合成一个分区组(VG),在从VG中划分从逻辑区(LV)供文件系统挂载。
LVM中的最小单位是物理扩展块(PE),有点类似blocks,PE是PV的最小单位,其可以指定大小(需2的倍数),我们可以通过LV中PE的数量来调整LV的大小。</p>
<p>PE/VG/LV关系图如下
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_25_2.gif?raw=true" alt="">
这图可以将每两组看作一个PV,更好理解LVM各单位的关系</p>
<p>LVM实现过程如下图：
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_25_3.jpg?raw=true" alt=""></p>
<h3 id="LVM实现过程"><a href="#LVM实现过程" class="headerlink" title=" LVM实现过程"></a><a name="ch3.2"> LVM实现过程</a></h3><h4 id="PV阶段"><a href="#PV阶段" class="headerlink" title="PV阶段"></a>PV阶段</h4><ul>
<li>pvcreate : 将物理分区(System Id 要改为8e)新建成PV</li>
<li>pvdisplay: 显示目前系统的PV状态</li>
<li>pvremove: 将PV属性删除,物理无法不具有PV属性
以下命令将sda6,7,8,9构建成pv<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pvcreate /dev/sda&#123;6,7,8,9&#125;  #pv名同设备名</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="VG阶段"><a href="#VG阶段" class="headerlink" title="VG阶段"></a>VG阶段</h4><ul>
<li>vgcreate:新建vg,基本格式是 <code>vgcreate -s PE大小 VG名 PV名</code></li>
<li>vgdisplay:显示目前系统的vg状态</li>
<li>vgextend:vg内增加额外的pv 格式是<code>vgextend VG名 PV名</code></li>
<li>vgreduce:vg内删除pv,格式类似vgextend</li>
<li>vgchange:激活/失活vg,在删除pv时都要失活vg,格式<code>vgchange -a n vg名</code></li>
<li>vgremove:删除vg
以下命令是将sda6,7,8构成一个vg,再添加sda9<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vgcreate -s 4M vg1 /dev/sda&#123;6,7,8&#125;  #构成出的vg1设备名是/dev/vg1</div><div class="line">vgextend vg1 /dev/sda9</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="LV阶段"><a href="#LV阶段" class="headerlink" title="LV阶段"></a>LV阶段</h4><ul>
<li>lvcreate:新建LV,可以直接指定大小(-L)或者通过PE个数来指定大小(-l) 基本格式是<code>lvcreate -l num -n lv名 vg名</code></li>
<li>lvdisplay:显示目前系统的lv状态</li>
<li>lvresize:对LV进行容量大小调整(+|-)</li>
<li>lvremove:删除一个LV
以下命令是在vg1下构建一个由365个PE构成的lv<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lvcreate -l 365 -n lv1 /dev/vg1 # 构建成的lv 设备名是/dev/vg1/lv1</div></pre></td></tr></table></figure>
最后就可以直接格式话化lv,并进行挂载</li>
</ul>
<h3 id="放大-缩小LV容量"><a href="#放大-缩小LV容量" class="headerlink" title=" 放大/缩小LV容量"></a><a name="ch3.3"> 放大/缩小LV容量</a></h3><h4 id="放大LV容量"><a href="#放大LV容量" class="headerlink" title="放大LV容量"></a>放大LV容量</h4><p>其过程可以在线完成(即vg活动时),一般步骤如下:</p>
<ol>
<li>构建pv (pvcreate)</li>
<li>将pv加入vg (vgextend)</li>
<li>放大lv容量 (lvresize)</li>
<li>修改文件系统容量(修改超级块信息,resize2fs):resize2fs格式是<code>resize2fs 设备 [size]</code>
以下将sda10加入到vg,以扩展lv<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 创建pv</div><div class="line">pvcreate /dev/sda10</div><div class="line"></div><div class="line"># 向vg添加pv</div><div class="line">vgextend vg1 /dev/sda10</div><div class="line"></div><div class="line"># 放大lv容量</div><div class="line">lvresize -l +179 /dev/vg1/lv1</div><div class="line"></div><div class="line"># 修改文件系统容量</div><div class="line">resize2fs /dev/vg1/lv1</div><div class="line"></div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="缩小LV容量"><a href="#缩小LV容量" class="headerlink" title="缩小LV容量"></a>缩小LV容量</h4><p>缩小lv容量不能在vg活动时进入,具体过程就是放大lv容量的逆过程(注意:一定要先resize2fs,不然可能文件系统损坏)
以下将/dev/sda10移出vg1
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># 系统要求在resize2fs时先进行磁盘检查</div><div class="line">e2fsck -f /dev/vg1/lv1</div><div class="line"></div><div class="line"># 修改文件系统size,以减去/dev/sda10的大小</div><div class="line">resize2fs /dev/vg1/lv1 6900M</div><div class="line"></div><div class="line"># 失活vg1</div><div class="line">vgchange -a n vg1  (-a y 是激活)</div><div class="line"></div><div class="line"># lv缩小容量</div><div class="line">lvresize -l -179 /dev/vg1/lv1</div><div class="line"></div><div class="line"># vg1移出/dev/sda10</div><div class="line">vgreduce vg1 /dev/sda10</div><div class="line"></div><div class="line"># /dev/sda10删除pv属性</div><div class="line">pvremove /dev/sda10</div><div class="line"></div><div class="line"># 激活vg1</div><div class="line">vgchange -a y vg1</div></pre></td></tr></table></figure></p>
<h3 id="LVM的快照功能"><a href="#LVM的快照功能" class="headerlink" title=" LVM的快照功能"></a><a name="ch3.4"> LVM的快照功能</a></h3><p>LVM的快照区会保存建立快照时的文件系统中的数据,当然这个快照区有一定的最值,当系统变化太多时,快照区就会饱满,通过我们建立快照区来备份某个时刻的数据,以恢复文件系统(比如,教学环境中,老师会将系统建立快照区,再将挂载快照区的文件系统供学生使用.这样并不会影响到原文件系统)</p>
<p>建立快照区的命令
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 建立了lv1的100M快照区</div><div class="line">lvcreate -L 100M -s -n lv1ss /dev/vg1/lv1</div><div class="line"></div><div class="line"># 之后我们可以挂载这个快照区</div><div class="line">mount /dev/vg1/lv1ss /mnt/tmp</div><div class="line"></div><div class="line"># 再备份数据出来待恢复使用</div><div class="line">tar -jcv -f /mnt/backup/lv1.backup /mnt/tmp </div><div class="line"># 注意不能直接从快照区复制数据到原区,原区数据会覆盖删去后都转到快照区的</div></pre></td></tr></table></figure></p>
<h3 id="LVM的相关命令汇总与LVM的关闭"><a href="#LVM的相关命令汇总与LVM的关闭" class="headerlink" title=" LVM的相关命令汇总与LVM的关闭"></a><a name="ch3.5"> LVM的相关命令汇总与LVM的关闭</a></h3><p>LVM相关命令汇总如下图:
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_25_1.png?raw=true" alt=""></p>
<p>LVM的关闭步骤如下:</p>
<ol>
<li>使用lvremove删除所有lv</li>
<li>使vg失活 vgchange -a n vgname</li>
<li>使用vgremove删除vg</li>
<li>使用pvremoe删除pv</li>
<li>fdisk 回收 分区</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;磁盘额度-quota&quot;&gt;&lt;a href=&quot;#磁盘额度-quota&quot; class=&quot;headerlink&quot; title=&quot; 磁盘额度(quota)&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt; 磁盘额度(quota)&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;什么是quota&quot;&gt;&lt;
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 账号管理与ACL权限</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E4%B8%8EACL%E6%9D%83%E9%99%90/"/>
    <id>http://yoursite.com/2016/09/06/Linux-账号管理与ACL权限/</id>
    <published>2016-09-06T12:52:44.000Z</published>
    <updated>2016-09-06T12:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="  用户管理"></a><a name="ch1">  用户管理</a></h2><p>Linux用户信息保存在<code>/etc/passwd</code>,用户密码信息保存在<code>/etc/shadow</code>,用户组信息保存在<code>/etc/group</code>,用户组密码信息保存在<code>/etc/gshadow</code>中.</p>
<p>下面我们以手工创建一个用户为例,了解上述各文件的结构.</p>
<h3 id="手工新建用户"><a href="#手工新建用户" class="headerlink" title="  手工新建用户"></a><a name="ch1.1">  手工新建用户</a></h3><p>手工新建用户流程 :</p>
<ol>
<li>新建所需要的用户组 (<code>vim /etc/group</code>)</li>
<li>将<code>/etc/group</code>与<code>/etc/gshadow</code>同步 (<code>grpconv</code>)</li>
<li>新建用户信息 (<code>vim /etc/passwd</code>)</li>
<li>将<code>/etc/passwd</code>与<code>/etc/shadow</code>同步 (<code>pwconv</code>)</li>
<li>新建用户密码 (<code>passwd username</code>)</li>
<li>新建用户主文件夹 (<code>cp -a /etc/skel /home/username</code>)</li>
<li>更改用户主文件夹属性 (<code>chown -R username:groupname /home/username</code>)</li>
<li>检查设置 (<code>pwck</code>)</li>
</ol>
<p>具体步骤:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">1.新建所需的用户组  (vim /etc/group)</div><div class="line">在最后一行加入一条用户组信息(其由4个字段组成, 组名:用户组密码(通常在/etc/gshadow设置,不设置以x表示)</div><div class="line">:GID(通常500以下保留给系统,新建的用户组用现有最大GID+1):用户组成员)</div><div class="line">比如加入一条用户组信息</div><div class="line">normal:x:1001:</div><div class="line"></div><div class="line">2.将/etc/group与/etc/gshadow同步 (grpconv)</div><div class="line">我们使用grpconv将在/etc/group加入的用户组信息同步到/etc/gshadow中.</div><div class="line">/etc/gshadow的结构也由4个字段组成,组名:密码列(开头以!表示不合法密码):用户组管理员:组员</div><div class="line">比如加入一条用户组密码信息(grpconv会同步创建)</div><div class="line">normal:*::</div><div class="line"></div><div class="line">3.新建用户信息 (vim /etc/passwd)</div><div class="line">同样我们在最后一行加入一条用户信息,(由7个字段组成,用户名:用户密码(也由/etc/shadow中代替)</div><div class="line">:UID(通常500以下为系统账号,100以下为系统默认创建,root=0):GID(初始用户组):备注:用户主目录:shell)</div><div class="line">比如加入一条用户信息</div><div class="line">myuser:x:1000:1002::/home/myuser:/bin/bash</div><div class="line"></div><div class="line">4.将/etc/passwd与/etc/shadow同步 (pwconv)</div><div class="line">pwconv将/etc/passwd的用户信息同步到/etc/shadow中,/etc/shadow由9个字段组成,用户名:用户密码(通常由MD5加密后):</div><div class="line">最近密码修改的时间(以天数为单位,后面的字段也是):密码可再次修改的最短时间:</div><div class="line">密码需要重新修改的时间:密码需重新修改的提醒时间(以上个字段为基准):</div><div class="line">密码过期后的宽限时间:账号失效时间(过了这个时间,账号就失效):保留</div><div class="line"></div><div class="line">比如下面这条用户密码信息(pwconv会帮我们创建,其会去参考/etc/default/useradd与/etc/login.defs)</div><div class="line">myuser:$6$4EZkAqYO$ghF87vQWxWAB17Z05OFQrCNfPrkWpceUhSzmxXHQ57hvH/U4PvVPs7r</div><div class="line">tzRAt17VNMYcUD2yhdGgZirNGqX6Il.:17000:0:99999:7::::</div><div class="line"></div><div class="line">5.新建用户密码 (passwd username)</div><div class="line">新建密码我们使用工具passwd来信息</div><div class="line"></div><div class="line">6.新建用户主文件夹 (cp -a /etc/skel /home/username)</div><div class="line">当然我们可以直接新建/home/username,但是我们有些默认的文件想在用户创建时就给予用户,</div><div class="line">通常会将/etc/skel文件给用户,系统创建时也是将/etc/skel的文件给与用户</div><div class="line">(同样,这个操作系统参考/etc/default/useradd的配置),所以我们可以将文件加到/etc/skel中</div><div class="line"></div><div class="line">7.更改用户主文件夹属性及权限 (chown -R username:groupname /home/username 与chmod)</div><div class="line">将用户主文件夹及子文件都改成用户所属</div><div class="line"></div><div class="line"></div><div class="line">8.检查设置 (pwck)</div><div class="line">pwck会报出设置错误信息</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>通过手工新建用户,我们知道系统在新建用户时会进行的操作,就是修改<code>/etc/passwd</code>  <code>/etc/shadow</code>
<code>/etc/group</code> <code>/etc/gshadow</code>还有就是创建用户主文件夹</p>
<h3 id="用户管理工具"><a href="#用户管理工具" class="headerlink" title="  用户管理工具"></a><a name="ch1.2">  用户管理工具</a></h3><h4 id="新建用户-useradd"><a href="#新建用户-useradd" class="headerlink" title="  新建用户 : useradd"></a><a name="ch1.2.1">  新建用户 : useradd</a></h4><p>useradd会参考/etc/default/useradd与/etc/login.defs文件来新建用户,其会去修改上述的/etc/passwd等4个文件</p>
<p> /etc/default/useradd的默认配置(各系统可能不一样)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GROUP=100    # 默认的初始用户组</div><div class="line">HOME=/home  # 用户主文件夹所在目录</div><div class="line">INACTIVE=-1   # 密码过期宽限时间(-1 表示密码过期后永远不失效)</div><div class="line">EXPIRE=          # 账号失效时间</div><div class="line">SKEL=/etc/skel # 用户主文件夹参考目录</div><div class="line">CREATE_MAIL_SPOOL=no # 不创建用户邮件邮箱</div><div class="line">SHELL=/bin/sh   #默认的shell</div></pre></td></tr></table></figure></p>
<p>/etc/login.defs的默认配置(各系统可能不一样)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PASS_MAX_DAYS   99999  #密码需要重新修改的时间</div><div class="line">PASS_MIN_DAYS  0  # 密码可再次修改的最短时间</div><div class="line">PASS_MIN_LEN  5  # 密码最短长度,已失效,被PAM模块代替(PAM是Linux下应用程序需要鉴定功能的调用的API)</div><div class="line">PASS_WARN_AGE 7 #密码需重新修改的提醒时间</div><div class="line"></div><div class="line">UID_MIN   500  # 一般用户最小的UID,小于500被系统保留</div><div class="line">UID_MAX  60000 # 一般用户最大的UID</div><div class="line">GID_MIN 500  # 用户组最小GID,小于500被系统保留</div><div class="line">GID_MAX 60000 # 用户组最大的GID</div><div class="line"></div><div class="line">UMASK 077  # 用户主文件夹的默认权限</div></pre></td></tr></table></figure></p>
<p>useradd的基本格式是: useradd [参数] 用户名
常用参数:</p>
<ul>
<li><code>m</code>  强制创建用户主目录</li>
<li><code>M</code>  强制不创建用户主目录</li>
<li><code>r</code>   创建系统账号</li>
<li><code>G</code>  次要用户组,如果要添加用户组,也可以在这里指定 - <code>aG</code></li>
<li><code>s</code>  指定shell</li>
<li><code>d</code>  指定用户主目录</li>
</ul>
<h4 id="修改用户-usermod"><a href="#修改用户-usermod" class="headerlink" title="  修改用户 : usermod"></a><a name="ch1.2.2">  修改用户 : usermod</a></h4><p>usermod与useradd的参数类似, 这里列一些
参数:</p>
<ul>
<li><code>l</code>  修改用户名,后接新的用户名</li>
<li><code>L</code>  冻结用户密码,使其无法登录(其实就是在/etc/shadow中的密码字段最前面加了!!)</li>
<li><code>U</code>  解冻用户</li>
</ul>
<h4 id="删除用户-userdel"><a href="#删除用户-userdel" class="headerlink" title="  删除用户 : userdel"></a><a name="ch1.2.3">  删除用户 : userdel</a></h4><p>userdel -r 会删除用户相关数据,删除了/etc/passwd,/etc/shadow,/etc/group,/etc/gshadow相关数据与/home/username,/var/spool/mail/username</p>
<h3 id="用户密码管理工具"><a href="#用户密码管理工具" class="headerlink" title="  用户密码管理工具"></a><a name="ch1.3">  用户密码管理工具</a></h3><h4 id="修改用户密码-passwd-与chpasswd"><a href="#修改用户密码-passwd-与chpasswd" class="headerlink" title="  修改用户密码 : passwd 与chpasswd"></a><a name="ch1.3.1">  修改用户密码 : passwd 与chpasswd</a></h4><p>查看密码状态可以使用 passwd -S</p>
<p>其中如果想在shell script中输入用户密码可以
echo “Userpasswd” | passwd –stdin $username 或者 printf “Userpasswd\nUserpasswd\n” | passwd $username</p>
<p>chpasswd也是用来修改密码的,其格式一定要”username:password”这个形式,如下
echo “username:password” | chpasswd -m 
-m 以MD5加密</p>
<h4 id="修改用户密码时间-chage"><a href="#修改用户密码时间-chage" class="headerlink" title="  修改用户密码时间 : chage"></a><a name="ch1.3.2">  修改用户密码时间 : chage</a></h4><p>记住我们/etc/shadow中有关密码时间由很多字段吧,chage -l 可以更直观地列出这些字段的信息.
除外也可以用相关的参数去修改这些字段,如-d 修改最近一次改动密码的时间(如果我们想用户第一次登录系统后就要求其修改密码 可以 <code>chage -d 0 username</code>)</p>
<h3 id="用户组管理工具"><a href="#用户组管理工具" class="headerlink" title="  用户组管理工具"></a><a name="ch1.4">  用户组管理工具</a></h3><h4 id="用户初始用户组与有效用户组"><a href="#用户初始用户组与有效用户组" class="headerlink" title="  用户初始用户组与有效用户组"></a><a name="ch1.4.1">  用户初始用户组与有效用户组</a></h4><p>当用户创建会指定用户组(-g),那个用户就是初始用户组,也可以那么说,/etc/passwd中相关用户信息的那个用户组字段就是初始用户组</p>
<p>有效用户组就是当前用户作用的用户组,比如新建文件时的用户组信息等.</p>
<p>显示当前用户的用户组信息可以使用<code>groups</code>(第1个用户组为有效用户组)或者<code>id</code></p>
<p>切换当前有效用户组 可以使用<code>newgrp</code></p>
<h4 id="新建用户组-groupadd"><a href="#新建用户组-groupadd" class="headerlink" title="  新建用户组 : groupadd"></a><a name="ch1.4.2">  新建用户组 : groupadd</a></h4><p>-r 会修改系统用户组</p>
<h4 id="修改用户组信息-groupmod"><a href="#修改用户组信息-groupmod" class="headerlink" title="  修改用户组信息: groupmod"></a><a name="ch1.4.3">  修改用户组信息: groupmod</a></h4><p>groupmod会去修改/etc/group相关字段</p>
<h4 id="删除用户组-groupdel"><a href="#删除用户组-groupdel" class="headerlink" title="  删除用户组:groupdel"></a><a name="ch1.4.4">  删除用户组:groupdel</a></h4><h4 id="用户组管理员-gpasswd"><a href="#用户组管理员-gpasswd" class="headerlink" title="  用户组管理员:gpasswd"></a><a name="ch1.4.5">  用户组管理员:gpasswd</a></h4><ul>
<li>添加用户组密码:gpasswd groupname</li>
<li>删除用户组密码:gpasswd -r groupname</li>
<li>添加用户组管理员(那么其可以执行gpasswd):gpasswd -A user1,user2.. groupname</li>
<li>添加用户组成员:gpasswd -M user1,user2…groupname</li>
<li>添加用户至用户组:gpasswd -a user1 groupname</li>
<li>删除用户:gpasswd -d user1 groupname</li>
</ul>
<h2 id="ACL权限"><a href="#ACL权限" class="headerlink" title="  ACL权限"></a><a name="ch2">  ACL权限</a></h2><p>ACL可以针对单一用户,单一用户组,单个文件进行rwx的权限设置.</p>
<h3 id="启用ACL"><a href="#启用ACL" class="headerlink" title="  启用ACL"></a><a name="ch2.1">  启用ACL</a></h3><p>查看你需要设置的文件对应的文件系统是否启用ACL功能.</p>
<p>首先查看文件系统的挂载情况:mount
比如我要设置的文件在/的文件系统下,其挂载至/dev/sda9,我们用dumpe2fs -h /dev/sda9的超级块的Default mount options情况.</p>
<p>如果没有acl功能,可以在/etc/fstab中options加入acl.这样开机就是启动acl. </p>
<h3 id="设置ACL-setfacl"><a href="#设置ACL-setfacl" class="headerlink" title="  设置ACL:setfacl"></a><a name="ch2.2">  设置ACL:setfacl</a></h3><p>setfacl最常用的参数就是 <code>-m</code>,设置权限列表, 比如 <code>-m u:user1:rx</code>就是针对某目录设置user1可以rx权限
删除acl权限可以使用 <code>-b</code></p>
<p>如果想某目录下所有文件都设置acl权限可以这样设置权限列表 <code>-m d:u:user1:rx</code></p>
<h3 id="查看ACL-getfacl"><a href="#查看ACL-getfacl" class="headerlink" title="  查看ACL:getfacl"></a><a name="ch23">  查看ACL:getfacl</a></h3><p>当我们文件设置setfacl后,ls查看的文件属性中权限字段会有个<code>+</code>,表示设置了acl权限.
如果要详细查看acl信息,使用getfacl</p>
<h2 id="用户身份切换工具"><a href="#用户身份切换工具" class="headerlink" title="  用户身份切换工具"></a><a name="ch3">  用户身份切换工具</a></h2><h3 id="切换用户-su"><a href="#切换用户-su" class="headerlink" title="  切换用户:su"></a><a name="ch3.1">  切换用户:su</a></h3><p>如果单纯使用<code>su username</code>来切换用户,系统会以non-login shell方式去读取用户相关环境变量(只会读取~/.bashrc),如果向使用login shell以完整的流程去读取用户相关的环境变量可以使用 <code>su - username</code></p>
<h3 id="以root身份去执行命令-sudo"><a href="#以root身份去执行命令-sudo" class="headerlink" title="  以root身份去执行命令:sudo"></a><a name="ch3.2">  以root身份去执行命令:sudo</a></h3><p>一般用户想使用sudo,获取root身份去执行一次命令,需要此用户被选中为sudoer(要root在/etc/sudoers设置).
/etc/sudoers文件的格式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># Host alias specification</div><div class="line"></div><div class="line"> # User alias specification</div><div class="line">User_Alias ADMPW = kumho, jinhu  # 设置用户集合</div><div class="line"></div><div class="line"> # Cmnd alias specification</div><div class="line">Cmnd_Alias ADMPWCOM=!/usr/bin/passwd, !/usr/bin/passwd root, /usr/bin passwd [A-Za-z]*  # 设置命令集  命令一定要以绝对路径写</div><div class="line"></div><div class="line"> # User privilege specification</div><div class="line"> root    ALL=(ALL:ALL) ALL  # 用户   登录者的来源主机名=(可切换的身份:用户组) 命令</div><div class="line"> ADMPW   ALL=(ALL:ALL) ADMPWCOM</div><div class="line"></div><div class="line"> # Members of the admin group may gain root privileges</div><div class="line"> %admin ALL=(ALL) ALL     #admin用户组成员都是sudoer</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;用户管理&quot;&gt;&lt;a href=&quot;#用户管理&quot; class=&quot;headerlink&quot; title=&quot;  用户管理&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt;  用户管理&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Linux用户信息保存在&lt;code&gt;/etc/passwd&lt;/code&gt;,用户密
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Shell Script</title>
    <link href="http://yoursite.com/2016/09/06/Linux-Shell-Script/"/>
    <id>http://yoursite.com/2016/09/06/Linux-Shell-Script/</id>
    <published>2016-09-06T05:42:30.000Z</published>
    <updated>2016-09-06T05:46:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Script的执行方式"><a href="#Script的执行方式" class="headerlink" title="  Script的执行方式"></a><a name="ch1">  Script的执行方式</a></h2><p>Script执行方式分为直接执行和source执行</p>
<h3 id="直接执行"><a href="#直接执行" class="headerlink" title="直接执行"></a>直接执行</h3><p>其中直接执行,是启动<b>子进程</b>执行Script,父进程休眠,Script中的操作不影响父进程.</p>
<p>可以分为路径执行,PATH执行与sh执行(sh是/bin/bash的硬连接)</p>
<p>这里说下sh执行,sh可以调试script
使用参数-n 不执行script,仅检查语法
使用参数-x 调试模式,显示执行时的script(变量都被准确赋值)</p>
<h3 id="source执行"><a href="#source执行" class="headerlink" title="source执行"></a>source执行</h3><p>父进程中执行,操作会影响父进程</p>
<h2 id="Shell中的数值运算"><a href="#Shell中的数值运算" class="headerlink" title="  Shell中的数值运算"></a><a name="ch2">  Shell中的数值运算</a></h2><p>我们除了可以使用 <code>declare</code>来定义数值型变量外,也可以直接使用<code>$((运算式))</code>来进执行数值处理,比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x=<span class="string">"10"</span></div><div class="line">y=<span class="string">"4"</span></div><div class="line"><span class="built_in">echo</span> $((<span class="variable">$x</span>%<span class="variable">$y</span>))</div></pre></td></tr></table></figure>
<h2 id="test与判断式"><a href="#test与判断式" class="headerlink" title="  test与判断式"></a><a name="ch3">  test与判断式</a></h2><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>我们可以使用<code>test</code>来查看文件是否存在及其属性,也可进行数值比较与字符串比较(这两个也可以在判断式中比较)
以下是test的一部分参数表</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">判断文件存在与类型</td>
<td style="text-align:center">格式 test -e filename</td>
</tr>
<tr>
<td style="text-align:center">-e</td>
<td style="text-align:center">该文件是否存在</td>
</tr>
<tr>
<td style="text-align:center">-f</td>
<td style="text-align:center">该文件是否存在且为文件</td>
</tr>
<tr>
<td style="text-align:center">-d</td>
<td style="text-align:center">该文件是否存在且为目录</td>
</tr>
<tr>
<td style="text-align:center">-b</td>
<td style="text-align:center">该文件是否存在为块设备</td>
</tr>
<tr>
<td style="text-align:center">判断文件权限</td>
<td style="text-align:center">格式 test -r filename</td>
</tr>
<tr>
<td style="text-align:center">-r</td>
<td style="text-align:center">该文件是否可读</td>
</tr>
<tr>
<td style="text-align:center">-w</td>
<td style="text-align:center">该文件是否可写</td>
</tr>
<tr>
<td style="text-align:center">-x</td>
<td style="text-align:center">该文件是否可执行</td>
</tr>
<tr>
<td style="text-align:center">-u</td>
<td style="text-align:center">是否具有SUID</td>
</tr>
<tr>
<td style="text-align:center">-g</td>
<td style="text-align:center">是否具有SGID</td>
</tr>
<tr>
<td style="text-align:center">-k</td>
<td style="text-align:center">是否具有SBIT</td>
</tr>
<tr>
<td style="text-align:center">比较两数值</td>
<td style="text-align:center">test n1 -eq n2</td>
</tr>
<tr>
<td style="text-align:center">-eq</td>
<td style="text-align:center">==</td>
</tr>
<tr>
<td style="text-align:center">-ne</td>
<td style="text-align:center">!=</td>
</tr>
<tr>
<td style="text-align:center">-gt</td>
<td style="text-align:center">&gt;(greater than)</td>
</tr>
<tr>
<td style="text-align:center">-lt</td>
<td style="text-align:center">&lt;</td>
</tr>
<tr>
<td style="text-align:center">-ge</td>
<td style="text-align:center">&gt;=</td>
</tr>
<tr>
<td style="text-align:center">-le</td>
<td style="text-align:center">&lt;=</td>
</tr>
<tr>
<td style="text-align:center">判断字符串数据</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">test str1=str2</td>
<td style="text-align:center">相等</td>
</tr>
<tr>
<td style="text-align:center">test str1!=str2</td>
<td style="text-align:center">不相等</td>
</tr>
<tr>
<td style="text-align:center">多重条件判定</td>
<td style="text-align:center">逻辑操作</td>
</tr>
<tr>
<td style="text-align:center">-a</td>
<td style="text-align:center">AND : test -e file1 -a test -e file2</td>
</tr>
<tr>
<td style="text-align:center">-o</td>
<td style="text-align:center">OR</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">反向:test ! -e file1</td>
</tr>
</tbody>
</table>
<h3 id="判断式"><a href="#判断式" class="headerlink" title="判断式[]"></a>判断式[]</h3><p>判断式基本格式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x=1</div><div class="line">[□$x□-le□0□]</div></pre></td></tr></table></figure>
注意<code>□</code>为空格,在变量/常量/操作符间一定要有空格</p>
<h2 id="shell-script的默认变量"><a href="#shell-script的默认变量" class="headerlink" title="  shell script的默认变量"></a><a name="ch4">  shell script的默认变量</a></h2><p>当我们执行命令时,会带参数(执行操作,文件参数等)
我们在script中怎么读取这些参数,script内置了变量<code>$#</code>,<code>$@</code>,<code>$num</code>来表示这些参数</p>
<ul>
<li><code>$#</code> 参数个数</li>
<li><code>$@</code> 参数列表</li>
<li><code>$num</code> 其中$0表示script名 $1..$num表示第num个参数</li>
</ul>
<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="  程序结构"></a><a name="ch5">  程序结构</a></h2><h3 id="判断结构"><a href="#判断结构" class="headerlink" title="判断结构"></a>判断结构</h3><h4 id="if结构"><a href="#if结构" class="headerlink" title="if结构"></a>if结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if [ 条件1 ] ; then</div><div class="line">     代码段1</div><div class="line">elif [ 条件2 ] ; then</div><div class="line">    代码段2</div><div class="line">esle </div><div class="line">    代码段3</div><div class="line">fi</div></pre></td></tr></table></figure>
<h4 id="swicth结构"><a href="#swicth结构" class="headerlink" title="swicth结构"></a>swicth结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">case $var in</div><div class="line">       constant1 )</div><div class="line">           代码段1</div><div class="line">         ;;</div><div class="line">       constant2 )</div><div class="line">             代码段2</div><div class="line">          ;;</div><div class="line">         * )</div><div class="line">             代码段 </div><div class="line">          ;;</div><div class="line">esac          </div></pre></td></tr></table></figure>
<p>注意这里的swicth不能跨段,就是<code>constant1</code>后一定有<code>;;</code>  <code>constant</code>可以是通配符,比如<code>[Yy]</code></p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="while-done-满足条件循环"><a href="#while-done-满足条件循环" class="headerlink" title="while..done : 满足条件循环"></a>while..done : 满足条件循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">while [ 条件 ]</div><div class="line">do</div><div class="line">   代码段</div><div class="line">done</div></pre></td></tr></table></figure>
<h4 id="utile…done-满足条件终止循环"><a href="#utile…done-满足条件终止循环" class="headerlink" title="utile…done : 满足条件终止循环"></a>utile…done : 满足条件终止循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">util [ 条件 ]</div><div class="line">do</div><div class="line">   代码段</div><div class="line">done</div></pre></td></tr></table></figure>
<h4 id="for…each-循环遍历"><a href="#for…each-循环遍历" class="headerlink" title="for…each : 循环遍历"></a>for…each : 循环遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for var in con1 con2 con3 ...</div><div class="line">do</div><div class="line">   代码段</div><div class="line">done</div></pre></td></tr></table></figure>
<p>例子
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for filename in $(ls -al .)</div><div class="line">do</div><div class="line">    echo $filename</div><div class="line">done</div></pre></td></tr></table></figure></p>
<h4 id="for…done-条件遍历"><a href="#for…done-条件遍历" class="headerlink" title="for…done : 条件遍历"></a>for…done : 条件遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s=0</div><div class="line">for (( i=1 ; i &lt;= $num ; i++ ))</div><div class="line">do</div><div class="line">    s=$(($s+$i))</div><div class="line">done </div></pre></td></tr></table></figure>
<h2 id="function"><a href="#function" class="headerlink" title="  function"></a><a name="ch6">  function</a></h2><p>function需要写在执行之前,因为script执行顺序是<code>从上到下,从左到右</code>
而且function内置有变量,跟script类似
需要返回值是使用<code>return</code>
例子:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function calnum ()&#123;</div><div class="line">  if [ $1 -le 0 ] ; then</div><div class="line">     return 1</div><div class="line">  fi</div><div class="line">   </div><div class="line">   sum=0</div><div class="line">   for (( i=1 ;  i&lt;=$1 ; i++ ))</div><div class="line">   do</div><div class="line">      sum=$(($sum+$i))</div><div class="line">   done</div><div class="line">   echo $sum</div><div class="line">   return 0</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Script的执行方式&quot;&gt;&lt;a href=&quot;#Script的执行方式&quot; class=&quot;headerlink&quot; title=&quot;  Script的执行方式&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt;  Script的执行方式&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Script执行方式分为
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 正则表达式</title>
    <link href="http://yoursite.com/2016/09/06/Linux-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/09/06/Linux-正则表达式/</id>
    <published>2016-09-06T05:28:47.000Z</published>
    <updated>2016-09-06T05:40:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式-字符的模式"><a href="#正则表达式-字符的模式" class="headerlink" title="正则表达式-字符的模式"></a><a name="ch1">正则表达式-字符的模式</a></h2><h3 id="语系对正则表达式的影响"><a href="#语系对正则表达式的影响" class="headerlink" title="语系对正则表达式的影响"></a><a name="ch1.1">语系对正则表达式的影响</a></h3><p>正则表达式中字符的编码顺序会对正则式匹配的结果造成影响</p>
<p>比如zh_CN和C语系的数字字母编码顺序:</p>
<ul>
<li>LANG=zh_CN :  0 1 2 3 4 … a A b B c C … z Z</li>
<li>LANG=C : 0 1 2 3 4… A B C … Z a b c …z</li>
</ul>
<p>所以我们需要指定编码,通常我们会指定LANG=C  (ASCII码)</p>
<p>为了能规范这种差异,正则表达式中也存在特殊符号来表示一些字符,如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">特殊符号</th>
<th style="text-align:center">代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[:alnum:]</td>
<td style="text-align:center">代表大小写字母和数字,即0-9,A-Z,a-z</td>
</tr>
<tr>
<td style="text-align:center">[:alpha:]</td>
<td style="text-align:center">代表大小写字母,即A-Z,a-z</td>
</tr>
<tr>
<td style="text-align:center">[:blank:]</td>
<td style="text-align:center">空格与[TAB]</td>
</tr>
<tr>
<td style="text-align:center">[:cntrl:]</td>
<td style="text-align:center">键盘上控制键,即CR,LF,TAB,DEL等</td>
</tr>
<tr>
<td style="text-align:center">[:digit:]</td>
<td style="text-align:center">代表数字</td>
</tr>
<tr>
<td style="text-align:center">[:graph:]</td>
<td style="text-align:center">除空格与[TAB]外的其他字符</td>
</tr>
<tr>
<td style="text-align:center">[:lower:]</td>
<td style="text-align:center">小写字母</td>
</tr>
<tr>
<td style="text-align:center">[:upper:]</td>
<td style="text-align:center">大写字母</td>
</tr>
<tr>
<td style="text-align:center">[:print:]</td>
<td style="text-align:center">代表任何可以被打印出来的字符</td>
</tr>
<tr>
<td style="text-align:center">[:space:]</td>
<td style="text-align:center">任何会产生空白的字符,如空格,[TAB],CR等</td>
</tr>
<tr>
<td style="text-align:center">[:punct:]</td>
<td style="text-align:center">代表标点符号,即” ‘ ? ! ; 等</td>
</tr>
<tr>
<td style="text-align:center">[:xdigit:]</td>
<td style="text-align:center">代表十六进制数,即0-9,A-F,a-f</td>
</tr>
</tbody>
</table>
<h3 id="支持正则式的命令"><a href="#支持正则式的命令" class="headerlink" title=" 支持正则式的命令"></a><a name="ch1.2"> 支持正则式的命令</a></h3><h4 id="基础正则式命令-grep"><a href="#基础正则式命令-grep" class="headerlink" title="基础正则式命令: grep"></a>基础正则式命令: grep</h4><p>基础正则式的特殊字符如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">特殊符号</th>
<th style="text-align:center">代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">^word</td>
<td style="text-align:center">待查找字符串word在行首</td>
</tr>
<tr>
<td style="text-align:center">word$</td>
<td style="text-align:center">待查找字符串word在行尾</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">代表一定有一个任意字符</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">转义字符</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">重复零个到无穷个的前一个字符</td>
</tr>
<tr>
<td style="text-align:center">[list]</td>
<td style="text-align:center">匹配list中的任意字符</td>
</tr>
<tr>
<td style="text-align:center">[n1-n2]</td>
<td style="text-align:center">匹配编码从n1-n2的任意字符</td>
</tr>
<tr>
<td style="text-align:center">[^list]</td>
<td style="text-align:center">匹配非list中的任意字符</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td style="text-align:center">重复前一个字符n-m遍</td>
</tr>
</tbody>
</table>
<h4 id="扩展正则式命令-egrep"><a href="#扩展正则式命令-egrep" class="headerlink" title="扩展正则式命令: egrep"></a>扩展正则式命令: egrep</h4><p>egrep与grep一样使用,其支持了更多的特殊字符</p>
<p>扩展正则式的特殊字符如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">特殊符号</th>
<th style="text-align:center">代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">重复一个或一个以上的前一个字符</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">重复零或一个的前一个字符</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>或者</td>
</tr>
<tr>
<td style="text-align:center">()</td>
<td style="text-align:center">匹配组: 如查找glad或good这两个字符,正则式:g(la\</td>
<td>oo)d<br>对比g[la\loo]d 这种正则式没有组合性</td>
</tr>
<tr>
<td style="text-align:center">()+</td>
<td style="text-align:center">重复匹配组</td>
</tr>
</tbody>
</table>
<h4 id="分析stdin并处理筛选命令-sed"><a href="#分析stdin并处理筛选命令-sed" class="headerlink" title="分析stdin并处理筛选命令: sed"></a>分析stdin并处理筛选命令: sed</h4><p>sed工具:分析stdin,并可以对数据进行替换/删除/增加/选取特定行的功能</p>
<p>sed的格式: <code>sed [-nefri] function</code></p>
<p>命令参数:</p>
<ul>
<li><code>n</code> 打印模式</li>
<li><code>e</code> 直接在命令行处理,当进行多个function动作时须要指定</li>
<li><code>i</code> 直接修改文件</li>
<li><code>r</code> 使sed支持扩展正则式(默认支持基础正则式)</li>
<li><code>f</code> 将function写到文件中,读取该文件进行动作</li>
</ul>
<p>function参数:</p>
<ul>
<li><code>a</code> 新增,形如’n1a str’ : 在当前第n1行后增加str行</li>
<li><code>c</code> 替换, 形如’n1,n2c str’,用str替换n1到n2行</li>
<li><code>d</code> 删除, 形如’n1,n2d’,删除n1到n2行,删除n1到最后(n1,$d)</li>
<li><code>i</code>  插入,形如’n1i str’,在当前第n1行前增加str行</li>
<li><code>p</code> 打印,形如’n1,n2p’,打印n1到n2行,须要加-n</li>
<li><code>s</code> 替换,形如’s/str1/str2/g’ 全文搜索,将str2代替str1</li>
</ul>
<h3 id="文件格式化命令"><a href="#文件格式化命令" class="headerlink" title=" 文件格式化命令"></a><a name="ch1.3"> 文件格式化命令</a></h3><h4 id="格式化打印-printf"><a href="#格式化打印-printf" class="headerlink" title="格式化打印:printf"></a>格式化打印:printf</h4><p>printf不是管道命令,其处理的是文本数据,当读取文件时,须先提出文件的内容,如$(cat filename)</p>
<p>printf的基本格式:<code>printf &#39;打印格式&#39; 文本内容</code>
其中打印格式如C语言的printf</p>
<p>比如我要打印如下格式的文本(test.txt),并去掉Name行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Name    Chinese    English   Math    Average</div><div class="line">DmTsai      80         60     70       70</div><div class="line">VBrid        70        60    65        65</div></pre></td></tr></table></figure>
<p>可以使用如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printf &apos;%10s %5d %5d %5d %5.2f&apos; $(cat test.txt|grep -v &apos;Name&apos;)</div></pre></td></tr></table></figure>
<h4 id="字段处理-awk"><a href="#字段处理-awk" class="headerlink" title="字段处理:awk"></a>字段处理:awk</h4><p>awk是管道命令. 其用分隔符(默认是空格或[TAB])将一行分隔成多个字段,并用变量$0,$1,$2…$n来表示整行,第1个字段,第2个字段…第n个字段</p>
<p>awk的基本格式 awk ‘条件1{动作1} 条件2{动作2}… 条件n{动作n}’ filename</p>
<p>awk内置的变量</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量名称</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$n</td>
<td style="text-align:center">n为数字,其中0表示整行,其他表示第n个字段</td>
</tr>
<tr>
<td style="text-align:center">NF</td>
<td style="text-align:center">每一行($0)的字段总数</td>
</tr>
<tr>
<td style="text-align:center">NR</td>
<td style="text-align:center">目前awk处理的当前行号</td>
</tr>
<tr>
<td style="text-align:center">FS</td>
<td style="text-align:center">目前的分隔符,默认是空格,设置分隔符可以 ‘BEGIN {FS=”str”}’</td>
</tr>
</tbody>
</table>
<p>awk的条件逻辑运算符是<code>&gt; &lt; &gt;= &lt;= == !=</code></p>
<p>例子:将1.3.1的例子test.txt添加总分字段’Total’,重新打印处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat test.txt | \</div><div class="line">&gt; awk &apos; NR==1 &#123;printf &quot;%10s  %10s  %10s  %10s  %10s  %10s\n&quot;, $1,$2,$3,$4,$5,&quot;Total&quot;&#125;</div><div class="line">&gt; NR&gt;=2 &#123;total=$2+$3+$4 printf &quot;%10s  %10d %10d %10d %10.2f %10.2f&quot;,$1,$2,$3,$4,$5,total&#125;&apos;</div></pre></td></tr></table></figure>
<h4 id="文件比较及补丁-diff与patch"><a href="#文件比较及补丁-diff与patch" class="headerlink" title="文件比较及补丁:diff与patch"></a>文件比较及补丁:diff与patch</h4><p>当我们比较两个相识(新旧版本)的文本文件时,可以使用diff filename1 filename2
如果是打出补丁文件 <code>diff -Naur filename1 filename2 &gt; filename.patch</code></p>
<p>对文件进行补丁 <code>patch -p0 &lt; filename.patch</code> (新旧文件同目录中)</p>
<p>还原文件 <code>patch -R -p0 &lt; filename.patch</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;正则表达式-字符的模式&quot;&gt;&lt;a href=&quot;#正则表达式-字符的模式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式-字符的模式&quot;&gt;&lt;/a&gt;&lt;a name=&quot;ch1&quot;&gt;正则表达式-字符的模式&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;语系对正则表达式的影响
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
</feed>
