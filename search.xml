<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Linux 服务器篇 防火墙与NAT服务器]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8ENAT%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title=" 前言"></a><a name="ch0"> 前言</a></h2><p>防火墙是整个数据包进入主机前的第一道关卡,那什么是防火墙？防火墙有什么机制？防火墙可以实现与不能实现的功能有哪些？其实Linux防火墙主要通过Netfilter与TCP Wrapper两个机制来管理，通过Netfilter可以实现让<code>Private IP</code>主机上网,也可以让Internet连接到LAN中主机，所以防火墙相当重要</p>
<h2 id="认识防火墙"><a href="#认识防火墙" class="headerlink" title=" 认识防火墙"></a><a name="ch1"> 认识防火墙</a></h2><h3 id="什么是防火墙"><a href="#什么是防火墙" class="headerlink" title=" 什么是防火墙"></a><a name="ch1.1"> 什么是防火墙</a></h3><p>在<a href="https://github.com/HiKumho/blog/issues/39" target="_blank" rel="external">Linux 学习之服务器篇 网络安全与主机基本防护:网络升级/限制端口/SELinux</a>中我们可以知道,数据包进入主机时,会通过防火墙/服务程序/SELinux/文件系统,防火墙作为保护主机的第一道关卡,其主要功能是限制某些服务的数据进出</p>
<p>所以防火墙主要任务是在规划出:</p>
<ul>
<li>切割被信任(LAN)与不被信任(Internet)的网段</li>
<li>划分出可提供Internet的服务与必须受保护的服务</li>
<li>分析出可接受与不可接受的数据包</li>
</ul>
<h3 id="Linux上的防火墙主要类别"><a href="#Linux上的防火墙主要类别" class="headerlink" title=" Linux上的防火墙主要类别"></a><a name="ch1.2"> Linux上的防火墙主要类别</a></h3><p>Linux实现防火墙功能有一些三种形式:</p>
<ul>
<li><code>Netfilter</code> 其通过分析数据包表头信息来限制其访问与处理一些动作(比如转换来源/目标的IP地址或端口信息),主要分析OSI的第二/三/四层</li>
<li><code>TCP Wrapper</code> 控管程序对于数据包的处理OR丢弃,主要以程序名来限制数据包</li>
<li><code>Proxy</code> 通过代理服务器,中转我们主机的数据包,同时起到保护主机的作用</li>
</ul>
<h3 id="Netfilter防火墙的使用限制"><a href="#Netfilter防火墙的使用限制" class="headerlink" title=" Netfilter防火墙的使用限制"></a><a name="ch1.3"> Netfilter防火墙的使用限制</a></h3><p>前面提到Netfilter防火墙主要是分析数据包表头信息,其进行的分析工作主要有:</p>
<ul>
<li>拒绝让Internet的数据包进入主机某些端口</li>
<li>拒绝让某些来源IP的数据包进入</li>
<li>拒绝让带有某些特殊flags的数据包进入</li>
<li>分析主机MAC地址,决定是否连线</li>
</ul>
<p>只不过即使有防火墙的限制,可是也不能说我们主机安全,比如我们向Internet开放WWW服务,由于要允许Internet上主机都可以连接我们主机的80端口,所以这些数据包要通过防火墙,达到服务进程处,这些数据包要是携带病毒,防火墙也是没办法处理的</p>
<h2 id="TCP-Wrappers"><a href="#TCP-Wrappers" class="headerlink" title=" TCP Wrappers"></a><a name="ch2"> TCP Wrappers</a></h2><p>TCP Wrappers是通过客服端想要连接的程序名,然后分析客服端的IP,来决定是否放行的</p>
<p>其通过配置文件<code>/etc/hosts.{allow|deny}</code>来管理</p>
<h3 id="哪些服务支持TCP-Wrappers"><a href="#哪些服务支持TCP-Wrappers" class="headerlink" title=" 哪些服务支持TCP Wrappers"></a><a name="ch2.1"> 哪些服务支持TCP Wrappers</a></h3><p>支持<code>TCP Wrappers</code>服务分为两类,分别是：</p>
<ul>
<li>由<code>super damon(xinted)</code>所管理的服务</li>
<li>有支援<code>libwrap.so</code>函数库的服务(可通过<code>ldd</code>来查看)</li>
</ul>
<h3 id="TCP-Wrappers配置文件"><a href="#TCP-Wrappers配置文件" class="headerlink" title=" TCP Wrappers配置文件"></a><a name="ch2.2"> TCP Wrappers配置文件</a></h3><p><code>TCP Wrappers</code>的配置文件<code>/etc/hosts.{allow|deny}</code>，其语法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;service(program name)&gt;:&lt;ip/domain/hostname&gt;:action</div></pre></td></tr></table></figure>
<p>其中<code>hosts.allow</code>设置程序放行的ip,而<code>hosts.deny</code>则相反,优先级上,<code>hosts.allow</code>高于<code>hosts.deny</code>
当两个文件都不存在时,Linux默认以放行来处理</p>
<h2 id="Netfilter"><a href="#Netfilter" class="headerlink" title=" Netfilter"></a><a name="ch3"> Netfilter</a></h2><p>Linux实现Netfilter功能(数据包过滤)的软件是<code>iptables</code>,其内核所提供，在效能上非常好</p>
<h3 id="数据包进入的流程-规则顺序的重要"><a href="#数据包进入的流程-规则顺序的重要" class="headerlink" title=" 数据包进入的流程:规则顺序的重要"></a><a name="ch3.1"> 数据包进入的流程:规则顺序的重要</a></h3><p>Netfilter防火墙是通过设定一条条<b>规则</b>来过滤数据包的,而这些规则在匹配数据包上有顺序(由上到下识别),匹配成功后就执行相应的<code>action</code>,不再往下匹配</p>
<p>如果都不匹配,那等着此数据包的就是<code>Poliey</code>(预设动作)了</p>
<p>比如下图,当一个数据包匹配<code>rule 01</code>,就满足,执行其action – [DROP],那么该数据包就会被主机给丢弃
<img src="http://ocz7ifqwi.bkt.clouddn.com/netfilter_rules.png" alt=""></p>
<h3 id="iptables的表格-table-与链-chain"><a href="#iptables的表格-table-与链-chain" class="headerlink" title=" iptables的表格(table)与链(chain)"></a><a name="ch3.2"> iptables的表格(table)与链(chain)</a></h3><p>由于防火墙有很多条规则,为了方便则是某类动作,我们将一组规则整合成<code>chain(链)</code>,比如处理进入的数据包的规则组称为<code>INPUT</code>,处理发出的数据包的规则组称为<code>OUTPUT</code>,</p>
<p>而再将这些链组合在一起,专门针对某些功能,那就是<code>table</code>了</p>
<p>iptables预设有以下三个<code>table</code>,如下图</p>
<p><img src="http://ocz7ifqwi.bkt.clouddn.com/netfilter_iptables.png" alt=""></p>
<p>各表相关的功能如下</p>
<ul>
<li><code>filter</code>  主要跟进出主机的数据包有关,预设table为filter<ul>
<li><code>INPUT</code>  主要跟进入主机的数据包有关</li>
<li><code>FORWARD</code>  主要跟转递数据包有关,与<code>nat table</code>相性高</li>
<li><code>OUTPUT</code>  主要跟主机发出的数据包有关</li>
</ul>
</li>
<li><code>nat</code> 主要对数据包中目标/来源的IP与port进行修改<ul>
<li><code>PREROUTING</code>  在路由判断前进行的规则,主要修改目标IP/port</li>
<li><code>POSTROUTING</code> 在路由判断后进行的规则,主要修改来源IP/port</li>
<li><code>OUTPUT</code> 与发出的数据包有关</li>
</ul>
</li>
<li><code>mangle</code> 主要与数据包的flags有关</li>
</ul>
<p>当数据包在防火墙规则匹配过程中,各表与链的相关性如下图</p>
<p><img src="http://ocz7ifqwi.bkt.clouddn.com/netfilter_iptables_relate.gif" alt=""></p>
<p>虽然上图很复杂,但我们可以看出iptables控制的三种数据包的流向:</p>
<ul>
<li>数据包进入Linux主机–使用路线A</li>
<li>数据包由Linux主机转递–使用路线B</li>
<li>数据包由Linux主机发出–使用路线C</li>
</ul>
<h3 id="iptables的语法"><a href="#iptables的语法" class="headerlink" title=" iptables的语法"></a><a name="ch3.3"> iptables的语法</a></h3><h4 id="规则的查看与清除"><a href="#规则的查看与清除" class="headerlink" title="规则的查看与清除"></a>规则的查看与清除</h4><ul>
<li>查看规则  : <code>iptables-save [-t table]</code></li>
<li>清除规则  : <ul>
<li><code>iptables -F</code>  清除所有的已制定的规则</li>
<li><code>iptables -X</code>  清除所有使用者制定的chain</li>
<li><code>iptables -Z</code>  所有chain的计数与流量统计都归0</li>
<li><code>iptables -F INPUT</code> 清空 filter表INPUT所有规则  </li>
<li><code>iptables -D INPUT 3</code>  删除input的第3条规则  </li>
</ul>
</li>
</ul>
<h4 id="设置预设政策"><a href="#设置预设政策" class="headerlink" title="设置预设政策"></a>设置预设政策</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables [-t tables] -P [INPUT,OUTPUT,FORWARD等] [ACCEPT,DROP]</div></pre></td></tr></table></figure>
<h4 id="添加规则：限制IP-network-网络接口"><a href="#添加规则：限制IP-network-网络接口" class="headerlink" title="添加规则：限制IP/network/网络接口"></a>添加规则：限制IP/network/网络接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># iptables [-AI 链名] [-io 网络接口] [-p 协议] \</div><div class="line">&gt; [-s 來源IP/网域] [-d 目标IP/网域] -j [ACCEPT|DROP|REJECT|LOG]</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>AI 链名</code>  针对某条链进行规则的 “插入” 或 “累加”<ul>
<li><code>A</code> 在链的尾部增加一条规则</li>
<li><code>I</code> 在链的头部插入一条规则,成为第一条规则</li>
</ul>
</li>
<li><code>io 网络接口</code>：设置数据包进出的网络接口<ul>
<li><code>i</code>  数据包所进入的接口,如<code>INPUT</code>链搭配</li>
<li><code>o</code> 数据包所出去的接口,如<code>OUTPUT</code>链搭配</li>
</ul>
</li>
<li><code>p 协议</code>：设置此规则适用的数据包格式<ul>
<li>如<code>tcp/udp/icmp等</code></li>
</ul>
</li>
<li><code>s 来源 IP/网域</code>：设定此规则的数据包來源,可指定 IP或网域，例如：    <ul>
<li>IP  ：192.168.0.100      <ul>
<li>网域：192.168.0.0/24, 192.168.0.0/255.255.255.0 均可。     </li>
<li>若规定为[不许]时,加上 ! 即可，例如：     </li>
<li>-s ! 192.168.100.0/24 表示不许192.168.100.0/24 的数据包来源；</li>
</ul>
</li>
</ul>
</li>
<li><code>d 目标IP/网域</code> ： 设置此规则的数据包目标</li>
<li><code>j</code> ：后接动作，主要的动作有接受(ACCEPT)、丢弃(DROP)、拒绝(REJECT)及记录(LOG)</li>
</ul>
<h4 id="添加规则：限制端口"><a href="#添加规则：限制端口" class="headerlink" title="添加规则：限制端口"></a>添加规则：限制端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> iptables [-AI 链] [-io 网络接口] [-p tcp,udp] \</div><div class="line">&gt; [-s 來源IP/网域] [--sport 端口范围] \</div><div class="line">&gt; [-d 目标IP/网域] [--dport 端口范围] -j [ACCEPT|DROP|REJECT]</div></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><code>--sport 端口范围</code>：限制來源的端口，端口可以是连续的，例如 1024:65535</li>
<li><code>--dport 端口范围</code>：限制目标的端口</li>
</ul>
<h4 id="添加规则：匹配mac与state"><a href="#添加规则：匹配mac与state" class="headerlink" title="添加规则：匹配mac与state"></a>添加规则：匹配mac与state</h4><p>匹配数据包的mac地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -A INPUT [-m mac] [--mac-source mac地址 ] -j action</div></pre></td></tr></table></figure>
<p>匹配数据包的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -A INPUT [-m state] [--state 状态] -j action</div></pre></td></tr></table></figure>
<p>数据包的状态有：</p>
<ul>
<li><code>INVALID</code>  无效的数据包,例如资料破损的数据包</li>
<li><code>ESTABLISHED</code> 已经连线成功的连续状态</li>
<li><code>NEW</code> 想要新建立连线的数据包状态</li>
<li><code>RELATED</code> 表示这个数据包是与我们主机发出去的数据包有关</li>
</ul>
<h4 id="添加规则：限制ICMP包的类型"><a href="#添加规则：限制ICMP包的类型" class="headerlink" title="添加规则：限制ICMP包的类型"></a>添加规则：限制ICMP包的类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -A INPUT [-p icmp] [--icmp-type 类型] -j action</div></pre></td></tr></table></figure>
<p>类型是icmp包的类型,比如<code>8</code> 是<code>echo request</code>,用于<code>ping</code>连接</p>
<h4 id="IPv4的内核功能：-prov-sys-net-ipv4"><a href="#IPv4的内核功能：-prov-sys-net-ipv4" class="headerlink" title="IPv4的内核功能：/prov/sys/net/ipv4/*"></a>IPv4的内核功能：/prov/sys/net/ipv4/*</h4><p>内核也一些功能,来处理网络状态：</p>
<ul>
<li><code>/proc/sys/net/ipv4/tcp_syncookies</code> 抵制基于SYN Flooding的DOS攻击</li>
<li><code>/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</code> 抵制基于Ping Flooding的DOS攻击</li>
<li><code>/proc/sys/net/ipv4/conf/*/rp_filter</code>  逆向路径过滤,抵挡一些不合理的数据包 </li>
<li><code>/proc/sys/net/ipv4/conf/*/log_martians</code> 记录不合法的IP来源</li>
</ul>
<h4 id="简单的防火墙规则"><a href="#简单的防火墙规则" class="headerlink" title="简单的防火墙规则"></a>简单的防火墙规则</h4><p>通常一些简单的防火墙规则有以下：</p>
<ul>
<li><code>规则归0</code>： 清除所有已经存在的规则</li>
<li><code>预设政策</code>： 除了INPUT链预设为DROP,其他预设为ACCEPT</li>
<li><code>信任本机</code>： 开放lo接口</li>
<li><code>回应数据包</code> ： 让主机主动向外要求而回应的数据包可以进入本机（ESTABLISHED,RELATED）</li>
<li><code>信任用户</code> ： 非必要，可以让LAN的来源可访问主机资源</li>
</ul>
<p>可以参考
<a href="https://github.com/HiKumho/shell_script_rep/blob/master/iptableRule.sh" target="_blank" rel="external">iptableRule.sh:设置防火墙规则,面向一般服务器</a></p>
<h2 id="NAT服务器的设置"><a href="#NAT服务器的设置" class="headerlink" title=" NAT服务器的设置"></a><a name="ch4"> NAT服务器的设置</a></h2><p>NAT服务在于修改数据包的来源/目标的Socket Pair,其关注的是nat表的PREROUTING链(修改目标的Socket Pair)与POSTROUTING(修改来源的Socket Pair)</p>
<h3 id="SNAT-DNAT以及设置方法"><a href="#SNAT-DNAT以及设置方法" class="headerlink" title=" SNAT/DNAT以及设置方法"></a><a name="ch4.1"> SNAT/DNAT以及设置方法</a></h3><h4 id="SNAT：修改数据包的来源Socket-Pair"><a href="#SNAT：修改数据包的来源Socket-Pair" class="headerlink" title="SNAT：修改数据包的来源Socket Pair"></a>SNAT：修改数据包的来源Socket Pair</h4><p><img src="http://ocz7ifqwi.bkt.clouddn.com/snat.png" alt=""></p>
<p>如上图所示,SNAT通常用于让LAN的主机通过服务器的Public IP连上Internet</p>
<p>设置方法：<code>iptables -t nat -A POSTROUTING -s $innet -o $EXTIF -j MASQUERADE</code></p>
<ul>
<li><code>$innet</code> 是LAN的network,如<code>192.168.100.0/24</code> </li>
<li><code>$EXTIF</code> 是对外的网络接口,如eth0</li>
<li><code>MASQUERADE</code>  让IP伪装成数据包出去(-o)的网络接口上的IP</li>
</ul>
<p>或者设置成,经由eth0出去的数据包,将它们的来源IP改成 192.168.1.210-192.168.1.220
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 192.168.1.210-192.168.1.220</div></pre></td></tr></table></figure></p>
<h4 id="DNAT：修改数据包的目标Socket-Pair"><a href="#DNAT：修改数据包的目标Socket-Pair" class="headerlink" title="DNAT：修改数据包的目标Socket Pair"></a>DNAT：修改数据包的目标Socket Pair</h4><p><img src="http://ocz7ifqwi.bkt.clouddn.com/dnat.png" alt=""></p>
<p>如上图所示,DNAT通过用于Internet主机访问LAN中的主机</p>
<p>设置方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 \</div><div class="line">     -j DNAT --to-destination 192.168.100.10:80 </div></pre></td></tr></table></figure>
<p>将从eth0进入且目标端口是80的数据包，都转移到192.168.100.10:80上</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 服务器篇 路由概念与路由协议]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87-%E8%B7%AF%E7%94%B1%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h2 id="路由"><a href="#路由" class="headerlink" title=" 路由"></a><a name="ch1"> 路由</a></h2><p>路由是规划我们数据包在网络上的传输路径以及方式</p>
<h3 id="路由表产生的类型"><a href="#路由表产生的类型" class="headerlink" title=" 路由表产生的类型"></a><a name="ch1.1"> 路由表产生的类型</a></h3><p>我们每台主机都有自己的路由表,我们可以使用<code>route</code>来查看,那设置路由表有以下方式：</p>
<ul>
<li>直接设置网络接口的路由配置文件<ul>
<li><code>/etc/network/interfaces(Ubuntu)</code>或<code>/etc/sysconfig/network-scripts/route-eth0(CentOS)</code></li>
</ul>
</li>
<li>手动或预设路由<ul>
<li>通过<code>route</code>来设置</li>
<li>预设路由指的是网段的网关IP</li>
</ul>
</li>
<li>动态路由的学习<ul>
<li>通过让路由器间自主学习动态更新路由表</li>
</ul>
</li>
</ul>
<h3 id="网卡虚拟网络接口-IP-Alias的测试用途"><a href="#网卡虚拟网络接口-IP-Alias的测试用途" class="headerlink" title=" 网卡虚拟网络接口:IP Alias的测试用途"></a><a name="ch1.2"> 网卡虚拟网络接口:IP Alias的测试用途</a></h3><p>让一个网卡虚拟出多个网络接口,其形式如<code>eth0:0</code>,这可以供我们设置IP参数,方便我们测试
但要注意的是实体网卡需要启动,虚拟出来网络接口才能使用</p>
<p>同样的,我们也可以通过建议其配置文件来开机启动该网络接口,比如<code>/etc/sysconfig/network-scripts/ifcfg-eth0:0</code></p>
<h3 id="重复路由的问题"><a href="#重复路由的问题" class="headerlink" title=" 重复路由的问题"></a><a name="ch1.3"> 重复路由的问题</a></h3><p>这里有个问题,就是如果我用两张网卡都设置成同一个目标网域的路由,比如像下面
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Destination     Gateway   Genmask         Flags Metric Ref   Use Iface</div><div class="line">192.168.0.0     0.0.0.0   255.255.255.0   U     0      0       0 eth1</div><div class="line">192.168.0.0     0.0.0.0   255.255.255.0   U     0      0       0 eth0</div></pre></td></tr></table></figure></p>
<p>会出现什么问题?</p>
<p>嘿嘿,我们知道数据包查看路由表是由上到下进行的,所以说数据包如果要传送到192.168.0.0/24这个网段的数据包,其实都是通过eth1,eth0没作用</p>
<h2 id="路由器架设"><a href="#路由器架设" class="headerlink" title=" 路由器架设"></a><a name="ch2"> 路由器架设</a></h2><p>我们知道,同一个网段内主机可以通过广播来传递数据包,而不同网段内数据包的传递就需要通过路由器来转交了</p>
<h3 id="什么是路由器与IP分享器"><a href="#什么是路由器与IP分享器" class="headerlink" title=" 什么是路由器与IP分享器"></a><a name="ch2.1"> 什么是路由器与IP分享器</a></h3><h4 id="什么是路由器"><a href="#什么是路由器" class="headerlink" title="什么是路由器?"></a><a name="ch2.1.1"><b>什么是路由器?</b></a></h4><p>上面我们了解到,路由器主要是<code>转递数据包</code>,它通过分享数据包IP表头,获取目标IP,通过其本身的路由表来转递,所以路由器要有两个网络接口以上.</p>
<p>要达成路由器功能,有以下两种方式:</p>
<ul>
<li><code>硬件功能</code> 比如TP-Link等厂商生产的硬件路由器,其内嵌嵌入式操作系统,负责不同网段间的数据包转递与IP转译</li>
<li><code>软件功能</code> 比如使用Linux的内核功能就能提供上面的功能了</li>
</ul>
<p><b>Linux要作为路由器</b>,首先需要启动其数据包转递的功能(<code>IP forward</code>),启动方式有以下两种</p>
<ul>
<li>直接修改内存中的内核功能参数 <code>/proc/sys/net/ipv4/ip_forward</code> (1`为启动 0非)</li>
<li>修改内核功能配置文件 <code>/etc/sysctl.conf</code>中<code>net.ipv4.ip_forward=1</code> 之后让其立即生效 <code>sysctl -p</code></li>
</ul>
<p>然后就是修改Linux路由器的路由表了,同样分为两种方式</p>
<ul>
<li>静态路由<br>通过直接设置路由配置文件或使用route来修改路由表,缺点就是对应大型网络的架设较困难,而且不易变更</li>
<li>动态路由<br>通过使用<code>Quagga</code>或<code>zebra</code>来侦测网域的变化,让路由器自主更改路由表</li>
</ul>
<h4 id="什么是IP分享器"><a href="#什么是IP分享器" class="headerlink" title="什么是IP分享器?"></a><a name="ch2.1.2"><b>什么是IP分享器?</b></a></h4><p>其实IP分享器本身就是一个路由器,在<code>数据包转递</code>这个功能上加入了<code>IP转译</code>,这也就是NAT服务器</p>
<p><code>IP转译</code> 通过修改数据包IP表头的来源或目标IP,可以让内部的私有IP转译成公共IP,连接上Internet</p>
<p>所以说NAT服务器可以沟通内部网段与公共网域</p>
<h4 id="何时需要路由器"><a href="#何时需要路由器" class="headerlink" title="何时需要路由器"></a><a name="ch2.1.3"><b>何时需要路由器</b></a></h4><p>通常需要架设路由器,都是拥有数百台主机的大型企业内部,通常会这么考虑</p>
<ul>
<li>布线与效能考量<ul>
<li>路由器可以分隔网段,所以数据传播更有效(不可能,让随便一台主机发个包就广播给数百台主机的吧)</li>
</ul>
</li>
<li>部门独立与保护资料的考量<ul>
<li>路由器因为可以分隔网段,所以也可以在路由器里加设防火墙,隔断一些数据包</li>
</ul>
</li>
</ul>
<h3 id="静态路由架设"><a href="#静态路由架设" class="headerlink" title=" 静态路由架设"></a><a name="ch2.2"> 静态路由架设</a></h3><p>前面我们提到,静态路由就是我们手工设置路由表,这有以下步骤:</p>
<ol>
<li>规划网段以及路由<ul>
<li>规划好网段以及相应路由/主机等</li>
<li><b>注意:网络传输是双向的,所以路由传递数据包也要双向</b></li>
<li>比如,<code>192.168.1.0</code>这个网段的数据包,route B会传给route A</li>
<li>而<code>192.168.100.0</code>由route A 也传给route B</li>
<li>总之多考虑下</li>
</ul>
</li>
<li>设置各主机/路由的IP参数以及路由表<ul>
<li>IP参数直接修改网络接口配置文件</li>
<li>路由表也修改配置文件</li>
<li>主机们就将默认网关设到其直接到达的路由器上</li>
<li>路由器要设置2个以上的网络接口</li>
</ul>
</li>
<li>路由器启动<code>数据包转递</code>功能<ul>
<li>修改<code>/etc/sysctl.conf</code>配置文件,具体查看上<a href="#ch2.1">2.1部分</a></li>
<li><code>sysctl -p</code>重新加载内核参数</li>
</ul>
</li>
<li>重启网络服务,并进行测试连通性<ul>
<li><code>service network restart</code> 重启网络服务</li>
<li>通过<code>ping</code>来测试各主机的连通</li>
</ul>
</li>
</ol>
<p>具体例子,请查看<a href="http://linux.vbird.org/linux_server/0230router.php#route_static" target="_blank" rel="external">鸟哥私房菜的静态路由部分</a></p>
<h3 id="动态路由架设-quagga-zebar-ripd"><a href="#动态路由架设-quagga-zebar-ripd" class="headerlink" title=" 动态路由架设:quagga(zebar+ripd)"></a><a name="ch2.3"> 动态路由架设:quagga(zebar+ripd)</a></h3><p>静态路由设置上较麻烦,而且需要重新规划时十分痛苦,聪明的人类想到让路由器自己学习路由表的方法(算法),然后就有了动态路由</p>
<p>动态路由架设过程:</p>
<h4 id="路由器们要安装quagga软件包"><a href="#路由器们要安装quagga软件包" class="headerlink" title="路由器们要安装quagga软件包"></a>路由器们要安装quagga软件包</h4><ul>
<li><code>quagga</code> 提供了很多动态路由协议,比如<code>RIPv2/OSPF/BGP</code>等,这些协议放置在<code>/etc/quagga/</code>下</li>
<li><code>zebra</code> quagga提供的软件,其为daemon,用于更新主机的路由表(插入/删除路由规则)</li>
<li><code>ripd</code> quagga提供的软件,其为daemon,用于向附近的路由器交流路由规则与传送</li>
</ul>
<h4 id="设置所有主机-路由器的网络参数"><a href="#设置所有主机-路由器的网络参数" class="headerlink" title="设置所有主机/路由器的网络参数"></a>设置所有主机/路由器的网络参数</h4><p>这个没得说的,注意路由器要启动<code>数据包转递</code></p>
<h4 id="路由器们设置zebra"><a href="#路由器们设置zebra" class="headerlink" title="路由器们设置zebra"></a>路由器们设置zebra</h4><p>修改路由器上的zebra配置文件<code>/etc/quagga/zebra.conf</code>,比如下面
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hostname www.centos.vbird           &lt;==给予这路由器一个主机名称，随便取！</div><div class="line">password linuxz1                    &lt;==给予一个密码！</div><div class="line">enable password linuxz1             &lt;==将这个密码生效！</div><div class="line">log file /var/log/quagga/zebra.log  &lt;==保存zebar的信息至日志文件</div></pre></td></tr></table></figure>
之后重启zebra以及设置开机启动zebra</p>
<p>最后就可以<code>netstat -ntulp | grep zebra</code>查看zebra端口,通过<code>telnet</code>连接测试</p>
<p><b>注意：zebra也可以设置/查看路由表,通过telnet连接上服务即可进行</b></p>
<h4 id="路由器们设置ripd"><a href="#路由器们设置ripd" class="headerlink" title="路由器们设置ripd"></a>路由器们设置ripd</h4><p>首先还是要修改ripd配置文件<code>/etc/quagga/ripd.conf</code>,如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">hostname www.centos.vbird           &lt;==这里设置router主机名</div><div class="line">password linuxz1                    &lt;==设置好密码</div><div class="line">debug rip events                    &lt;==可以记录较多的错误信息</div><div class="line">debug rip packet                    &lt;==通过信息来解决问题</div><div class="line">router rip                          &lt;==启动router 的 rip 功能</div><div class="line"> version 2                          &lt;==启动RIPv2 的服务 (预设值)</div><div class="line"> network 192.168.1.0/24             &lt;==路由器所管理的两个接口</div><div class="line"> network 192.168.100.0/24</div><div class="line">interface eth0                      &lt;==针对对外接口设置略过身份验证的方式</div><div class="line"> no ip rip authentication mode      &lt;==不要验证身份！</div><div class="line">log file /var/log/quagga/zebra.log  &lt;==记录日志信息</div></pre></td></tr></table></figure></p>
<p>之后重启guagga以及设置开机启动guagga</p>
<p>最后就是查看路由表啦！！！ <code>route</code>或者连接上<code>zebra</code></p>
<h3 id="路由器连接同个网段：ARP-Proxy"><a href="#路由器连接同个网段：ARP-Proxy" class="headerlink" title=" 路由器连接同个网段：ARP Proxy"></a><a name="ch2.4"> 路由器连接同个网段：ARP Proxy</a></h3><p>如果我们要强行对同一个网段的主机进行划分出子网(在不改动IP参数等前提下),我们应该怎么做？
我们知道路由器是可以沟通不同网段上的主机,如果让它来分隔同个网段的主机要怎么做？</p>
<p>这就是<code>ARP Proxy</code>,我对其的理解是:</p>
<ul>
<li>让路由器的网卡MAC伪装成某些主机的MAC,让路由器强行接收发给主机们的数据包(比如路由器上有条规则：<code>对与192.168.1.1</code>主机的数据包都发到我eth0上吧,我会处理的)</li>
<li>然后再通过路由器的<code>数据包转递</code>给主机</li>
</ul>
<p>我们可以通过<code>arp</code>与<code>route</code>实现,具体请看<a href="http://linux.vbird.org/linux_server/0230router.php#arp_proxy" target="_blank" rel="external">鸟哥关于ARP Proxy部分</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 服务器篇 网络安全与主机基本防护:网络升级/限制端口/SELinux]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%9F%BA%E6%9C%AC%E9%98%B2%E6%8A%A4-%E7%BD%91%E7%BB%9C%E5%8D%87%E7%BA%A7-%E9%99%90%E5%88%B6%E7%AB%AF%E5%8F%A3-SELinux/</url>
      <content type="html"><![CDATA[<h2 id="网络数据包连线进入主机的过程"><a href="#网络数据包连线进入主机的过程" class="headerlink" title=" 网络数据包连线进入主机的过程"></a><a name="ch1"> 网络数据包连线进入主机的过程</a></h2><p>当网络上一个连线要求进入我们主机获取资源时,这个数据包进入主机整个流程是怎样的?</p>
<h3 id="数据包进入主机的过程"><a href="#数据包进入主机的过程" class="headerlink" title=" 数据包进入主机的过程"></a><a name="ch1.1"> 数据包进入主机的过程</a></h3><p>网络数据包传输是双向的,当数据包进入主机时会被一层层防护筛选,最后才能获取到主机中的资源,下图是数据包进入主机的流程
<img src="https://raw.githubusercontent.com/HiKumho/blog/a5a3591061509bfda8cf412b71b4806d958343d6/img/blog_39_1.gif" alt=""></p>
<ol>
<li>经过防火墙的分析:linux内建两个防火墙机制:<code>netfilter</code>与<code>TCP wrappers</code><ul>
<li>数据包过滤防火墙:NetFilter 由<code>iptables</code>这个组件提供,对TCP/IP包表头信息进行过滤,主要对象是MAC/IP/ICMP/TCP/UDP数据包</li>
<li>TCP wrapper:数据包经过NetFilter后由Super daemons及TCP wrapper检验,主要是抵挡IP或端口,并进报告,<code>/etc/hosts.allow</code>与<code>hosts.deny</code>中设置</li>
</ul>
</li>
<li>服务的基本功能:服务进程同样可以过滤掉某些数据包,比如httpd.conf规范了一些IP不能访问资源,如果服务程序有漏洞,也是很重大的一件事</li>
<li>SElinux对服务进程的权限控制:限制了服务进程能取得资源的范围,即使是root也要遵守规则</li>
<li>文件系统的基本权限控制:能否读取到数据,最后还是由文件系统的基本权限来控制的</li>
</ol>
<h3 id="网络常见攻击手段及保护措施"><a href="#网络常见攻击手段及保护措施" class="headerlink" title=" 网络常见攻击手段及保护措施"></a><a name="ch1.2"> 网络常见攻击手段及保护措施</a></h3><ul>
<li>取得用户账号信息后猜密码<ul>
<li>知道你的主机名,获取到用户账号,通过nmap来扫描主机的服务端口,就可以猜密码</li>
<li>保护措施<ul>
<li>减少信息曝光</li>
<li>建立严格的密码设定规划：比如<code>/etc/shadow</code> <code>/etc/login.defs</code>中设置密码须变更的时间</li>
<li>完善的权限设置</li>
</ul>
</li>
</ul>
</li>
<li>利用系统的程序漏洞主动攻击<ul>
<li>利用我们系统上开启的服务程序漏洞来进行攻击</li>
<li>保护措施<ul>
<li>关闭不需要的网络服务</li>
<li>随时保持更新软件</li>
<li>关闭不需要的软件</li>
</ul>
</li>
</ul>
</li>
<li>利用社交工程欺骗<pre><code>-  一些钓鱼信息等等
-  保护措施
    -  不要随意透露账号/密码等信息
    -  追踪对方
</code></pre></li>
<li>恶意网站<pre><code>- 保护措施
   -  随时更新软件
   -  最小化软件功能
   -  不连接到不明的主机
</code></pre></li>
<li>蠕虫/木马的rootkit<ul>
<li>rootkit是指取得root权限的一群工具组,rootkit主要也是通过程序漏洞来实现的</li>
<li>蠕虫：让你的主机一直发送数据包对外攻击，网络频宽被吃光</li>
<li>木马：让你主机开启后门(开一个port来黑客主动入侵)</li>
<li>保护措施<pre><code>-   定时用rkhunter来追查
-   不下载来路不明的软件/资料
-   减少危险指令的使用,比如SUID/SGID等
</code></pre></li>
</ul>
</li>
<li>DDoS攻击<ul>
<li>分散式阻断服务功能,通过绑架各地的僵尸主机来进行DDos</li>
<li>让僵尸主机不断发送请求(同步连线)至目标服务器</li>
<li>不理会服务器回应,持续发送请求,耗掉服务资源,使其不能提供正常服务</li>
</ul>
</li>
</ul>
<h3 id="主机保护：软件更新-减少网络服务-启动SElinux"><a href="#主机保护：软件更新-减少网络服务-启动SElinux" class="headerlink" title=" 主机保护：软件更新/减少网络服务/启动SElinux"></a><a name="ch1.3"> 主机保护：软件更新/减少网络服务/启动SElinux</a></h3><p>主机保护有以下几个方向:</p>
<ul>
<li>建立完善的用户密码规则</li>
<li>完善的主机权限设置(SElinux与文件系统权限)</li>
<li>设定自动升级与修补软件漏洞,移出软件(软件方面)</li>
<li>强化服务程序的安全设定</li>
<li>利用<code>iptables</code>/<code>tcp wrappers</code>强化网络防火墙</li>
<li>利用日志文件分析主机状态(<code>logwatch</code>)</li>
</ul>
<p>后面部分也会谈到软件更新/减少网络服务(限制端口)等操作,有关SElinux部分请看<a href="https://github.com/HiKumho/blog/issues/27#ch4" target="_blank" rel="external">Linux 学习之程序管理与SELinux</a></p>
<h2 id="网络自动更新软件"><a href="#网络自动更新软件" class="headerlink" title=" 网络自动更新软件"></a><a name="ch2"> 网络自动更新软件</a></h2><h3 id="如何进行软件更新"><a href="#如何进行软件更新" class="headerlink" title=" 如何进行软件更新"></a><a name="ch2.1"> 如何进行软件更新</a></h3><p>通常我们都是通过线上自动升级机制的<code>yum/apt/you/urpmi</code>来更新软件的,它们基于自家的包管理器(如rpm/dpkg)</p>
<p>如果我们以tarball方式安装的软件,要进行升级,就只能自己到相关官网上下载更新的tarball,再次编译安装了</p>
<h3 id="yum软件更新-镜像网站使用的原理"><a href="#yum软件更新-镜像网站使用的原理" class="headerlink" title=" yum软件更新/镜像网站使用的原理"></a><a name="ch2.2"> yum软件更新/镜像网站使用的原理</a></h3><p><code>yum</code>基于RPM软件包管理,<code>yum</code>会连线yum服务器上下载RPM软件清单(记录了各软件的相关信息与依赖关系),通过RPM软件界清单,直接下载我们需要的软件以及前驱软件</p>
<p>yum更新软件流程如下图
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_39_2.gif?raw=true" alt=""></p>
<ol>
<li>由yum配置文件(<code>/etc/yum.rrepos.d/*.repo</code>)判断yum服务器IP地址<ul>
<li>yum服务器可以是官网,或者一些镜像网站(对官网网站内容的拷贝,减轻官网的负担)</li>
<li>比如CentOS镜像列表:<a href="https://www.centos.org/download/mirrors/" target="_blank" rel="external">CentOS Mirror List</a></li>
</ul>
</li>
<li>连接到yum服务器后,先下载新的RPM软件清单</li>
<li>分析比较欲安装/升级的软件包,并提供用户确认</li>
<li>下载软件包到/var/cache/yum中,并进行实际安装</li>
<li>安装完毕,删除下载的软件包, 可以用<code>yum clean</code>手动删除</li>
</ol>
<h3 id="yum的使用-安装-搜索-软件群组-全系统更新"><a href="#yum的使用-安装-搜索-软件群组-全系统更新" class="headerlink" title=" yum的使用:安装/搜索/软件群组/全系统更新"></a><a name="ch2.3"> yum的使用:安装/搜索/软件群组/全系统更新</a></h3><p>yum除了可以安装升级软件外,其还提供了软件搜索以及软件群组等功能</p>
<p>yum指令的用法如下</p>
<ul>
<li>基本格式  <code>yum [options] [相关参数]</code><ul>
<li>一般options<ul>
<li><code>install</code>  安装指定的软件</li>
<li><code>update</code>  升级软件,后接软件名时,表指升级该软件,否则是全系统升级</li>
<li><code>remove</code>  移出软件</li>
<li><code>list</code>  列出所有可获得以及已安装的软件</li>
<li><code>search</code>  在RPM清单中搜索软件(即yum服务器上搜索)  本机搜索用<code>rpm -qa | grep &quot;keyword&quot;</code></li>
<li><code>info</code> 显示软件详细信息</li>
<li><code>clean</code> 清除<code>/var/cache/yum</code>中的安装包</li>
</ul>
</li>
<li>软件组options<ul>
<li><code>grouplist</code>  列出可使用的软件组</li>
<li><code>groupinfo</code> 显示软件组的详细信息</li>
<li><code>groupinstall</code> 安装软件组</li>
<li><code>groupremove</code> 移出软件组</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="选择特定的镜像网站-修改yum配置文件以及清除yum缓存"><a href="#选择特定的镜像网站-修改yum配置文件以及清除yum缓存" class="headerlink" title=" 选择特定的镜像网站:修改yum配置文件以及清除yum缓存"></a><a name="ch2.4"> 选择特定的镜像网站:修改yum配置文件以及清除yum缓存</a></h3><h4 id="找到镜像网站"><a href="#找到镜像网站" class="headerlink" title="找到镜像网站"></a>找到镜像网站</h4><p>首先我们要知道什么样的网站才是镜像网站,比如CentOS的镜像网站列表<a href="https://www.centos.org/download/mirrors/" target="_blank" rel="external">https://www.centos.org/download/mirrors/</a></p>
<p>但是我进入这个镜像网站里有好多目录,我该怎么做,比如下面这个北京理工大学的CentOS镜像网站
<a href="http://mirror.bit.edu.cn/centos/" target="_blank" rel="external">http://mirror.bit.edu.cn/centos/</a></p>
<p>我们先找到相对应的系统版本,比如我是CentOS7,进入后发现有好多目录,其实这些目录称为容器,提供某类型软件,比如操作系统软件<code>os</code>与一般软件<code>updates</code>这两个容器,其下面有一个<code>repodata</code>目录,那就是我们软件列表清单相关数据存放处</p>
<p>经过以上操作,我可以找到一个更新CentOS7的系统的容器<a href="http://mirror.bit.edu.cn/centos/7/os/x86_64/" target="_blank" rel="external">http://mirror.bit.edu.cn/centos/7/os/x86_64/</a></p>
<h4 id="修改配置文件-etc-yum-repos-d-repo"><a href="#修改配置文件-etc-yum-repos-d-repo" class="headerlink" title="修改配置文件/etc/yum.repos.d/*.repo"></a>修改配置文件<code>/etc/yum.repos.d/*.repo</code></h4><p>在<code>/etc/yum.repos.d</code>目录下新建或修改repo文件,比如我这个CentOS-Bit-Base.repo文件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[bit-base]  #容器名 不能同名</div><div class="line">name=CentOS-$releasever -Bit-Base  # 说明容器</div><div class="line">baseurl=http://mirror.bit.edu.cn/centos/7/os/x86_64/  #容器地址</div><div class="line">gpgcheck=1 #公匙相关</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7   </div><div class="line">enable=1   #启动这个容器</div><div class="line"></div><div class="line">#released updates </div><div class="line">[bit-updates]</div><div class="line">name=CentOS-$releasever -Bit-Updates</div><div class="line">baseurl=http://mirror.bit.edu.cn/centos/7/updates/x86_64/</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line">enable=1</div></pre></td></tr></table></figure></p>
<h4 id="查看容器是否启动与清除历史缓存"><a href="#查看容器是否启动与清除历史缓存" class="headerlink" title="查看容器是否启动与清除历史缓存"></a>查看容器是否启动与清除历史缓存</h4><ul>
<li>查看容器是否启动  <code>yum repolist all</code></li>
<li>清除历史缓存  <code>yum clean all</code></li>
</ul>
<h2 id="限制服务端口"><a href="#限制服务端口" class="headerlink" title=" 限制服务端口"></a><a name="ch3"> 限制服务端口</a></h2><h3 id="什么是端口-port"><a href="#什么是端口-port" class="headerlink" title=" 什么是端口(port)"></a><a name="ch3.1"> 什么是端口(port)</a></h3><p>当你启动一个服务时,这个服务根据TCP/IP相关协议启动一个端口(port)在监听,也就是说端口提供服务
端口有以下特点</p>
<ul>
<li>服务器启动的端口以及对应的服务是固定的,<code>/etc/services</code>可以查看</li>
<li>客户端连接服务器端口时,随机启动一个大于1024的端口连接</li>
<li>一个服务器可以同时提供多种服务</li>
<li>一共有65536个端口,TCP/UDP包中端口号占16位,固一台主机有2^16个端口<ul>
<li>只有root才能启动小于1024端口</li>
<li>大于1024端口用于客户端请求</li>
</ul>
</li>
<li>服务器端可以启用非正规端口提供服务,客户端连接时须指定端口</li>
<li>是否要可靠连接TCP</li>
</ul>
<h3 id="查看端口-netstat-nmap"><a href="#查看端口-netstat-nmap" class="headerlink" title=" 查看端口:netstat/nmap"></a><a name="ch3.2"> 查看端口:netstat/nmap</a></h3><ul>
<li><code>netstat</code> ： 查看本机上面启动的端口<ul>
<li>列出正在监听的网络服务 <code>netstat -tulnp</code></li>
<li>列出已连线的网络服务连线状态 <code>netstat -tun</code></li>
<li>删除已连线的网络服务的连线 <code>netstat -tunp</code>+<code>kill -9 pid</code></li>
</ul>
</li>
<li><code>nmap</code> 侦测网络上其他主机启动的端口,通常是同子网内主机的检测(不要去扫其他人主机,会违法的)<ul>
<li>以TCP中的ping扫描主机状态 <code>nmap [ip|hostname|(network/netIDNum)]  -PT</code></li>
<li>以ICMP扫描主机状态  <code>nmap [ip|hostname|(network/netIDNum)]  -sP</code></li>
</ul>
</li>
</ul>
<h3 id="服务的启动-关闭"><a href="#服务的启动-关闭" class="headerlink" title=" 服务的启动/关闭"></a><a name="ch3.3"> 服务的启动/关闭</a></h3><p>请查看<a href="https://github.com/HiKumho/blog/issues/28" target="_blank" rel="external">Linux 学习之认识系统服务(daemon)</a></p>
<h2 id="被攻击后主机修复工作"><a href="#被攻击后主机修复工作" class="headerlink" title=" 被攻击后主机修复工作"></a><a name="ch4"> 被攻击后主机修复工作</a></h2><h3 id="网管应具备的能力"><a href="#网管应具备的能力" class="headerlink" title=" 网管应具备的能力"></a><a name="ch4.1"> 网管应具备的能力</a></h3><ul>
<li>了解什么时需要保护的内容</li>
<li>预防黑客的入侵</li>
<li>主机环境安全化</li>
<li>防火墙规则的设置</li>
<li>即时维护主机</li>
<li>良好的教育训练课程</li>
<li>完善的备份计划</li>
</ul>
<h3 id="主机受攻击后复原工作流程"><a href="#主机受攻击后复原工作流程" class="headerlink" title=" 主机受攻击后复原工作流程"></a><a name="ch4.2"> 主机受攻击后复原工作流程</a></h3><ul>
<li>立即拔除网线</li>
<li>分析日志文件,搜索可能的入侵途径</li>
<li>重要资料备份</li>
<li>重新安装系统</li>
<li>软件漏洞修补</li>
<li>关闭/移出不需要的服务</li>
<li>资料的恢复与服务设置</li>
<li>连上Internet</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 服务器篇 常用的网络指令]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="网络参数设置使用的指令"><a href="#网络参数设置使用的指令" class="headerlink" title=" 网络参数设置使用的指令"></a><a name="ch1"> 网络参数设置使用的指令</a></h2><h3 id="设置IP参数与启动-关闭网络接口-ifconfig-ifup-ifdown"><a href="#设置IP参数与启动-关闭网络接口-ifconfig-ifup-ifdown" class="headerlink" title=" 设置IP参数与启动/关闭网络接口:ifconfig/ifup/ifdown"></a><a name="ch1.1"> 设置IP参数与启动/关闭网络接口:ifconfig/ifup/ifdown</a></h3><ul>
<li><code>ifconfig</code>  查看/设置/启动关闭网络接口 (设置的参数保存在<b>内存</b>中)<ul>
<li><code>ifconfig [interface(如eth0/wlan0)]</code>  查看网络接口信息<ul>
<li>注意interface可以是同张网卡的别名,比如<code>eth0:v1</code></li>
</ul>
</li>
<li><code>ifconfig [interface] {up|down}</code>  启动/关闭网络接口,设置时需先关闭网络接口</li>
<li><code>ifconfig [interface] {options}</code> 设置网络接口信息<ul>
<li><code>直接接ip地址</code></li>
<li><code>mtu</code> 后接mtu数值<ul>
<li><code>netmask</code> 子网掩码</li>
<li><code>boradcast</code> 广播地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>ifup/ifdown</code> 启动/关闭网络接口<ul>
<li>与<code>ifconfig</code>的启动关闭不同,其是参考/etc中的网络参数配置文件</li>
<li>当内存中<code>/proc/net</code>与<code>/etc</code>中的配置文件参数不同时,就会报错</li>
<li>格式是<code>ifup/ifdown [interface]</code></li>
</ul>
</li>
</ul>
<h3 id="路由修改-route"><a href="#路由修改-route" class="headerlink" title=" 路由修改:route"></a><a name="ch1.2"> 路由修改:route</a></h3><p><code>route</code> 查看/设置路由表,同样的其设置的参数是保存在内存中的,要静态修改路由可以写入配置文件<code>/etc/sysconfig/network-script/route-interface(CentOS)</code>或<code>/etc/network/interface(Ubuntu)</code></p>
<h4 id="查看路由表-route-n-ee-n是直接用IP和port显示主机名"><a href="#查看路由表-route-n-ee-n是直接用IP和port显示主机名" class="headerlink" title="查看路由表: route {-n|-ee} -n是直接用IP和port显示主机名"></a>查看路由表: <code>route {-n|-ee}</code> -n是直接用IP和port显示主机名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">目标            网关            子网掩码        标志  跃点   引用  使用 接口</div><div class="line">192.168.14.0    0.0.0.0         255.255.254.0   U     1      0        0 eth0</div><div class="line">10.42.0.0       0.0.0.0         255.255.255.0   U     9      0        0 wlan0</div><div class="line">0.0.0.0         192.168.14.1    0.0.0.0         UG    0      0        0 eth0</div></pre></td></tr></table></figure>
<p>上面参数的说明</p>
<ul>
<li><code>目标(Destination)</code> 网段IP地址(network)或主机IP,<code>0.0.0.0</code>表缺省</li>
<li><code>网关(Gateway)</code> 是路由器IP(邮局2333),需同本机同一个子域网内,<code>0.0.0.0</code>表本机</li>
<li><code>子网掩码(Genmask)</code> 标识网段</li>
<li><code>标志(Flags)</code><ul>
<li><code>U</code> 此路由已启动</li>
<li><code>H</code> 目标是一部主机非域网</li>
<li><code>G</code> 通过网关/路由器转包</li>
<li><code>R</code> 使用动态路由时,恢复路由信息</li>
<li><code>D</code> 已被设置为动态路由</li>
<li><code>M</code> 路由已被修改</li>
<li><code>!</code> 此路由不会被接受</li>
</ul>
</li>
<li><code>接口(Iface)</code> 此路由使用的接口</li>
</ul>
<p><b>注意: 路由表的编写应该要有顺序,由上到下从C类IP到A类IP,这样数据包传输时,会更准确</b></p>
<h4 id="路由的增加-删除"><a href="#路由的增加-删除" class="headerlink" title="路由的增加/删除"></a>路由的增加/删除</h4><ul>
<li>增加路由 <code>route add {-net|-host} {网段或主机IP} netmask {mask} dev {interface} [gw] {网关IP}</code></li>
<li>删除路由 <code>route del {-net|-host} {网段或主机IP} netmask {mask} dev {interface}</code></li>
</ul>
<h3 id="网络参数综合指令-ip"><a href="#网络参数综合指令-ip" class="headerlink" title=" 网络参数综合指令:ip"></a><a name="ch1.3"> 网络参数综合指令:ip</a></h3><p><code>ip</code>整合了<code>ifconfig</code>与<code>route</code>,且功能上比它们更多</p>
<p><code>ip</code>可以查看/设置3部分的内容:</p>
<ul>
<li><code>link</code> 关于网卡,包括MAC</li>
<li><code>addr</code> 关于IP参数</li>
<li><code>route</code> 关于路由表</li>
</ul>
<h4 id="查看-设置网卡参数-ip-link"><a href="#查看-设置网卡参数-ip-link" class="headerlink" title="查看/设置网卡参数: ip link"></a>查看/设置网卡参数: ip link</h4><ul>
<li>查看网卡参数 <code>ip [-s] link show</code></li>
<li>设置网卡参数 <code>ip link set {interface} [options]</code><ul>
<li><code>up|down</code> 启动/关闭网卡接口</li>
<li><code>address</code> 修改MAC</li>
<li><code>name</code>  网卡接口的特殊名字</li>
<li><code>mtu</code> 修改mtu</li>
</ul>
</li>
</ul>
<h4 id="查看-设置IP参数-ip-address"><a href="#查看-设置IP参数-ip-address" class="headerlink" title="查看/设置IP参数:ip address"></a>查看/设置IP参数:ip address</h4><ul>
<li>查看网卡参数 <code>ip [-s] address show</code></li>
<li>设置网卡参数 <code>ip address {add|del} {ip地址}  dev {interface} [options]</code><ul>
<li><code>broadcast</code> 广播地址 <code>+</code>表自动计算</li>
<li><code>label</code> 网络接口别名</li>
<li><code>name</code>  网卡接口的特殊名字</li>
<li><code>scope</code><ul>
<li><code>global</code> 允许来自所有来源的连线</li>
<li><code>link</code> 仅允许本接口的自我连线</li>
<li><code>host</code> 仅允许本主机内部的连线</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查看-设置路由表-ip-route"><a href="#查看-设置路由表-ip-route" class="headerlink" title="查看/设置路由表:ip route"></a>查看/设置路由表:ip route</h4><ul>
<li>查看路由表 <code>ip route show</code></li>
<li>设置路由表 <code>ip route [add|del] [子网或主机IP] [via 网关IP] [dev 接口]</code></li>
</ul>
<h3 id="无线网络-iwlist-iwconfig"><a href="#无线网络-iwlist-iwconfig" class="headerlink" title=" 无线网络:iwlist/iwconfig"></a><a name="ch1.4"> 无线网络:iwlist/iwconfig</a></h3><ul>
<li><code>iwconfig</code>   设置无线网络</li>
<li><code>iwlist</code> 侦测无线基站(AP,热点)<ul>
<li><code>iwlist [interface(如wlan0)] scan</code></li>
</ul>
</li>
</ul>
<h3 id="使用dchp自动取得IP参数-dhclient"><a href="#使用dchp自动取得IP参数-dhclient" class="headerlink" title=" 使用dchp自动取得IP参数:dhclient"></a><a name="ch1.5"> 使用dchp自动取得IP参数:dhclient</a></h3><p>让某个网络接口发送dhcp要求取得IP参数:<code>dhclient [interface]</code></p>
<h2 id="网络侦测与观察指令"><a href="#网络侦测与观察指令" class="headerlink" title=" 网络侦测与观察指令"></a><a name="ch2"> 网络侦测与观察指令</a></h2><h3 id="两主机两点连通测试与追踪路径中的MTU最大值：ping"><a href="#两主机两点连通测试与追踪路径中的MTU最大值：ping" class="headerlink" title=" 两主机两点连通测试与追踪路径中的MTU最大值：ping"></a><a name="ch2.1"> 两主机两点连通测试与追踪路径中的MTU最大值：ping</a></h3><h4 id="测试两主机是否连通-ping-IP-hostname"><a href="#测试两主机是否连通-ping-IP-hostname" class="headerlink" title="测试两主机是否连通:ping [IP|hostname]"></a>测试两主机是否连通:<code>ping [IP|hostname]</code></h4><p>ping会发送一个ICMP包(其装入IP包中)来进行网络状态的测试,利用ICMP包返回的信息来进行分析</p>
<p>其中比较重要的是<code>ttl</code>参数,表示数据包经过的路由器数(经过一个就减1)
当目标主机与本机同一个域网内,ttl预设64,否则预设255</p>
<h4 id="测试路径能通过的最大MTU-ping-IP-hostname-s-MTU测试值-M-do-不进行拆包处理"><a href="#测试路径能通过的最大MTU-ping-IP-hostname-s-MTU测试值-M-do-不进行拆包处理" class="headerlink" title="测试路径能通过的最大MTU:ping [IP|hostname] -s MTU测试值 -M do(不进行拆包处理)"></a>测试路径能通过的最大MTU:<code>ping [IP|hostname] -s MTU测试值 -M do(不进行拆包处理)</code></h4><p>如果MTU测试值太大就会报错</p>
<h3 id="两主机间各节点的分析：traceroute"><a href="#两主机间各节点的分析：traceroute" class="headerlink" title=" 两主机间各节点的分析：traceroute"></a><a name="ch2.2"> 两主机间各节点的分析：traceroute</a></h3><p><code>traceroute [IP|hostname]</code> 跟踪两主机间各节点的信息</p>
<p>默认traceroute预设UDP包来进行测试,只是现在很多路由器会过滤UDP/ICMP的回应
我们可以用TCP包来测试,只要加上<code>-T</code>参数 </p>
<h3 id="查看本机的网络连接与后面：netstat"><a href="#查看本机的网络连接与后面：netstat" class="headerlink" title=" 查看本机的网络连接与后面：netstat"></a><a name="ch2.3"> 查看本机的网络连接与后面：netstat</a></h3><ul>
<li><code>netstat -nlptu</code>  输出目前本机已启动的网络服务</li>
<li><code>netstat -atunp</code> 查看本机所有网络连线状态</li>
</ul>
<h3 id="查看主机名与IP：host-nslookup-dig"><a href="#查看主机名与IP：host-nslookup-dig" class="headerlink" title=" 查看主机名与IP：host/nslookup/dig"></a><a name="ch2.4"> 查看主机名与IP：host/nslookup/dig</a></h3><ul>
<li><code>host hostname [DNS IP]</code>: 查看对应主机的IP,默认以<code>/etc/resolv.conf</code>设置的DNS服务器查询</li>
<li><code>nslookup [hostname|IP]</code> 查看主机名或IP的信息</li>
<li><code>dig [hostname|IP]</code> 查看主机名或IP的信息</li>
</ul>
<h2 id="远端连线指令"><a href="#远端连线指令" class="headerlink" title=" 远端连线指令"></a><name="ch3"> 远端连线指令</name="ch3"></h2><p>这里的远端连线,连接到对方的服务器上,获取资源等操作
传统的连线指令有<code>telnet</code>与<code>ftp</code>等,由于其使用明文传输,安全性较低,<code>ssh</code>针对这方面进行加强</p>
<ul>
<li><code>telnet</code>  比较常用与BBS<ul>
<li><code>telnet [host|IP] [port]</code></li>
</ul>
</li>
<li><code>ftp</code>  传输较大的资料<ul>
<li><code>ftp [host|IP] [port]</code></li>
</ul>
</li>
<li><code>lftp</code> 自动化ftp脚本<ul>
<li>由于我们连接到目标的ftp服务器后,其操作都要参考目标服务器的设置,lftp能自动化处理</li>
<li><code>lftp [host|IP] [port] [-u user[,pass]] -c &quot;commands&quot;</code><ul>
<li>我们将要执行的操作写入commands中,每条指令到要分行</li>
</ul>
</li>
</ul>
</li>
<li><code>ssh</code> 为Shell提供安全的传输和使用环境,传输的数据经压缩<ul>
<li><code>ssh [host|IP] [port]</code></li>
</ul>
</li>
</ul>
<h2 id="文字界面网页浏览器-下载器"><a href="#文字界面网页浏览器-下载器" class="headerlink" title=" 文字界面网页浏览器/下载器"></a><a name="ch4"> 文字界面网页浏览器/下载器</a></h2><p>我们在命令行中要想浏览html页面,可以使用<code>links</code></p>
<p>而要下载网络资源可以使用<code>wget</code>或<code>axel</code>
其中<code>axel</code>有断点续传的功能,而<code>wget</code>没有</p>
<h2 id="数据包抓取"><a href="#数据包抓取" class="headerlink" title=" 数据包抓取"></a><a name="ch5"> 数据包抓取</a></h2><h3 id="对网络连线TCP-UDP读写-nc-netcat"><a href="#对网络连线TCP-UDP读写-nc-netcat" class="headerlink" title=" 对网络连线TCP/UDP读写:nc,netcat"></a><a name="ch5.1"> 对网络连线TCP/UDP读写:nc,netcat</a></h3><ul>
<li>启动服务端口:<code>nc -l [ip|hostname] [port]</code></li>
<li>连接服务端口:<code>nc [ip|hostname] [port]</code>(类似telnet)</li>
</ul>
<p>两个端口建立连线后,就可以传输数据,比如:
透过端口3333（-l 监听状态listen）从机器foo复制到机器bar复制档案：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user@bar$ nc -l -p 3333 &gt; backup.iso</div><div class="line">user@foo$ nc bar 3333 &lt; backup.iso</div></pre></td></tr></table></figure></p>
<p>利用零模式I/O（参数 -z）检查192.168.0.1的UDP端口（参数 -u）80-90是否开启：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nc -vzu 192.168.0.1 80-90</div></pre></td></tr></table></figure></p>
<h3 id="抓取TCP数据包-tcpdump-wireshark"><a href="#抓取TCP数据包-tcpdump-wireshark" class="headerlink" title=" 抓取TCP数据包:tcpdump/wireshark"></a><a name="ch5.2"> 抓取TCP数据包:tcpdump/wireshark</a></h3><ul>
<li><code>tcpdump</code>  会监听某个网络接口上传输的数据包,并将其抓取进行分析<ul>
<li>格式 <code>tcpdump [-i 网络接口] [-w 存取本地文件] [-r 读取保存本地的文件] [-Aennqx] [-c 监听数据包数量]</code><ul>
<li><code>A</code> 以ASCII显示数据包内容,通常用于抓取网页数据包</li>
<li><code>e</code>  以MAC帧数据来显示</li>
<li><code>nn</code> 直接以IP/port显示主机名与服务名</li>
<li><code>q</code> 简短的数据包信息</li>
<li><code>X</code> 以十六进制与ASCII显示数据包内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>而wireshark是图形界面下的抓包工具</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 服务器篇 连接Internet]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87-%E8%BF%9E%E6%8E%A5Internet/</url>
      <content type="html"><![CDATA[<h2 id="Linux-连接Internet-驱动网卡"><a href="#Linux-连接Internet-驱动网卡" class="headerlink" title=" Linux 连接Internet : 驱动网卡"></a><a name="ch1"> Linux 连接Internet : 驱动网卡</a></h2><p>当我们想要连接上Internet时,首先需要确保Linux已经驱动了网卡,之后才是设置网络参数</p>
<h3 id="查看Linux是否驱动网卡"><a href="#查看Linux是否驱动网卡" class="headerlink" title=" 查看Linux是否驱动网卡"></a><a name="ch1.1"> 查看Linux是否驱动网卡</a></h3><p>要确保自己机器上已经有网卡了,之后使用<code>dmesg | grep eth</code>查看网卡信息(注意有线网卡设备名是eth0…ethN)</p>
<p>比如我机器上的<code>RTL8105e</code>螃蟹卡,而对应的内核模块(驱动程序)是<code>r8169</code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[  1.223558] r8169 0000:09:00.0 eth0: RTL8105e at 0xf845c000, e0:db:55:ab:6b:29, XID 00c00000 IRQ 27</div></pre></td></tr></table></figure></p>
<p>可以通过<code>lsmod | grep r8169</code>查看是否该模块有加载至内核中,如果要查看详细模块信息可以<code>modinfo r8169</code></p>
<h3 id="编译驱动网卡模块"><a href="#编译驱动网卡模块" class="headerlink" title=" 编译驱动网卡模块"></a><a name="ch1.2"> 编译驱动网卡模块</a></h3><p>一般来说,如果我们的网卡被Linux驱动,可能就要去找此张网卡相对的驱动程序,再自行编译。</p>
<p>不太推荐自行编译网卡驱动,毕竟升级内核时,又需要重新编译一次自行编译的程序,通常都是购买Linux支持的网卡</p>
<p>以下说明自行编译网卡驱动程序的过程</p>
<h4 id="取得官方驱动程序包"><a href="#取得官方驱动程序包" class="headerlink" title="取得官方驱动程序包"></a>取得官方驱动程序包</h4><p>比如这里取得的是驱动程序源码</p>
<h4 id="解压缩与编译安装"><a href="#解压缩与编译安装" class="headerlink" title="解压缩与编译安装"></a>解压缩与编译安装</h4><p>解压源码包,通过读README等文件知道编译过程,通常使用config与make编译安装程序(这里是内核模块)</p>
<h4 id="加载内核模块"><a href="#加载内核模块" class="headerlink" title="加载内核模块"></a>加载内核模块</h4><p>利用<code>depmod</code>与<code>modprobe</code>加载内核模块至内核</p>
<p>详细过程请看</p>
<ul>
<li><a href="https://github.com/HiKumho/blog/issues/31#ch1.4" target="_blank" rel="external">什么是软件的tarball及其安装过程</a></li>
<li><a href="https://github.com/HiKumho/blog/issues/30#ch4" target="_blank" rel="external">内核与内核模块</a></li>
</ul>
<h2 id="Linux-连接Internet-设置网络参数"><a href="#Linux-连接Internet-设置网络参数" class="headerlink" title=" Linux 连接Internet : 设置网络参数"></a><a name="ch2"> Linux 连接Internet : 设置网络参数</a></h2><p>我们知道TCP/IP的重要参数主要有:IP/Netmask/Gateway/DNS IP 此外还有主机名(hostname)与本地保存的域名与IP对应关系(host)</p>
<h3 id="Linux的网络参数配置文件"><a href="#Linux的网络参数配置文件" class="headerlink" title=" Linux的网络参数配置文件"></a><a name="ch2.1"> Linux的网络参数配置文件</a></h3><p>CentOS下,它们的配置文件如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">设置的网络参数</th>
<th style="text-align:center">文件名</th>
<th style="text-align:center">重要参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IP/Netmask/DHCP/Gateway等</td>
<td style="text-align:center">/etc/sysconfig/network-scripts/ifcfg-eth0</td>
<td style="text-align:center">DEVICE=网卡设备名(这里是eth0)<br>BOOTPROTO=是否使用dhcp(自动获取网络参数)<br>HWADDR=网卡MAC<br>IPADDR=IP地址<br>NETMASK=子网掩码<br>ONBOOT=预设使用此文件设置的参数<br>GATEWAY=网关IP<br>NM_CONTROLLED=额外的网管软件</td>
</tr>
<tr>
<td style="text-align:center">主机名称</td>
<td style="text-align:center">/etc/sysconfig/network</td>
<td style="text-align:center">NETWORKING=要不要有网络<br>NETWORKING_IPV6=支持IPV6<br>HOSTNAME=主机名</td>
</tr>
<tr>
<td style="text-align:center">DNS IP</td>
<td style="text-align:center">/etc/resolv.conf</td>
<td style="text-align:center">nameserver DNS的IP</td>
</tr>
<tr>
<td style="text-align:center">本地保存的主机名与IP对应表</td>
<td style="text-align:center">/etc/hosts</td>
<td style="text-align:center">IP 主机名称 别名</td>
</tr>
</tbody>
</table>
<p>Ubuntu下,它们的配置文件如上相似,主要是</p>
<ul>
<li><code>IP/Netmask等</code>  在<code>/etc/network/interfaces(默认设置)</code>与<code>/etc/NetworkManager/system-connections/(各网络接口的设置)</code></li>
<li><code>主机名称</code>  在<code>/etc/hostname</code>中</li>
</ul>
<p>以下是一个/etc/network/interfaces配置文件,可以配置dns/路由表/网络接口等参数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># This file describes the network interfaces available on your system</div><div class="line"># and how to activate them. For more information, see interfaces(5).</div><div class="line"></div><div class="line"># The loopback network interface</div><div class="line">auto lo</div><div class="line">iface lo inet loopback</div><div class="line"></div><div class="line"># The primary network interface</div><div class="line">auto eth0</div><div class="line">iface eth0 inet static</div><div class="line">address xxx.xxx.xxx.xxx</div><div class="line">netmask xxx.xxx.xxx.xxx</div><div class="line">gateway xxx.xxx.xxx.xxx</div><div class="line"></div><div class="line">auto eth0:0</div><div class="line">iface eth0:0 inet static</div><div class="line">address xxx.xxx.xxx.xxx</div><div class="line">netmask xxx.xxx.xxx.xxx</div><div class="line"></div><div class="line">#dns-nameservers 202.102.224.68 202.102.227.68</div><div class="line">up route add -net xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx gw xxx.xxx.xxx.xxx eth0</div><div class="line">up route add -net xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx gw xxx.xxx.xxx.xxx eth0</div><div class="line">up route add -net xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx gw xxx.xxx.xxx.xxx eth0</div></pre></td></tr></table></figure></p>
<p>除了上面的文件外,还有以下较重要的文件</p>
<ul>
<li><code>/etc/services</code>  定义服务与端口对应</li>
<li><code>/etc/protocols</code>  定义IP包相关协议资料</li>
</ul>
<h3 id="启动网络服务"><a href="#启动网络服务" class="headerlink" title=" 启动网络服务"></a><a name="ch2.2"> 启动网络服务</a></h3><p>当我们更新好网络参数配置文件后,当然要重启网络服务啦！
有以下两种方式</p>
<ul>
<li><code>/etc/init.d/network restart</code> 重启整个网络服务</li>
<li><code>ifup eth0(ifdown eth0)</code>  只启动或关闭某个网络接口</li>
</ul>
<h3 id="手动设置固定IP参数"><a href="#手动设置固定IP参数" class="headerlink" title=" 手动设置固定IP参数"></a><a name="ch2.3"> 手动设置固定IP参数</a></h3><p>如上面我们可以知道要手动设置固定IP参数,就是修改其的配置文件,以下是修改网络参数涉及到的配置文件/启动脚本和测试命令表</p>
<table>
<thead>
<tr>
<th style="text-align:center">修改的参数</th>
<th style="text-align:center">配置文件与启动脚本</th>
<th style="text-align:center">测试命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IP相关参数</td>
<td style="text-align:center">/etc/sysconfig/network-scripts/ifcfg-eth0<br>/etc/init.d/network restart</td>
<td style="text-align:center">ifconfig(查看IP参数)<br>route(查看网关)<br>ping 网关IP</td>
</tr>
<tr>
<td style="text-align:center">DNS IP</td>
<td style="text-align:center">/etc/reslov.conf</td>
<td style="text-align:center">dig www.google.com</td>
</tr>
<tr>
<td style="text-align:center">主机名称</td>
<td style="text-align:center">/etc/sysconfig/network<br>/etc/hosts</td>
<td style="text-align:center">hostname (获取主机名)<br> ping $(hostname)<br> reboot</td>
</tr>
</tbody>
</table>
<p>这里注意的是IP相关参数时设置的网关,每个接口都有一样(或者只设置一个),避免互相干扰</p>
<h3 id="自动取得IP参数-DHCP"><a href="#自动取得IP参数-DHCP" class="headerlink" title=" 自动取得IP参数:DHCP"></a><a name="ch2.4"> 自动取得IP参数:DHCP</a></h3><p>DHCP就是有一部主机提供DHCP服务给整个网域下的主机,比如IP分享器就是一个DHCP主机,其会提供IP参数与DNS参数,所以不需要额外设置</p>
<p>将<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>中<code>BOOTPROTO</code>设置为<code>dhcp</code>就启动了<code>eth0</code>为DHCP连接,然后将IP/子网掩码/网关等都去掉(特别是网关)</p>
<h3 id="ADSL拨号连网"><a href="#ADSL拨号连网" class="headerlink" title=" ADSL拨号连网"></a><a name="ch2.5"> ADSL拨号连网</a></h3><p>ADSL拨号连网需要使用<code>rp-pppoe</code>这个软件帮忙,其拨号成功后会产生一个<code>ppp0</code>接口,其是架设在以太网卡(<code>eth0</code>)上的,所以<code>eth0</code>不能关闭,但是要一定要将eth0设置的网关去掉,<code>ppp0</code>会提供一个网关</p>
<ul>
<li>当网卡有Private IP又要拨号上网时<ul>
<li>仍是使用此预设启动网卡<code>ONBOOT=yes</code></li>
<li>仍设置IP与子网掩码,都是局域网的参数</li>
<li>不设置网关</li>
<li>之后设置<code>pppoe-setup</code>拨号参数</li>
<li><code>pppoe-start</code>来进行拨号上网</li>
<li>这样局域网内的主机可以通过此网卡连上Internet</li>
</ul>
</li>
<li>如果要两张网卡,就可以<ul>
<li>对外网卡预设不启动<code>ONBOOT=no</code></li>
<li>对外网卡进行拨号</li>
<li>对内网卡设置局域网IP参数</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 服务器篇 局域网架设简介]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%9E%B6%E8%AE%BE%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h2 id="局域网的连线"><a href="#局域网的连线" class="headerlink" title=" 局域网的连线"></a><a name="ch1"> 局域网的连线</a></h2><p>以下章节我们是谈到小型局域网的布线规划,而大型企业内部网络的架设需要相当多的专业知识(如线路设计,配线盘,墙上打网线孔等)我们只能放着</p>
<p>以下的布线是以星型连线架构设计的</p>
<h3 id="Linux直接联网-与一般PC同地位"><a href="#Linux直接联网-与一般PC同地位" class="headerlink" title=" Linux直接联网-与一般PC同地位"></a><a name="ch1.1"> Linux直接联网-与一般PC同地位</a></h3><p>当我们拥有多Public IP(ADSL拨接给予多个IP)时可以使用以下的连接方式,Linux与一般PC同地位,<b>它们都具有一个Public IP与Private IP</b>,所以服务器挂机后,不会影响其他PC,这种方式管理上困难</p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/blog_36_1.png?raw=true" alt=""></p>
<h3 id="Linux直接联网-与一般PC分开网域"><a href="#Linux直接联网-与一般PC分开网域" class="headerlink" title=" Linux直接联网-与一般PC分开网域"></a><a name="ch1.2"> Linux直接联网-与一般PC分开网域</a></h3><p>同样是当我们拥有多Public IP时可以使用的连接方式,一般PC放在同一个子网内,内部传输没有问题,外部连接时通过IP分享器,获取Public IP,而Linux在它们的上层网络,更易于管理子网内PC的连接</p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/blog_36_2.png?raw=true" alt=""></p>
<h3 id="Linux直接联网-让Linux直接管理LAN"><a href="#Linux直接联网-让Linux直接管理LAN" class="headerlink" title=" Linux直接联网-让Linux直接管理LAN"></a><a name="ch1.3"> Linux直接联网-让Linux直接管理LAN</a></h3><p>以下连接方式不管你是否有多个Public IP都使用,让Linux直接管理LAN,而且可以作为防火墙,<b>要求是Linux服务器必须具有两张以上的网卡</b>,对外使用Public IP,对内使用Private IP,当然你一张网卡有两个网络接口也行</p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/blog_36_3.png?raw=true" alt=""></p>
<h3 id="Linux放在防火墙后-让Linux使用Private-IP"><a href="#Linux放在防火墙后-让Linux使用Private-IP" class="headerlink" title=" Linux放在防火墙后-让Linux使用Private IP"></a><a name="ch1.4"> Linux放在防火墙后-让Linux使用Private IP</a></h3><p>让Linux服务器在LAN中,让防火墙过滤连接,将数据包重新导向进入服务器,这种连线方式在大型企业内部常见</p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/blog_36_4.png?raw=true" alt=""></p>
<h2 id="网络设备选购建议"><a href="#网络设备选购建议" class="headerlink" title=" 网络设备选购建议"></a><a name="ch2"> 网络设备选购建议</a></h2><ul>
<li><code>主机硬件系统</code>   考虑使用年限/省电/虚拟化功能(虚拟机)等</li>
<li><code>Linux操作系统</code>  考虑稳定/可网络升级/能够快速取得协助支援</li>
<li><code>网卡</code> 考虑服务器用途/是否内建/驱动程序取得等</li>
<li><code>Switch/Hub</code>  考虑主机数量/防火墙/传输频宽</li>
<li><code>网线</code>   考虑与速度相配的等级/线材/施工配线等</li>
<li><code>无线网络相关设备</code>  考虑速度/安全性/标准等</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 建立虚拟WiFi]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E5%BB%BA%E7%AB%8B%E8%99%9A%E6%8B%9FWiFi/</url>
      <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>今天想在Linux下建立虚拟WiFi,共享给手机使用.自己的操作环境是Ubuntu14.04</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="先确保已连上Internet-以及启动WiFi"><a href="#先确保已连上Internet-以及启动WiFi" class="headerlink" title="先确保已连上Internet,以及启动WiFi"></a>先确保已连上Internet,以及启动WiFi</h4><p>在Ubuntu的右上角Network管理中<code>启动联网</code>以及<code>启动Wi-Fi</code></p>
<h4 id="建立一个WiFi连接"><a href="#建立一个WiFi连接" class="headerlink" title="建立一个WiFi连接"></a>建立一个WiFi连接</h4><p>新建一个连接WiFi连接
<img src="https://github.com/HiKumho/blog/blob/master/img/%E5%85%B1%E4%BA%ABWIFI/%E5%85%B1%E4%BA%ABWIFI_1.png?raw=true" alt=""></p>
<h4 id="配置已新建的WiFi连接"><a href="#配置已新建的WiFi连接" class="headerlink" title="配置已新建的WiFi连接"></a>配置已新建的WiFi连接</h4><p>对新建的WiFi连接进行如下配置,其中<code>SSID</code>就是WiFi名  <code>WIFI安全性的密码</code>就是WiFi的密码</p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/%E5%85%B1%E4%BA%ABWIFI/%E5%85%B1%E4%BA%ABWIFI_2.png?raw=true" alt=""></p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/%E5%85%B1%E4%BA%ABWIFI/%E5%85%B1%E4%BA%ABWIFI_3.png?raw=true" alt=""></p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/%E5%85%B1%E4%BA%ABWIFI/%E5%85%B1%E4%BA%ABWIFI_4.png?raw=true" alt=""></p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/%E5%85%B1%E4%BA%ABWIFI/%E5%85%B1%E4%BA%ABWIFI_5.png?raw=true" alt=""></p>
<h4 id="修改新建WiFi的配置文件"><a href="#修改新建WiFi的配置文件" class="headerlink" title="修改新建WiFi的配置文件"></a>修改新建WiFi的配置文件</h4><p>取得root权限,修改上面新建WiFi的配置文件<code>sudo vim /etc/NetworkManager/system-connections/WIFI1</code> 将其中<code>mode</code>属性值改为<code>ap</code>,如<code>mode=ap</code>,保存</p>
<h5 id="连接新建WiFi"><a href="#连接新建WiFi" class="headerlink" title="连接新建WiFi"></a>连接新建WiFi</h5><p>在Network管理上<code>连接到隐藏的Wi-Fi网络</code>选中新建的WiFi,就可以在手机上面扫描并连接上此WiFi</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://ubuntuhandbook.org/index.php/2014/09/3-ways-create-wifi-hotspot-ubuntu/" target="_blank" rel="external">3 Ways to Create Wifi Hotspot in Ubuntu 14.04 (Android Support)</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 服务器篇 基础网络概念]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87-%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h2 id="什么是网络"><a href="#什么是网络" class="headerlink" title=" 什么是网络"></a><a name="ch1"> 什么是网络</a></h2><p>网络是将主机用网线或无线技术连接起来,使主机资源透过网络设备来传输的一种技术,其跨平台,一个标准用于不同操作系统间,这个标准为IEEE标准,其分为硬件标准(以太网络设备)与通信协议(TCP/IP)</p>
<h3 id="网络组成元件"><a href="#网络组成元件" class="headerlink" title=" 网络组成元件"></a><a name="ch1.1"> 网络组成元件</a></h3><p>组成网络的元件有以下:</p>
<ul>
<li>节点: 主要是具有网络地址(IP)的设备</li>
<li>服务器主机:一个提供资料的特殊节点</li>
<li>工作站/客服端:任何可在网络上输入的设备都可是工作站/客服端,比如ATM机</li>
<li>网络卡:以太网卡,内建或外插在主机上的设备,提供网络连线,一个节点至少有一个网络卡</li>
<li>网络接口:提供网络地址,一张网卡至少可以搭配一个以上的网络接口,每台主机都有一个内部网络接口,其提供127.0.0.1/8这个IP</li>
<li>路由或网关:其具有两个以上的网络接口,可连接两个以上的不同网段的设备</li>
<li>网络拓扑:各个节点在网络上的连接方式</li>
</ul>
<h3 id="网络区域范围"><a href="#网络区域范围" class="headerlink" title=" 网络区域范围"></a><a name="ch1.2"> 网络区域范围</a></h3><p>通常以距离来划分网络分为区域网络(Local Area Network,LAN)与广域网络(Wide Area Network,WAN),区域网络通过用较好的设备来连接,而广域网络则用较便宜的设备</p>
<h3 id="网络通信协议-OSI七层协议"><a href="#网络通信协议-OSI七层协议" class="headerlink" title=" 网络通信协议:OSI七层协议"></a><a name="ch1.3"> 网络通信协议:OSI七层协议</a></h3><p>因为网络通信涉及到相当多的环节,如硬件/软件封包等,故将网络通信的实现划分成多个层级,每个层级独立,只负责处理本层的任务</p>
<p>OSI七层模型如下图:
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_34_1_OSI%E6%A8%A1%E5%9E%8B.gif?raw=true" alt=""></p>
<p>七层模型中越接近硬件的层为底层,越接近应用程序的为高层,每层只认识对方同一层的数据,且每层都有自己独特的表头资料(header)</p>
<p>每层负责的任务如下表:</p>
<table style="margin: 1em auto 1em auto;">
<tr>
<th colspan="5">OSI 模型</th>
</tr>
<tr>
<th></th>
<th>数据单元</th>
<th>层</th>
<th colspan="2">功能</th>
</tr>
<tr>
<th rowspan="4">主机层</th>
<td style="background:#d8ec9c;" rowspan="3">Dat（数据）</td>
<td style="background:#d8ec9b;"> 应用层</td>
<td style="background:#d8ec9c;" colspan="2">网络进程到应用程序。提供为应用软件而设的界面，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等</td>
</tr>
<tr>
<td style="background:#d8ec9b;"> 表示层</td>
<td style="background:#d8ec9b;" colspan="2">把数据转换为能与接收者的系统格式兼容并适合传输的格式</td>
</tr>
<tr>
<td style="background:#d8ec9b;"> 会话层</td>
<td style="background:#d8ec9b;" colspan="2">负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接</td>
</tr>
<tr>
<td style="background:#e7ed9c;">Segments（数据段）</td>
<td style="background:#e7ed9c;"> 传输层</td>
<td style="background:#e7ed9c;" colspan="2">把传输表头(TH)加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议(TCP/UDP) 等</td>
</tr>
<tr>
<th rowspan="3">媒介层</th>
<td style="background:#eddc9c;">网络分组/数据报文</td>
<td style="background:#eddc9c;"> 网络层</td>
<td style="background:#eddc9c;" colspan="2">决定数据的路径选择和转寄，将网络表头(NH)加至数据包，以形成分组。网络表头包含了网络数据。例如:互联网协议(IP) 等</td>
</tr>
<tr>
<td style="background:#e9c189;">Frame（数据帧）</td>
<td style="background:#e9c189;">数据链路层</td>
<td style="background:#e9c189;" colspan="2">负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成了帧。数据链表头(DLH)是包含了物理地址和错误侦测及改错的方法。数据链表尾(DLT)是一串指示数据包末端的字符串。例如以太网、无线局域网(Wi-Fi)和通用分组无线服务(GPRS)等</td>
</tr>
<tr>
<td style="background:#e9988a;">Bit（比特）</td>
<td style="background:#e9988a;">物理层</td>
<td style="background:#e9988a;" colspan="2">在局部局域网上传送帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等</td>
</tr>
</table>

<h3 id="网络通信协议：TCP-IP"><a href="#网络通信协议：TCP-IP" class="headerlink" title=" 网络通信协议：TCP/IP"></a><a name="ch1.4"> 网络通信协议：TCP/IP</a></h3><p>由于OSI过于严谨,所以实际使用时会将其简化,那就是TCP/IP协议,其为4层。</p>
<p>TCP/IP与OSI对应关系以及使用协议如下图:
<img src="https://raw.githubusercontent.com/HiKumho/blog/9a69ddba59bac60c5344ddcd982ea6b398b96e2d/img/blog_34_2_TCP-IP%E6%A8%A1%E5%9E%8B.gif" alt=""></p>
<p>TCP/IP如何运行,我们以打开一个网址为例:<br>0. 应用程序阶段: 在浏览器输入网址,此时网址与相关资料被浏览器包装成一个资料,向下传给TCP/IP的应用层<br>1. 应用层阶段:由应用层提供的HTTP协议,将来自浏览器资料包装起来,并给予一个应用层表头,再向传输层送去<br>2. 传输层阶段:由于HTTP为可靠连接,因此该包会被装入TCP封包中,并给予TCP包的表头,向网络层送去<br>3. 网络层阶段:将TCP包装入IP封包,给予IP表头(包含来源IP:port与目的地IP:port),向链接层送去<br>4. 链接层阶段:将IP包依据CSMA/CD标准,包装成MAC帧,并给予MAC表头,最后转换成位元串,利用传输设备送到远端主机上<br>5. 服务器回应:服务器接受到此包后,会进行逆向地拆解,每个层级进行分析,最后取得想要的资料再根据上面的流程送回给客服端       </p>
<h2 id="TCP-IP协议-链接层-Network-Interface-link"><a href="#TCP-IP协议-链接层-Network-Interface-link" class="headerlink" title=" TCP/IP协议:链接层(Network Interface/link)"></a><a name="ch2"> TCP/IP协议:链接层(Network Interface/link)</a></h2><p>TCP/IP最底层的链接层主要与硬件有关,下面会说明WAN/LAN的硬件与以太网络的传输协议:CSMA/CD,以及MAC帧等概念</p>
<h3 id="WAN使用的设备"><a href="#WAN使用的设备" class="headerlink" title=" WAN使用的设备"></a><a name="ch2.1"> WAN使用的设备</a></h3><p>LAN使用的设备较为便宜,但使用的设备非常多,一般用户通常接触到的主要是ADSL或光纤等</p>
<h4 id="传统电话拨号-通过ppp协议"><a href="#传统电话拨号-通过ppp协议" class="headerlink" title="传统电话拨号:通过ppp协议"></a>传统电话拨号:通过ppp协议</h4><p>早期网络只能通过数据机加上电话线以及电脑九针端口，通过点对点协议（Point-to-Point Protocol，PPP，它通常用在两节点间创建直接的连接）,来访问网络,速度非常慢,通过打电话后就不能使用网络了</p>
<h4 id="综合业务数字网-Integrated-Services-Digital-Network，ISDN"><a href="#综合业务数字网-Integrated-Services-Digital-Network，ISDN" class="headerlink" title="综合业务数字网(Integrated Services Digital Network，ISDN)"></a>综合业务数字网(Integrated Services Digital Network，ISDN)</h4><p>利用现有的电话线路来达成网络连线的目的,只是连线两端都需要有ISDN数据机来提供连线功能,其有多种通道可以使用</p>
<h4 id="非对称数字用户线路-Asymmetric-Digital-Subscriber-Line-ADSL"><a href="#非对称数字用户线路-Asymmetric-Digital-Subscriber-Line-ADSL" class="headerlink" title="非对称数字用户线路(Asymmetric Digital Subscriber Line,ADSL)"></a>非对称数字用户线路(Asymmetric Digital Subscriber Line,ADSL)</h4><p>采用频分多路复用技术把普通的电话线分成了电话、上行和下行三个相对独立的信道，从而避免了相互之间的干扰,注意ADSL中速度单位是bits/s,比如下行速度2Mbps,实际是256KB(types)ps</p>
<h4 id="线缆调制解调器-Cable-modem"><a href="#线缆调制解调器-Cable-modem" class="headerlink" title="线缆调制解调器(Cable modem)"></a>线缆调制解调器(Cable modem)</h4><p>是利用有线电视双向同轴电缆提供互联网相关应用服务的技术</p>
<h3 id="LAN使用的设备-以太网"><a href="#LAN使用的设备-以太网" class="headerlink" title=" LAN使用的设备:以太网"></a><a name="ch2.2"> LAN使用的设备:以太网</a></h3><p>在局域网中使用的设备是以太网</p>
<h4 id="以太网速度与标准"><a href="#以太网速度与标准" class="headerlink" title="以太网速度与标准"></a>以太网速度与标准</h4><ul>
<li>10Mbps/100Mbps/1Gbps/10Gbps/100Gbps以太网</li>
<li>从10Gbps以太网标准包含7种不同类型,分别适用于局域网、城域网和广域网</li>
</ul>
<h4 id="以太网网线接口"><a href="#以太网网线接口" class="headerlink" title="以太网网线接口"></a>以太网网线接口</h4><ul>
<li>目前以太网最常见的接口是RJ-45,共有8芯。因为每条芯线的不同RJ4-5分为568A与568B接口</li>
<li>虽然RJ-45有8芯,实际使用的1,2,3,6芯</li>
<li>跳线:一边接568A,一边接568B时称为跳线,用于直接连接两部主机的网卡</li>
<li>平行线:两边同为568A或568B,用于连接主机与集线器的网卡</li>
</ul>
<h3 id="以太网的传输协议-CSMA-CD"><a href="#以太网的传输协议-CSMA-CD" class="headerlink" title=" 以太网的传输协议:CSMA/CD"></a><a name="ch2.3"> 以太网的传输协议:CSMA/CD</a></h3><p>以太网的传输主要就是网卡对网卡间的资料传递，每张网卡出厂时,都有独一无二的卡号,我们称为MAC(物理地址),其中传输遵循CSMA/CD协议</p>
<ul>
<li>CS:载波侦听<br>指任何连接到网络(LAN)上的设备在发送MAC帧前,先对网络进行监听,当通道空闲时,才发送</li>
<li>MA:多点传输<br>一个设备发送的帧会被网络上其他设备所接收,接收的设备根据帧中目的地址来判断是否要处理此帧</li>
<li>CD:碰撞检测<br>网络上帧碰撞时的一种解决方式,发送的帧具有检测功能,若网络上两帧发送碰撞损坏后,其发送端会随机等待一个时间再发送</li>
</ul>
<h3 id="链接层传输单位-帧及其最大传输量-MTU"><a href="#链接层传输单位-帧及其最大传输量-MTU" class="headerlink" title=" 链接层传输单位:帧及其最大传输量:MTU"></a><a name="ch2.4"> 链接层传输单位:帧及其最大传输量:MTU</a></h3><h4 id="链接层传输单位-帧"><a href="#链接层传输单位-帧" class="headerlink" title="链接层传输单位:帧"></a>链接层传输单位:帧</h4><p>CSMA/CD传输的单位就是帧(整个网络硬件上面传输资料的最小单位),一条网路一次只能通过一个帧,其内容如下
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_34_3_%E5%B8%A7.png?raw=true" alt=""></p>
<p>其中目的地址与来源地址就是MAC(物理地址),其范围是<code>00:00:00:00:00:00</code>到<code>FF:FF:FF:FF:FF:FF</code>（6bytes,前3bytes是厂商编号,后3bytes是厂商定义编号） <code>ifconfig</code>可以查到MAC</p>
<p>帧实际数据大小范围:46bytes-MTU(1500bytes)</p>
<h4 id="最大传输量-MTU"><a href="#最大传输量-MTU" class="headerlink" title="最大传输量:MTU"></a>最大传输量:MTU</h4><p>以太网标准能传输的实际数据最大量称为MTU,通常是1500bytes,当IP包过大时,就会将IP包拆包装进帧中.</p>
<p>虽然MTU可以扩大,其需要硬件支持,不仅是自身的设备,还要求接收端的设备支持,所有通常不扩张</p>
<h3 id="集线器与交换机"><a href="#集线器与交换机" class="headerlink" title=" 集线器与交换机"></a><a name="ch2.5"> 集线器与交换机</a></h3><p>集线器与交换机都是以太网常用的设备</p>
<p>集线器：接收到帧,并向所有端口广播出去
交换机: 交换机内部的CPU会在每个端口成功连接时,通过将其MAC地址和端口对应,形成一张MAC表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。</p>
<h2 id="TCP-IP协议-网络层"><a href="#TCP-IP协议-网络层" class="headerlink" title=" TCP/IP协议:网络层"></a><a name="ch3"> TCP/IP协议:网络层</a></h2><p>网络层提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。TCP/IP协议体系中的网络层功能由IP协议规定和实现，故又称IP层</p>
<h3 id="IP数据包"><a href="#IP数据包" class="headerlink" title=" IP数据包"></a><a name="ch3.1"> IP数据包</a></h3><p>前面谈到链接层传输的数据单位是帧,而网络层传输的是IP包,由于IP有不同版本,目前广泛使用的是IPv4,其使用32位表示IP地址(IPv6用128位表示IP地址)</p>
<p>以下是一个IPv4的数据包
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_34_4_IP%E5%8C%85.png?raw=true" alt=""></p>
<ul>
<li><code>Version</code>  IP包的版本,IPv4或IPv6</li>
<li><code>IHL(Internet Header Length)</code>  IP表头长度</li>
<li><code>Type of Service</code>  IP包的服务类型,如高传输T,高可靠R</li>
<li><code>Total Length</code> IP包总大小=表头+实际数据,最大达65535bytes</li>
<li><code>Identification</code> 识别码,用于表示IP包被拆包,分段后,这些小包是否属于同一个IP包</li>
<li><code>Flags</code> 特殊标志,D为0表可分段,1表不可分段等</li>
<li><code>Fragment Offset</code> IP分段在原始IP包中的偏移量</li>
<li><code>Time To Live(TTL)</code> IP包存活时间,取值范围为0-255,通过网络上一个路由器就减1,当TTL为0时,此包会被丢弃</li>
<li><code>Protocol Number</code> 协议代码 记录此包在传输层及网络层使用的协议是什么,如TCP=6，UDP=17等</li>
<li><code>Header Checksum</code> IP表头检查码,用于检查IP包表头的错误</li>
<li><code>Source Address</code> 来源IP地址</li>
<li><code>Destination Address</code> 目的IP地址</li>
<li><code>Options</code> 其他额外功能,如安全处理，路由记录</li>
<li><code>Padding</code> 由于IP每条资料必须是32bit,由于Options没有固定位数,所有Padding用于补齐</li>
</ul>
<h3 id="IP地址的组成与分级"><a href="#IP地址的组成与分级" class="headerlink" title=" IP地址的组成与分级"></a><a name="ch3.2"> IP地址的组成与分级</a></h3><p>如上面提到,IPv4由32位组成,其中我们又将这32位IP划分出Net_ID(用于标识网段)和Host_ID(用于标识同网段下的主机),为了方便记录,我们通常将这32位IP以每8位写成十进制来表示.如<code>11111111 11111111 11111111  @11111111</code>通常写成<code>255.255.255.255</code></p>
<p>我们将Host_ID全为0的IP用来标识某网段地址(Network IP),用Host_ID全为1来标识此网段的广播地址(Broadcast IP)</p>
<h4 id="IP与网段"><a href="#IP与网段" class="headerlink" title="IP与网段"></a>IP与网段</h4><p>前面我们提到Net_ID用于标识网段,首先我们需要明白,网段是在同一个物理网段上划分出来的,不是说你们两IP的Net_ID一样(前提是同一个物理网段)就可以广播通信</p>
<p>当我们确定在同一个网段时,可以通过CSMA/CD直接在此网段上广播自己的数据包出去</p>
<p>当我们确定在同一个物理网,不同的子网段上时,可以路由或者网关,将我们传送的包转交至其他网段上,然后在其他网段上广播到目的主机</p>
<h4 id="IP与门牌"><a href="#IP与门牌" class="headerlink" title="IP与门牌"></a>IP与门牌</h4><p>IP地址中的Net_ID就像我们的街道,Host_ID就像我们的门牌.而Host_ID全为0标识街道的地址,当我们要找街道上某户人时,我们可以在街道的广播设备(Host_ID全为1)上呼叫,目标听到后回应,而当我们写信给不同地方的朋友时,那只能通过邮局了(route),通过这个街道上的邮局都是用Host_ID全为1再减1后的IP来标识</p>
<h4 id="IP分级"><a href="#IP分级" class="headerlink" title="IP分级"></a>IP分级</h4><p>为了规范Net_ID的位数,于是我们将IP进行分级,其中A类IP为<code>0.0.0.0/8-127.255.255.255/8</code> B类IP为<code>128.0.0.0/16-191.255.0.0/16</code> C类IP为<code>192.0.0.0/24-223.255.255.255/24</code>,其中<code>IP/Num</code>的Num是Net_ID的位数</p>
<h3 id="IP的类别与取得方式"><a href="#IP的类别与取得方式" class="headerlink" title=" IP的类别与取得方式"></a><a name="ch3.3"> IP的类别与取得方式</a></h3><h4 id="IP类别"><a href="#IP类别" class="headerlink" title="IP类别"></a>IP类别</h4><p>上面是对IP进行分级,下面我们对IP进行分类,其可以分成公有IP和私有IP,而我们要连上Internet须使用公有IP,私有IP用来构建局域网来划分主机，如果要将私有IP送上Internet,需要架设防火墙与NAT服务</p>
<p>IPv4规划好的私有IP:
A类私有IP : <code>10.0.0.0 - 10.255.255.255</code>
B类私有IP : <code>172.16.0.0 - 172.31.255.255</code>
C类私有IP : <code>192.168.0.0 - 192.168.255.255</code></p>
<p>此外还有一个特殊的IP网段(loopback),用于本地测试使用,就是<code>127.0.0.0/8</code>,本地服务都是在此网段的主机上启动,如<code>127.0.0.1</code>这个IP</p>
<h4 id="IP取得方式"><a href="#IP取得方式" class="headerlink" title="IP取得方式"></a>IP取得方式</h4><ul>
<li>直接手动设置:向网关询问IP相关参数</li>
<li>通过拨号取得</li>
<li>自动取得网络参数(DHCP):在局域网内架设一部主机负责管理所有主机的网络参数</li>
</ul>
<h3 id="子网掩码-Netmask-与无类别域间路由-CIDR"><a href="#子网掩码-Netmask-与无类别域间路由-CIDR" class="headerlink" title=" 子网掩码(Netmask)与无类别域间路由(CIDR)"></a><a name="ch3.4"> 子网掩码(Netmask)与无类别域间路由(CIDR)</a></h3><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>由于我们默认使用的IP地址,可能Host_ID过多,实际使用时,我们并没有这么多主机(如一个A类IP可使用2^24-2个主机),假设我们有这么多主机,如果我们同时向这些主机广播一个数据包,也是很痛苦的一件事</p>
<p>所以我们将我们获取的IP地址再进一步划分出不同的子网段,来管理网络(其实就是从Host_ID中分出子网的ID位)</p>
<p>Netmask就是用32位IP地址中Net_ID全为1,Host_ID全为0来表示</p>
<p>假设我要对<code>192.168.0.0/24</code>这个IP地址划分出2个子网
可以这么做<code>Net_ID+1=24+1=25</code>,由于划分出两个网段,原本<code>192.168.0.0/24</code>有256个IP,每个网段有128个IP,
那么第1个网段地址(Network IP)是<code>192.168.0.0/25</code>  而其广播地址(Broadcast IP)是<code>192.168.0.127/25</code>
第2个网段地址是<code>192.168.0.128/25</code> 而其广播地址是<code>192.168.0.255</code>
子网掩码是<code>255.255.255.128</code></p>
<h4 id="无类别域间路由-CIDR"><a href="#无类别域间路由-CIDR" class="headerlink" title="无类别域间路由(CIDR)"></a>无类别域间路由(CIDR)</h4><p>打破原本IP分级,将Net_ID位用作Host_ID位,使得多个网段写成一个网段</p>
<h3 id="路由概念与查看本机路由表"><a href="#路由概念与查看本机路由表" class="headerlink" title=" 路由概念与查看本机路由表"></a><a name="ch3.5"> 路由概念与查看本机路由表</a></h3><h4 id="路由概念"><a href="#路由概念" class="headerlink" title="路由概念"></a>路由概念</h4><p>在同一个网段内,我们可以通过IP广播来传输数据,而如上面提到的,当你要在不同网段上传输数据时,这时就只能借助邮局(路由或网关)了,路由其实就是路径选择</p>
<p>我们以下图为例
<img src="https://raw.githubusercontent.com/HiKumho/blog/e2e4d7bdce0011158e87d7b8ad5d1ba8cdfe1eb1/img/blog_34_5_route.jpg" alt=""></p>
<p><code>192.168.0.0/24</code>与<code>192.168.1.0/24</code>是不同网段,当PC01传输资料给PC11,其流程如下
1. 查询IP包的目的IP地址
当PC01要传输IP包时,查询到IP包表头的目的IP地址</p>
<p>2. 查询本机的路由
PC01查看其的路由表,发现目的IP与自己处于同网段时,就会广播数据包出去</p>
<p>3. 查询默认路由器(default gateway)
本例中由于PC01与PC11在不同网段,所以PC01会将IP包发给其设置的路由器,由路由器处理此包,本例是server A</p>
<p>4. 路由器转交IP包到目的网段
路由器查看自己的路由信息,将PC01的IP包转交给<code>192.168.1.254</code>,并将IP包在此网段广播出去,给目的IP</p>
<p>由上我们可以知道,每台主机都存在一个路由表,而且会设置其默认的网关/路由器地址,用于不同网段间的通信</p>
<h4 id="查看本机路由表-route"><a href="#查看本机路由表-route" class="headerlink" title="查看本机路由表:route"></a>查看本机路由表:route</h4><p>我们可以使用route来查看本机的路由表,其中第1列是网段地址,而<code>default</code>来表示缺省的网段</p>
<h3 id="IP与MAC-ARP与RARP协议"><a href="#IP与MAC-ARP与RARP协议" class="headerlink" title=" IP与MAC:ARP与RARP协议"></a><a name="ch3.6"> IP与MAC:ARP与RARP协议</a></h3><p>我们知道,网络实际上是利用MAC来传输帧,并不是我们指定的IP,所以我们需要通过IP地址来获取MAC地址,则就是ARP协议</p>
<p>ARP协议:通过广播包含目标IP地址的ARP包出去,目标接收到此包后会返回其MAC地址,发送端接收到目标MAC地址后记录进ARP table中,并开始通信</p>
<p>RARP协议是MAC地址来获取IP地址</p>
<p>查看本机的MAC地址:<code>ifconfig</code></p>
<p>查看本机的ARP table: <code>arp</code></p>
<h3 id="反馈信息-ICMP协议"><a href="#反馈信息-ICMP协议" class="headerlink" title=" 反馈信息:ICMP协议"></a><a name="ch3.7"> 反馈信息:ICMP协议</a></h3><p>网络控制消息协定（Internet Control Message Protocol，ICMP）,通常用于返回的错误信息或是分析路由。ICMP错误消息总是包括了源数据并返回给发送者。 ICMP错误消息的例子之一是TTL值过期。每个路由器在转发数据报的时候都会把IP包头中的TTL值减一。如果TTL值为0，“TTL在传输中过期”的消息将会回报给源地址。 每个ICMP消息都是直接封装在一个IP数据包中的，因此，和UDP一样，ICMP是不可靠的。</p>
<h2 id="TCP-IP协议-传输层"><a href="#TCP-IP协议-传输层" class="headerlink" title=" TCP/IP协议:传输层"></a><a name="ch4"> TCP/IP协议:传输层</a></h2><p>网络层的IP只是负责将数据送到正确的目标上,而数据没有被接收,那是传输层的任务之一,传输层的封包分为连接导向的TCP封包,与非连接导向的UDP封包</p>
<h3 id="可靠连接的TCP协议"><a href="#可靠连接的TCP协议" class="headerlink" title=" 可靠连接的TCP协议"></a><a name="ch4.1"> 可靠连接的TCP协议</a></h3><p>通常传输层会将数据打包成TCP包,然后将其传入网络层,装入IP包中,TCP包/IP包/帧的关系如下图
<img src="https://raw.githubusercontent.com/HiKumho/blog/e15407def84c9f9ee3530a5eb70f26b0c7b1355c/img/blog_35_6_tcp_ip_mac%E5%8C%85.png" alt=""></p>
<p>TCP数据包如下
<img src="https://raw.githubusercontent.com/HiKumho/blog/a02208423e1bd1ce08e8ccf8d1d829795a4c0964/img/blog_35_7_tcp%E5%8C%85.png" alt=""></p>
<ul>
<li><code>source port &amp; destination port</code> ： 来源IP中的端口与目标IP中的服务端口,传输数据时,两个端口需要连接,其中一个IP与一个端口组成socket pair</li>
<li><code>sequence number</code>: TCP包比IP包大时,TCP包进行分段,sequence number就是每个分段的序号</li>
<li><code>acknoledge number</code>:回应代码</li>
<li><code>Data offset</code> 对<code>Options</code>的补齐,保证TCP包的大小</li>
<li><code>Reserved</code> 保留</li>
<li><code>Code</code> 控制码,好让接收端明白这个封包的动作<ul>
<li><code>ACK</code> 回应</li>
<li><code>SYN</code> 表示发送端希望与接收端建立同步连接</li>
<li><code>FIN</code> 表示传输结束</li>
<li><code>URG</code> 表示紧急包,接收端应紧急处理</li>
<li><code>PSH</code> 要求接收端立即传输缓存区的对应的包</li>
<li><code>RST</code> 强制结束连线</li>
</ul>
</li>
<li><code>Window</code> 主要用于控制包的流量</li>
<li><code>Checksum</code> 发送端发送资料前,进行检验动作,检验码写到此项中</li>
<li><code>Urgent pointer</code> 紧急资料，与<code>URG</code>对应,告知紧急资料所在位置</li>
<li><code>Options</code> 表示接收端可以接收的最大数据容量</li>
<li><code>Padding</code> 补齐包的大小</li>
</ul>
<h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title=" TCP的三次握手"></a><a name="ch4.2"> TCP的三次握手</a></h3><p>TCP被称为可靠的连线传输,是因为客服端与接收端建立在同步连接的基础上的,而同步连接是通过三次握手来实现,如下图
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_34_8_TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png?raw=true" alt=""></p>
<p>通过客服端发起SYN连线请求,服务端发起ACK/SYN请求,最后客服端回应ACK建立连接</p>
<h3 id="非连接导向的UDP协议"><a href="#非连接导向的UDP协议" class="headerlink" title=" 非连接导向的UDP协议"></a><a name="ch4.3"> 非连接导向的UDP协议</a></h3><p>在UDP传输过程中,不会建立连线,接收端在接收到包后不会回应(ACK)发送端,直接发送数据给与客服端,不管客服端是否正确接收到数据,UDP较为快速</p>
<p>UDP数据包如下
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_34_9_udp%E5%8C%85.png?raw=true" alt=""></p>
<h3 id="网络防火墙与OSI七层协议"><a href="#网络防火墙与OSI七层协议" class="headerlink" title=" 网络防火墙与OSI七层协议"></a><a name="ch4.4"> 网络防火墙与OSI七层协议</a></h3><p>防火墙针对OSI七层协议来说,每层可以抵挡的方面有:</p>
<ul>
<li>第二层: 可以针对来源与目标的MAC进行抵挡</li>
<li>第三层: 可以针对来源与目标的IP,以及ICMP的类别进行抵挡</li>
<li>第四层: 可以针对TCP/UDP的端口进行抵挡,也可以针对TCP的状态来处理</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 内核编译]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</url>
      <content type="html"><![CDATA[<h2 id="内核编译过程"><a href="#内核编译过程" class="headerlink" title=" 内核编译过程"></a><a name="ch1"> 内核编译过程</a></h2><h3 id="获取内核源文件"><a href="#获取内核源文件" class="headerlink" title=" 获取内核源文件"></a><a name="ch1.1"> 获取内核源文件</a></h3><p>通过Linux内核官网获取内核源文件: <a href="https://www.kernel.org/" target="_blank" rel="external">https://www.kernel.org/</a> 
(这里我下载到的是linux-4.8.0-rc3)</p>
<p>鸟哥说可以通过获取发行版本的内核源文件,由于自己没有找到,所以不能测试</p>
<h3 id="解压内核源文件"><a href="#解压内核源文件" class="headerlink" title=" 解压内核源文件"></a><a name="ch1.2"> 解压内核源文件</a></h3><p>因为内核文件是用tar的xz工具打包压缩的,xz压缩比比bz2还好,tar中使用-J来标识,解压内核文件到/usr/src中，操作如下
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -Jxv <span class="_">-f</span> linux-4.8.0-rc3 -C /usr/src/</div></pre></td></tr></table></figure> </p>
<h3 id="内核源文件目录"><a href="#内核源文件目录" class="headerlink" title=" 内核源文件目录"></a><a name="ch1.3"> 内核源文件目录</a></h3><p>解压下来的内核源文件,含有的目录说明</p>
<table>
<thead>
<tr>
<th style="text-align:center">目录</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">arch</td>
<td style="text-align:center">与硬件平台有关,大部分指CPU类型,例如x86，x86_64等,编译出的内核文件会在这里</td>
</tr>
<tr>
<td style="text-align:center">block</td>
<td style="text-align:center">与块设备有关的设置数据</td>
</tr>
<tr>
<td style="text-align:center">crypto</td>
<td style="text-align:center">内核所支持的加密技术,例如md5或des等</td>
</tr>
<tr>
<td style="text-align:center">Documentation</td>
<td style="text-align:center">与内核有关的帮助文档,对了解内核相对有用</td>
</tr>
<tr>
<td style="text-align:center">drivers</td>
<td style="text-align:center">一些硬件的驱动程序,如显卡,网卡等PCI相关硬件</td>
</tr>
<tr>
<td style="text-align:center">firmware</td>
<td style="text-align:center">一些旧式硬件的微指令数据</td>
</tr>
<tr>
<td style="text-align:center">fs</td>
<td style="text-align:center">内核所支持的文件系统</td>
</tr>
<tr>
<td style="text-align:center">include</td>
<td style="text-align:center">一些可让其他过程调用的头文件(定义数据)</td>
</tr>
<tr>
<td style="text-align:center">init</td>
<td style="text-align:center">一些内核初始化的定义功能,包括挂载与init程序的调用等</td>
</tr>
<tr>
<td style="text-align:center">ipc</td>
<td style="text-align:center">定义Linux操作系统内各程序的通信</td>
</tr>
<tr>
<td style="text-align:center">kernel</td>
<td style="text-align:center">定义内核程序/内核状态/进程信号量/程序调度等</td>
</tr>
<tr>
<td style="text-align:center">lib</td>
<td style="text-align:center">一些函数库</td>
</tr>
<tr>
<td style="text-align:center">mm</td>
<td style="text-align:center">与内存单元的有关数据包括swap与虚拟内存等</td>
</tr>
<tr>
<td style="text-align:center">net</td>
<td style="text-align:center">与网络有关的各项协议数据,还有防火墙模块(net/ipv4/netfilter)等</td>
</tr>
<tr>
<td style="text-align:center">security</td>
<td style="text-align:center">包括selinux等在内的安全性设置</td>
</tr>
<tr>
<td style="text-align:center">sound</td>
<td style="text-align:center">与音效有关的各项模块</td>
</tr>
<tr>
<td style="text-align:center">virt</td>
<td style="text-align:center">与虚拟化机器有关的信息,如KVM(Kernel-based Virtual Machine)</td>
</tr>
</tbody>
</table>
<h3 id="清理原编译文件和配置文件"><a href="#清理原编译文件和配置文件" class="headerlink" title=" 清理原编译文件和配置文件"></a><a name="ch1.4"> 清理原编译文件和配置文件</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make mrproper #清除.config</div><div class="line">make clean  # 清除目标文件</div></pre></td></tr></table></figure>
<p>make 会参考内核文件目录下的Makefile文件 执行相应的操作</p>
<h3 id="挑选内核功能"><a href="#挑选内核功能" class="headerlink" title=" 挑选内核功能"></a><a name="ch1.5"> 挑选内核功能</a></h3><p>执行<code>make menuconfig</code>会在终端显示一个菜单,帮助我们挑选需要的内核功能。
<code>make menuconfig</code>执行时如果报出如下的错误
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HOSTCC  scripts/kconfig/mconf.o</div><div class="line">In file included from scripts/kconfig/mconf.c:23:0:</div><div class="line">scripts/kconfig/lxdialog/dialog.h:38:20: fatal error: curses.h: 没有那个文件或目录</div></pre></td></tr></table></figure>
需要安装ncurses库,需先安装,操作如下
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</div></pre></td></tr></table></figure></p>
<p>关于内核功能的挑选,不明白时在相应的条目下按<code>h</code>有说明,其中<code>[*]</code>表示此条目功能会编译进内核,<code>[M]</code>表示此条目功能会编译成内核模块</p>
<p>挑选完内核功能后，<code>save</code>保存为配置文件<code>.config</code>,为后面编译准备</p>
<h3 id="编译内核与内核模块"><a href="#编译内核与内核模块" class="headerlink" title=" 编译内核与内核模块"></a><a name="ch1.6"> 编译内核与内核模块</a></h3><p>执行<code>make bzImage</code>编译压缩后的内核文件,其文件会输出为<code>arch/x86/boot/bzImage</code></p>
<p>如果在编译过程中出现<code>如arm-linux-gcc没有找到的相关错误</code>,需先安装ARM-Linux-GCC，执行操作<code>apt-get install gcc-arm-linux-gnueabi</code> 详细说明请看<a href="http://www.cnblogs.com/muyun/p/3370996.html" target="_blank" rel="external">Ubuntu安装ARM架构GCC工具链（ubuntu install ARM toolchain）最简单办法</a></p>
<p>执行<code>make modules</code>编译内核模块</p>
<h3 id="安装内核模块"><a href="#安装内核模块" class="headerlink" title=" 安装内核模块"></a><a name="ch1.7"> 安装内核模块</a></h3><p>执行<code>make modules_install</code>将前面编译号的内核模块安装至<code>/lib/modules</code>下的相应目录</p>
<h2 id="启动内核"><a href="#启动内核" class="headerlink" title=" 启动内核"></a><a name="ch2"> 启动内核</a></h2><p>以下要进行的操作是设置一个启动菜单项,引导新的内核启动。</p>
<p>由于我安装系统时/boot独立分区,而且容量不够大,所以下面的操作我会新建一个分区来安装grub引导程序及相应配置文件,由其启动新的内核</p>
<h3 id="新建分区-安装grub"><a href="#新建分区-安装grub" class="headerlink" title=" 新建分区,安装grub"></a><a name="ch2.1"> 新建分区,安装grub</a></h3><p>使用fdisk工具新建一个分区,并成功挂载至<code>/mnt/boot</code>目录下</p>
<p>使用grub-install安装grub,操作如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">grub-install --root-directory=/mnt/boot /dev/sda10 # 新建的分区是/dev/sda10</div></pre></td></tr></table></figure>
查看/mnt/boot目录会发现grub程序及配置文件成功安装，</p>
<p><b>其实可以不安装grub,不影响,但是仍需要挂载分区</b></p>
<p>由于MBR执行grub的主程序后,会调入其配置文件,所以需要将此分区在开机时挂载起来,修改<code>/etc/fstab</code>文件</p>
<h3 id="将内核文件移到新分区"><a href="#将内核文件移到新分区" class="headerlink" title=" 将内核文件移到新分区"></a><a name="ch2.2"> 将内核文件移到新分区</a></h3><p>记得我们编译好的内核文件是<code>/usr/src/linux-4.8.0-rc3/arch/x86/boot/bzImage</code>,将其移动至新分区,并改名为<code>vmlinuz-4.8.0-rc3</code>(查看我们/boot目录下的内核文件其命名方式也是vmlinuz-版本号)</p>
<h3 id="制作虚拟文件系统Initrd"><a href="#制作虚拟文件系统Initrd" class="headerlink" title=" 制作虚拟文件系统Initrd"></a><a name="ch2.3"> 制作虚拟文件系统Initrd</a></h3><p>我们需要先将<code>/usr/src/linux-4.8.0-rc3/.config</code>移动到/boot目录下,因为使用<code>mkinitramfs</code>工具会参考/boot目录的相应配置文件,注意需要将<code>.config</code>改名为<code>config-版本号</code>(版本号最好与/lib/modules下相应内核模块目录同样)</p>
<p>之后执行<code>mkinitramfs -o /mnt/boot/initrd-版本号 版本号</code></p>
<p>最后将<code>./config</code>移回/mnt/boot下(这个关系不大)</p>
<p>查看我的<code>/mnt/boot</code>目录有以下文件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">config-4.8.0-rc3-kumho-generic  </div><div class="line">vmlinuz-4.8.0-rc3-kumho-generic </div><div class="line">initrd-4.8.0-rc3-kumho-generic</div><div class="line">boot/</div></pre></td></tr></table></figure></p>
<h3 id="编辑grub菜单"><a href="#编辑grub菜单" class="headerlink" title=" 编辑grub菜单"></a><a name="ch2.4"> 编辑grub菜单</a></h3><p>grub2菜单项的标识是<code>menuentry</code>,由于我们只是加载新内核来启动系统,并没有需要改变根目录分区,所有可以直接打开<code>/boot/grub/grub.cfg</code>将第一个<code>menuentry</code>项复制到<code>/etc/grub.d/40_custom</code>文件里</p>
<p>修改其菜单名menuetry的属性值
修改其root属性值为新建分区(这里我修改为 <code>set root=&#39;hd0,msdos10&#39;</code>)
修改其linux属性值为<code>/vmlinuz-4.8.0-rc3-kumho-generic</code>,后接的启动参数可以不修改
修改其initrd属性值为<code>/initrd-4.8.0-rc3-kumho-generic</code></p>
<p>最后使用<code>grub-mkconfig -o /boot/grub/grub.cfg</code>输出新的grub.cfg</p>
<p>重新开机选择新菜单启动后执行<code>uname -r</code>查看当前内核</p>
<p>关于grub2.0配置文件详细说明请看<a href="http://linux.vbird.org/linux_basic/0510osloader.php#grub" target="_blank" rel="external">鸟哥私房菜–grub2.0配置文件</a></p>
<h3 id="启动内核时遇到的问题"><a href="#启动内核时遇到的问题" class="headerlink" title=" 启动内核时遇到的问题"></a><a name="ch2.5"> 启动内核时遇到的问题</a></h3><h4 id="request-module-runaway-loop-modprobe-binfmt-464c"><a href="#request-module-runaway-loop-modprobe-binfmt-464c" class="headerlink" title="request_module: runaway loop modprobe binfmt-464c"></a>request_module: runaway loop modprobe binfmt-464c</h4><p>这是我编译64位内核,启动内核后遇到的问题</p>
<p>网上找到相关资料
<a href="http://blog.sina.com.cn/s/blog_740ccd0401011ivx.html" target="_blank" rel="external">linux启动时出现request_module: runaway loop modprobe binfmt-464c</a></p>
<p>再按上面的步骤(在挑选内核功能时,cross compile prefix中写入arm-linux-)重新编译内核后,出现编译失败,缺少<code>arm-linux-gcc</code>库的原因,重新安装后(安装方法本文前面提到),解决问题</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 软件安装:软件管理(RPM/yum与DKPG/apt)]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86-RPM-yum%E4%B8%8EDKPG-apt/</url>
      <content type="html"><![CDATA[<p>关于软件管理可以参考<a href="http://blog.csdn.net/on_1y/article/details/8598385" target="_blank" rel="external">Linux 软件管理(RPM,Dpkg,APT)</a></p>
<p>这里对上文的SRPM进行补充
SRPM(Source RPM)，文件以SRPM打包会软件的源码以及相关配置文件，文件以“.src.rpm”为扩展名</p>
<p>当我们需要安装一个SRPM时，如果是按默认值来安装，可以直接使用
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpmbuild --rebuild *.src.rpm  #编译打包成RPM包</div></pre></td></tr></table></figure>
或
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpmbuild --recompile *.src.rpm  #在--rebuild基础上，安装RPM</div></pre></td></tr></table></figure></p>
<p>如果我们需要修改SRPM的设置文件，需要重新编译，执行以下步骤
1. 解包： rmp -i *.src.rpm
其会将SRPM包解压到以下目录内</p>
<table>
<thead>
<tr>
<th style="text-align:center">目录名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/usr/src/redhat/SPECS</td>
<td style="text-align:center">此软件的设置文件</td>
</tr>
<tr>
<td style="text-align:center">/usr/src/redhat/SOURCES</td>
<td style="text-align:center">存放此软件的源文件与config文件</td>
</tr>
<tr>
<td style="text-align:center">/usr/src/redhat/BUILD</td>
<td style="text-align:center">编译过程中的暂存数据</td>
<td>.</td>
</tr>
<tr>
<td style="text-align:center">/usr/src/redhat/RPMS</td>
<td style="text-align:center">经编译后释出的RPM文件</td>
</tr>
<tr>
<td style="text-align:center">/usr/src/redhat/SRPMS</td>
<td style="text-align:center">经编译后释出的SRPM文件</td>
</tr>
</tbody>
</table>
<p>由于系统差异，可能/usr/src/redhat这个目录有差别</p>
<p>2. 修改SPECS目录下的<em>.spec这个设置文件
关于 </em>.spec设置文件的语法,请看以下链接</p>
<p><a href="http://linux.vbird.org/linux_basic/0520rpm_and_srpm.php#srpmmanager_config" target="_blank" rel="external">鸟哥的Linux私房菜–SRPM的spec设置</a></p>
<p>3. 再编译：rpmbuild (-ba|-bb) *.spec
根据 spec文件对整个目录内的文件进行再编译，<code>-ba</code>是释出RPM与SRPM包 而<code>-bb</code>仅释出RPM包</p>
<p>4. 之后可以通过<code>rpm -ivh</code>来安装RPM包</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 软件安装:源码与Tarball]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-%E6%BA%90%E7%A0%81%E4%B8%8ETarball/</url>
      <content type="html"><![CDATA[<h2 id="开放源码的软件安装及升级"><a href="#开放源码的软件安装及升级" class="headerlink" title=" 开放源码的软件安装及升级"></a><a name="ch1"> 开放源码的软件安装及升级</a></h2><h3 id="什么是源码-编译程序-可执行文件"><a href="#什么是源码-编译程序-可执行文件" class="headerlink" title=" 什么是源码/编译程序/可执行文件"></a><a name="ch1.1"> 什么是源码/编译程序/可执行文件</a></h3><ul>
<li>源码：遵循某些编译器能识别的语法,编写的一种特殊的纯文本文件</li>
<li>编译程序：源文件到目标文件到可执行文件的过程。<ul>
<li>编译：源文件→目标文件(机器代码或接近机器代码)</li>
<li>链接：目标文件与调用函数或其他目标文件链接整合成可执行文件</li>
</ul>
</li>
<li>可执行文件：二进制程序(shell script并不是程序，其可执行,但只是调用shell的命令或外部的程序)</li>
</ul>
<h3 id="什么是函数库"><a href="#什么是函数库" class="headerlink" title=" 什么是函数库"></a><a name="ch1.2"> 什么是函数库</a></h3><p>函数库：类似子程序的角色，用来调用其某个功能，Linux中一般位于<code>/usr/include</code> <code>/lib</code> <code>/usr/lib</code>中，可以分为静态函数库与动态函数库</p>
<ul>
<li>静态函数库：<ul>
<li>扩展名为.a</li>
<li>编译过程，直接整合到执行文件中，使用静态函数库编译成的文件较大</li>
<li>静态函数库编译成的文件可独立运行</li>
<li>只有静态函数库升级了，使用静态函数库编译出的文件要升级时，只能重新编译</li>
</ul>
</li>
<li>动态函数库<ul>
<li>扩展名为.so</li>
<li>编译过程，不整合到文件中，只提供执行程序一个指向</li>
<li>动态函数编译成的程序不可独立运行，需要动态库</li>
<li>升级动态库，不影响编译出来的程序</li>
</ul>
</li>
</ul>
<p>Linux 倾向使用动态函数库，这样升级方便。</p>
<h4 id="动态函数库加载至内存"><a href="#动态函数库加载至内存" class="headerlink" title=" 动态函数库加载至内存"></a><a name="ch1.2.1"> 动态函数库加载至内存</a></h4><p>我们可以使用ldconfig将动态函数库加载至内存中，这样其他程序调用其函数时，更加有效率
首先将需要加载至内存中的动态函数库目录写到<code>/etc/ld.so.conf</code>中，再执行<code>ldconfig</code>，如果要查看当前内存加载的动态函数库可以使用<code>ldconfig -p</code></p>
<h4 id="解析程序的动态函数库：ldd"><a href="#解析程序的动态函数库：ldd" class="headerlink" title=" 解析程序的动态函数库：ldd"></a><a name="ch1.2.2"> 解析程序的动态函数库：ldd</a></h4><p>当我们想了解一个程序使用什么动态函数库时，可以调用<code>ldd 程序的绝对路径</code>
想了解一个动态函数库的详细信息（比如依赖关系，版本等），可以调用<code>ldd -v 函数库的绝对路径</code></p>
<h3 id="什么是make与configure"><a href="#什么是make与configure" class="headerlink" title=" 什么是make与configure"></a><a name="ch1.3"> 什么是make与configure</a></h3><ul>
<li>make：是编译源文件的一个工具，我们按照一定的规则编写makefile文件，make将按照makefile把程序源文件编译成可执行文件。当然其需要编译器（如gcc）的支持</li>
<li>configure：会检测操作系统环境，是否能支持此程序安装，如果支持则是写出makefile文件，供make使用。（通常开放源码的软件后，提供configure这个shell script）</li>
</ul>
<h3 id="什么是软件的tarball及其安装过程"><a href="#什么是软件的tarball及其安装过程" class="headerlink" title=" 什么是软件的tarball及其安装过程"></a><a name="ch1.4"> 什么是软件的tarball及其安装过程</a></h3><h4 id="软件的tarball"><a href="#软件的tarball" class="headerlink" title=" 软件的tarball"></a><a name="ch1.4.1"> 软件的tarball</a></h4><p>软件释出时使用tar工具进行打包压缩项目文件，形成的打包文件我们称为tarball，一般这个tarball文件会有</p>
<ul>
<li>源文件</li>
<li>检测程序文件（config或configure等）</li>
<li>本软件的简要说明（INSTALL或README）</li>
</ul>
<h4 id="软件的tarball安装过程"><a href="#软件的tarball安装过程" class="headerlink" title=" 软件的tarball安装过程"></a><a name="ch1.4.2"> 软件的tarball安装过程</a></h4><ol>
<li>从软件官网下载tarball文件</li>
<li>解压tarball文件</li>
<li>以gcc进行源码的编译（生成目标文件）</li>
<li>以gcc进行函数库，目标文件的链接，形成主要的执行程序</li>
<li>将执行程序和相关的配置文件放置合适的目录内</li>
</ol>
<p>因为我们可以使用make与configure来简化上面的第3与第4个步骤，所以安装过程变为</p>
<ol>
<li>下载tarball，并解压</li>
<li>在解压的目录里找到configure或config，并执行，通常是<code>config --prefix=安装目录</code>，生成makefile文件</li>
<li>make根据makefile文件执行相应的操作，如<code>make clean</code> <code>make main</code> <code>make install</code>等</li>
<li>安装完毕，目标执行文件已安装到第2步执行的安装目录中</li>
</ol>
<p>如下图描述通过configure与make进行安装的过程
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_31_1.gif?raw=true" alt=""></p>
<h4 id="ntp的tarball安装例子"><a href="#ntp的tarball安装例子" class="headerlink" title=" ntp的tarball安装例子"></a><a name="ch1.4.3"> ntp的tarball安装例子</a></h4><p>以ntp这个时间服务软件为例子，验算安装tarball的过程
1. 下载解压ntp的tarball文件，并查看README/INSTALL
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxv <span class="_">-f</span> ntp-4.2.8p8.tar.gz -C ./</div></pre></td></tr></table></figure></p>
<p>2. 检查configure支持的参数，并生成makefile文件
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ntp</div><div class="line">./configure --help</div><div class="line">./configure --prefix=/usr/<span class="built_in">local</span>/ntp --enable-all-clocks --enable-parse-clocks <span class="comment">#--prefix指定安装目录</span></div></pre></td></tr></table></figure></p>
<p>3. 最后编译安装
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">make clean <span class="comment">#清除之前编译的文件</span></div><div class="line">make </div><div class="line">make install <span class="comment"># 将编译好的程序移到指定目录</span></div></pre></td></tr></table></figure></p>
<p>make与makefile请看<a href="#ch2.2">2.1 make的宏编译</a></p>
<h3 id="软件的tarball的升级"><a href="#软件的tarball的升级" class="headerlink" title=" 软件的tarball的升级"></a><a name="ch1.5"> 软件的tarball的升级</a></h3><p>因为软件以tarball的形式释出，所以我们升级软件时，有很大的自由度。我们可以通过官方释出的补丁文件，再利用patch文件来升级软件</p>
<h4 id="怎么制作补丁文件"><a href="#怎么制作补丁文件" class="headerlink" title=" 怎么制作补丁文件"></a><a name="ch1.5.1"> 怎么制作补丁文件</a></h4><p>我们以hellov1.c与其v2版的hellov2.c为例，通过调用diff工具即可 <code>diff -Naur fromFile toFile</code>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">diff -Naur hellov1.c hellov2.c &gt; hellov1Tov2.patch</div></pre></td></tr></table></figure>
这样我们就成功做出hellov1升级到v2的补丁文件</p>
<h4 id="文件打补丁"><a href="#文件打补丁" class="headerlink" title=" 文件打补丁"></a><a name="ch1.5.2"> 文件打补丁</a></h4><p>我们以hellov1Tov2.patch补丁更新hellov1.c，我们先查看hellov1Tov2.patch的内容
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">--- helloV1.c 2016-08-21 21:30:19.038816459 +0800</div><div class="line">+++ helloV2.c 2016-08-21 21:31:18.262816949 +0800</div><div class="line">@@ -2,6 +2,7 @@</div><div class="line"> </div><div class="line"> int main()</div><div class="line"> &#123;</div><div class="line">+ printf(&quot;This 2nd Version\n&quot;);</div><div class="line">  printf(&quot;Hello World!\n&quot;);</div><div class="line">  return 0;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
因为我们是在helloV1.c与helloV2.c的目录下做出这个补丁文件的，所以其描述的文件都是相对路径
如果我们在使用diff时用其他路径来描述这两个文件，比如<code>diff /home/user/helloV1.c /home/usr/helloV2.c</code>,那其做出来的补丁文件应该会用绝对路径来描述文件，这里会影响patch</p>
<p>我们还是以之前的patch文件为例，我们cd到helloV1.c的目录，通过调用<code>patch -p0 &lt;hellov1Tov2.patch</code>,就将helloV1升级到V2，如果要还原，则使用<code>patch -R &lt;hellov1Tov2.patch</code></p>
<p>如果补丁文件是使用绝对路径来描述的，我们可以通过<code>patch -pNum</code>来描述这个原文件的所在，比如/home/user/helloV1.C <code>-p1</code>表示当前工作目录下<code>home/user/helloV1.C</code> <code>-p2</code>表示当前工作目录下<code>user/helloV1.C</code> <code>-pNum</code>的Num是表示去掉多少层父目录</p>
<h2 id="gcc编译器与make的宏编译"><a href="#gcc编译器与make的宏编译" class="headerlink" title=" gcc编译器与make的宏编译"></a><a name="ch2"> gcc编译器与make的宏编译</a></h2><h3 id="gcc编译器的常见命令"><a href="#gcc编译器的常见命令" class="headerlink" title=" gcc编译器的常见命令"></a><a name="ch2.1"> gcc编译器的常见命令</a></h3><p><code>gcc -c hello.c</code>  # 对hello.c进行编译，生成目标文件hello.o</p>
<p><code>gcc -O -c hello.c</code> # 在上面操作的基础上，进行优化</p>
<p><code>gcc -o hello hello.o hello2.o</code> # 对hello.o hello2.o进行链接，生成执行程序hello</p>
<p><code>gcc -o hello hello.o hello2.o -lm -L /usr/lib -I /usr/include</code> # 在上面操作的基础上，<code>-lm</code>表示添加函数库或头文件 <code>-L</code>是函数库所在的路径 <code>-I</code>是头文件所在的路径</p>
<p><code>gcc -o hello hello.c -Wall</code> # 对hello.c进行编译链接成hello，并将警告信息显示出来</p>
<h3 id="make的宏编译"><a href="#make的宏编译" class="headerlink" title=" make的宏编译"></a><a name="ch2.2"> make的宏编译</a></h3><p><code>make</code>会参考<code>makefile</code>文件来进行编译链接，make有这些特点</p>
<ul>
<li>简化编译时所需的执行命令</li>
<li>若编译完成后，修改某源文件，则make仅会针对被修改的文件进行编译，其他目标文件不会被更改</li>
<li>最后依照相关性来更新执行文件</li>
<li>而且还有使用shell的命令</li>
</ul>
<h4 id="makefile的基本语法与变量"><a href="#makefile的基本语法与变量" class="headerlink" title=" makefile的基本语法与变量"></a><a name="ch2.2.1"> makefile的基本语法与变量</a></h4><p><b>makefile的基本语法是这样的</b>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 备注</div><div class="line">target : 目标文件1 目标文件2....</div><div class="line">&lt;TAB&gt; 执行命令</div></pre></td></tr></table></figure>
target是我们make可执行的一个操作名，target为main是make的默认操作名</p>
<p>例如下面这个例子
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">main ： hello.o hellov2.o</div><div class="line">      gcc -o hello hello.o hellov2.o</div><div class="line"></div><div class="line">clean : </div><div class="line">       rm -r hello hello.o hellov2.o</div></pre></td></tr></table></figure>
我们可以通过<code>make main</code>来编译<code>hello.c</code>与<code>hellov2.c</code>，通过<code>make clean</code>来删除执行文件与目标文件</p>
<p><b>makefile的变量语法与shell类似，但有区别：</b></p>
<ul>
<li>定义变量时，变量名与内容以<code>=</code>隔开，同时两边都要有空格，而且不能有<code>：</code>，变量名左边不能有<tab></tab></li>
<li>调用变量时，以${变量名}或$(变量名)使用</li>
<li>习惯上，变量名以大写</li>
<li>特殊的变量：<ul>
<li><code>$@</code> 表示当前的target</li>
<li><code>CFLAGS</code> gcc的操作选项标识符</li>
</ul>
</li>
<li>环境变量优先度：<ul>
<li>make命令行后面接的环境变量为最优先</li>
<li>其次是makefile指定的环境变量</li>
<li>最后是shell原本具有的环境变量</li>
</ul>
</li>
</ul>
<p>将上面的makefile例子用变量重写
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LIBS = -lm</div><div class="line">OBJS = hello.o hellov2.o</div><div class="line">CFLAGS = -Wall</div><div class="line">main ： $&#123;OBJS&#125;</div><div class="line">    gcc -o hello $&#123;OBJS&#125; $&#123;LIBS&#125;</div><div class="line">clean :</div><div class="line">    rm -r hello $&#123;OBJS&#125;</div></pre></td></tr></table></figure></p>
<h2 id="检验软件或文件的正确性"><a href="#检验软件或文件的正确性" class="headerlink" title=" 检验软件或文件的正确性"></a><a name="ch3"> 检验软件或文件的正确性</a></h2><p>当我们下载一个软件时，官网若提供了MD5或SHA1的指纹编码，我们可以下载好软件，通过md5sum或sha1sum来检验这个下载完的软件的正确性，用<code>md5sum 文件名</code>或<code>sha1sum 文件名</code>，其会返回一个指纹码，然后我们把这个指纹码与官网的指纹码进行匹配，一样则下载的文件无误。</p>
<p>我们也可以用md5sum 或sha1sum来获取文件某一时刻的指纹，当文件在我们不知情时被改动，只有再此获取其指纹，与之前的指纹匹配，就可以知道其文件有误</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 系统启动]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/</url>
      <content type="html"><![CDATA[<h2 id="Linux启动流程"><a href="#Linux启动流程" class="headerlink" title=" Linux启动流程"></a><a name="ch1"> Linux启动流程</a></h2><p>Linux启动的过程如下:</p>
<ol>
<li>加载BIOS的硬件信息与进行自我测试,并依据设置取得第一个可启动的设备</li>
<li>读取并执行硬盘第一扇区中MBR的boot loader程序(即grub,spfdisk等)</li>
<li>依据boot loader的设置加载内核,内核会再次检测硬件信息与加载驱动程序</li>
<li>在硬件驱动成功后,内核会主动调用init进程,并对init初始化配置(/etc/inittab)</li>
<li>init执行/etc/rc.d/rc.sysinit文件来准备操作系统环境(如网络/时区等)</li>
<li>init执行run-level的各服务启动</li>
<li>init执行/etc/rc.d/rc.local</li>
<li>init执行终端模拟程序mingetty来启动login进程,等待用户登录</li>
</ol>
<p>详细描述:</p>
<ul>
<li>BIOS,开机自我测试与MBR<ul>
<li>系统加载BIOS,通过BIOS去加载CMOS信息,获取各项硬件的配置信息</li>
<li>BIOS检测硬件,定义出可启动的设备顺序,读取MBR中的数据(boot loader)</li>
</ul>
</li>
<li>Boot loader的功能<ul>
<li>不同操作系统的文件格式不一致,其有属于自己的boot loader</li>
<li>必须要通过其的boot loader才能加载内核,boot loader可以识别多个文件系统</li>
<li>boot loader只能安装在MBR或分区的启动扇区中</li>
<li>安装操作系统时,会将其的boot loader都写在MBR和其启动扇区中</li>
<li>boot loader提供菜单/加载内核/转交其他loader的功能</li>
</ul>
</li>
<li>加载内核,检测硬件与initrd功能<ul>
<li>boot loader读取内核后,内核开始测试与驱动设备,并重新检测硬件(内核文件放置/boot/vmlinuz)</li>
<li>内核还会动态加载独立出来的内核模块,其在/lib/modules中(/lib不能与根目录不同分区)</li>
<li>一些内核模块有USB,SATA等硬盘设备驱动等,但是我们要读取硬盘中/lib/modules,这里形成了个悖论</li>
<li>Linux使用虚拟文件系统(initrd)解决上述的问题,其在/boot/initrd中,包含有Linux启动所需的模块(如硬盘驱动),通过先启动系统,在挂载根目录,读取硬盘中模块,再加载实际系统</li>
</ul>
</li>
</ul>
<p>下图是BIOS/Boot loader/内核的启动阶段
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_30_1.jpg?raw=true" alt=""></p>
<h2 id="Boot-loader-Grub"><a href="#Boot-loader-Grub" class="headerlink" title=" Boot loader:Grub"></a><a name="ch2"> Boot loader:Grub</a></h2><h3 id="boot-loader的两个阶段"><a href="#boot-loader的两个阶段" class="headerlink" title=" boot loader的两个阶段"></a><a name="ch2.1"> boot loader的两个阶段</a></h3><p>由于MBR只有446字节,boot loader的代码与配置数据就大于446字节,所以Linux将loader的启动分为两个阶段</p>
<h4 id="执行loader的主程序"><a href="#执行loader的主程序" class="headerlink" title="执行loader的主程序"></a>执行loader的主程序</h4><p>MBR仅安装boot loader的最小主程序,并没有安装loader的相关配置文件</p>
<h4 id="主程序加载配置文件"><a href="#主程序加载配置文件" class="headerlink" title="主程序加载配置文件"></a>主程序加载配置文件</h4><p>主程序加载所有配置文件与相关环境参数(/boot/grub)中</p>
<h3 id="grub的配置文件"><a href="#grub的配置文件" class="headerlink" title=" grub的配置文件"></a><a name="ch2.2"> grub的配置文件</a></h3><p>grub可以动态查找配置,无需在修改grub配置文件后重新安装grub</p>
<p>####grub1的配置文件/boot/grub/menu.lst
grub中硬盘与分区的代号的规则</p>
<ul>
<li>硬盘代号以()括起来</li>
<li>以hd表示硬盘,后面会接一组数字</li>
<li>以“查找顺序”作为硬盘的编号,而不是依照硬盘插入的接口排序</li>
<li>第一块找到的硬盘为0,第二个为1号,以此类推</li>
<li>每个硬盘的第一个分区为0,以此类推</li>
<li>比如(hd0,0)表示查找的第一块硬盘第一分区,(hd1,1)查找到的第二块硬盘第二分区</li>
</ul>
<p>/boot/grub/menu.lst配置文件:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">default=0  #默认启动的菜单项</div><div class="line">timeout=5  #若5秒内不动键盘,则用默认菜单项启动</div><div class="line">title CentOS  # 第1个菜单项</div><div class="line">   root (hd0,0)  # /boot所在的硬盘分区</div><div class="line">   kernel /vmlinuz-2.6.18-92 root=/dev/sda2 rhgb quiet  #内核文件(相对与/boot所在) 以及 根目录所在分区 与启动参数</div><div class="line">   initrd /intrd-2.6.18-92.img  # initrd文件(相对与/boot所在)</div></pre></td></tr></table></figure></p>
<p>####grub2的配置文件/boot/grub/grub.cfg
grub2不希望用户直接修改grub.cfg文件,而是通过修改/etc/default/grub文件后,调用grub-mkconfig来影响grub.cfg</p>
<p>grub2的硬盘分区号从1开始,菜单项关键字不是title 而是menuentry</p>
<p>关于grub2详细介绍请看以下链接
<a href="http://linux.vbird.org/linux_basic/0510osloader.php#grub" target="_blank" rel="external">鸟哥的Linux私房菜-Grub2</a></p>
<h3 id="grub的安装"><a href="#grub的安装" class="headerlink" title=" grub的安装"></a><a name="ch2.3"> grub的安装</a></h3><p>如果要从其他boot loader转到grub时,需要进行以下步骤:</p>
<ol>
<li>先使用grub-install安装grub(安装第二阶段需要的配置文件)</li>
<li>编写grub的配置文件menu.lst或grub.cfg</li>
<li>通过grub shell将主程序安装到系统中,如MBR(hd0),或分区启动扇区(hd0,0)等(安装第一阶段需要的主程序),以下是执行grub 进入grub shell的命令<ul>
<li>用root (hdx,x)选择含有grub目录的分区代号</li>
<li>用 find /boot/vmlinuz 测试内核文件是否存在</li>
<li>用 setup (hdx,x) 或setup (hdx),将ggrub安装在启动扇区或者MBR中</li>
<li>quit 退出grub shell</li>
</ul>
</li>
</ol>
<h3 id="initrd文件的创建"><a href="#initrd文件的创建" class="headerlink" title=" initrd文件的创建"></a><a name="ch2.4"> initrd文件的创建</a></h3><p>initrd包含Linux系统启动必要的内核模块,当原本的initrd含有的模块不能满足我们需要时,可以通过重新创建一个含有新模块的initrd文件
<code>mkinitrd --with=模块名称 initrd文件名 内核版本</code> </p>
<h2 id="init进程"><a href="#init进程" class="headerlink" title=" init进程"></a><a name="ch3"> init进程</a></h2><p>在内核加载驱动完成后,内核会主动调用init进程(/sbin/init),来完成系统的初始化,init会参考配置文件/etc/inittab来工作,inittab可以设置Linux的运行等级(模块,run level)</p>
<h3 id="第一进程init的配置文件与run-level"><a href="#第一进程init的配置文件与run-level" class="headerlink" title=" 第一进程init的配置文件与run level"></a><a name="ch3.1"> 第一进程init的配置文件与run level</a></h3><p>####run level
run level分为7个等级,可以用runlevel显示当前的等级,与init来切换等级</p>
<ul>
<li>0 直接关机</li>
<li>1 单用用维护模式,用在系统出问题时维护</li>
<li>2 类似3level,无NFS服务</li>
<li>3 完整含有网络功能的纯文本模式</li>
<li>4 系统保留</li>
<li>5 类似3level X window</li>
<li>6 重启</li>
</ul>
<p>Ubuntu默认的[2-5]level是一样功能的</p>
<h4 id="etc-inittab配置文件"><a href="#etc-inittab配置文件" class="headerlink" title="/etc/inittab配置文件"></a>/etc/inittab配置文件</h4><p>/etc/inittab每行用：分隔字段,一共有4个字段,如下格式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[设置选项]:[run level]:[init的操作行为]:[命令选项]</div></pre></td></tr></table></figure></p>
<ul>
<li>设置选项:最多4个字符,代表init的主要工作选项,只是一个简单的代表说明</li>
<li>run level:此选项在哪个run level执行,如35就是在3/5level下执行</li>
<li>init操作行为:<ul>
<li><code>initdefault</code>：代表默认的run level设置值</li>
<li><code>sysinit</code> : 系统初始化的操作选项</li>
<li><code>ctrlaltdel</code> : 代表[ctl]+[alt]+[del]是否可以重新启动的设置</li>
<li><code>wait</code> : 代表后面接的命令须执行完才能继续做下面的选项设置</li>
<li><code>respawn</code> 代表后面接的命令可以无限重新启动</li>
</ul>
</li>
<li>命令选项 ： 即将要执行的命令</li>
</ul>
<p>一个/etc/inittab的例子
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">id：5：initdefault：     #设置默认的run level</div><div class="line"></div><div class="line">si：：syinit：/etc/rc.d/rc.sysinit   # 准备操作系统的环境</div><div class="line"></div><div class="line">10：0：wait：/etc/rc.d/rc 0   #设置run level 0 需要启动/关闭的服务文件在哪</div><div class="line">11：1：wait：/etc/rc.d/rc 1</div><div class="line"></div><div class="line">1 ： 2345 ：respawn：/sbin/mingetty tty1 #设置tty1的终端</div><div class="line">2 ： 2345 ：respawn：/sbin/mingetty tty2 #设置tty2的终端</div><div class="line"></div><div class="line">x : 5：respawn :/etc/X11/prefdm -nodaemon # 设置x window服务</div></pre></td></tr></table></figure></p>
<h3 id="init准备操作系统环境-etc-rc-d-rc-sysinit"><a href="#init准备操作系统环境-etc-rc-d-rc-sysinit" class="headerlink" title=" init准备操作系统环境:/etc/rc.d/rc.sysinit"></a><a name="ch3.2"> init准备操作系统环境:/etc/rc.d/rc.sysinit</a></h3><p>init在开始加载各项系统服务之前,得先设置好整个系统环境，主要利用/etc/rc.d/rc.sysinit这个script来设置系统环境,有以下的工作:</p>
<ul>
<li>取得网络环境与主机类型</li>
<li>测试与挂载内存设备/proc及USB设备/sys</li>
<li>决定是否启动SELinux</li>
<li>启动随机数生成器,做一些密码加密的演算</li>
<li>设置终端的字体</li>
<li>设置显示启动中的欢迎界面</li>
<li>设置系统时间与时区</li>
<li>用户自定义模块的加载</li>
<li>加载内核相关设置</li>
<li>设置主机名与初始化电源管理模块</li>
<li>初始化磁盘阵列</li>
<li>初始化LVM</li>
<li>以fsck检测磁盘文件系统</li>
<li>进行磁盘配额(quota)</li>
<li>重新以可读写模式挂载磁盘</li>
<li>清除启动过程产生的临时文件</li>
<li>将启动信息写到日志文件</li>
</ul>
<h3 id="Upstart方式的init"><a href="#Upstart方式的init" class="headerlink" title=" Upstart方式的init"></a><a name="ch3.3"> Upstart方式的init</a></h3><p>前面介绍的init是System V方式启动的,现在的init是基于Upstart方式启动,所以你在查找/etc/inittab与/etc/rc.d/rc.sysinit应该找不到,只不过你新建/etc/inittab,upstart的init会优先参考其设置</p>
<p>详细的请看以下链接
<a href="http://www.cnblogs.com/cassvin/archive/2011/12/25/ubuntu_init_analysis.html" target="_blank" rel="external">upstart的init</a></p>
<h3 id="启动系统服务-etc-rcN-d"><a href="#启动系统服务-etc-rcN-d" class="headerlink" title=" 启动系统服务(/etc/rcN.d/)"></a><a name="ch3.4"> 启动系统服务(/etc/rcN.d/)</a></h3><p>各run level的需要启动/关闭的系统服务都在各自的/etc/rcN.d/下,比如/etc/rc5.d这个目录</p>
<p>其下会含有以K或S开头的文件,其是连接文件,连接到实际的服务启动脚本文件
K或S后接的数字是其执行顺序,系统会先执行K文件，再执行S文件
实际的执行操作会以/etc/rc5.d/K<em>  stop 或/etc/rc5.d/S</em> start 进行</p>
<h3 id="定义系统开机执行命令-etc-rc-d-rc-local"><a href="#定义系统开机执行命令-etc-rc-d-rc-local" class="headerlink" title=" 定义系统开机执行命令(/etc/rc.d/rc.local)"></a><a name="ch3.5"> 定义系统开机执行命令(/etc/rc.d/rc.local)</a></h3><p>我们只需将命令或脚本文件的绝对路径写入/etc/rc.d/rc.local中,系统在完成系统服务工作后,将会执行rc.local中的命令</p>
<h2 id="内核与内核模块"><a href="#内核与内核模块" class="headerlink" title=" 内核与内核模块"></a><a name="ch4"> 内核与内核模块</a></h2><p>内核与内核模块放在哪？</p>
<ul>
<li>内核:/boot-vmlinuz</li>
<li>内核解压所需RAM Disk：/boot/initrd</li>
<li>内核模块：/lib/modules/version/kernel</li>
<li>内核源码：/usr/src/linux或/usr/src/kernels</li>
<li>内核版本 ： /proc/version</li>
<li>系统内核功能：/proc/sys/kernel</li>
</ul>
<h3 id="查看目前内核加载的模块-lsmod"><a href="#查看目前内核加载的模块-lsmod" class="headerlink" title=" 查看目前内核加载的模块:lsmod"></a><a name="ch4.1"> 查看目前内核加载的模块:lsmod</a></h3><p>lsmod会列出目前内核加载了的模块,显示的内容包括模块名称,大小以及此模块是否被其他模块使用</p>
<h3 id="内核模块的依赖性"><a href="#内核模块的依赖性" class="headerlink" title=" 内核模块的依赖性"></a><a name="ch4.2"> 内核模块的依赖性</a></h3><p>内核模块目录基本上会依照下面几个子目录来分类：</p>
<ul>
<li>arch 与硬件平台有关,如CPU等级等</li>
<li>crypto 内核所支持的加密技术,如MD5</li>
<li>drivers 一些硬件驱动程序,如显卡,网卡,PCI等</li>
<li>fs  内核所支持的文件系统</li>
<li>lib 函数库</li>
<li>net 与网络有关的各项协议数据,还有防火墙模块</li>
<li>sound 与音效有关的各项模块</li>
</ul>
<p>当我们需要添加内核模块时,将内模模块放置相应的分类目录下,在利用depmod制作一个modules.dep文件来描述内核模块的依赖性,为接下来的处理内核模块操作</p>
<h3 id="内核模块的添加删除-modprobe"><a href="#内核模块的添加删除-modprobe" class="headerlink" title=" 内核模块的添加删除:modprobe"></a><a name="ch4.3"> 内核模块的添加删除:modprobe</a></h3><p>添加内核模块：modprobe 模块名
删除内核模块 ： modprobe -r 模块名
modprobe会去参考modules.dep文件</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 认识与分析日志文件]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%88%86%E6%9E%90%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="  日志文件"></a><a name="ch1">  日志文件</a></h2><h3 id="Linux常见日志文件"><a href="#Linux常见日志文件" class="headerlink" title="  Linux常见日志文件"></a><a name="ch1.1">  Linux常见日志文件</a></h3><table>
<thead>
<tr>
<th style="text-align:center">日志文件</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/var/log/cron</td>
<td style="text-align:center">例行工作日志</td>
</tr>
<tr>
<td style="text-align:center">/var/log/dmesg</td>
<td style="text-align:center">内核检测过程中分析的系统硬件信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/lastlog</td>
<td style="text-align:center">记录系统上账号最近一次登录的信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/mailog或/var/log/mail/*</td>
<td style="text-align:center">记录邮件往来信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/messages</td>
<td style="text-align:center">系统发生的重要信息(比如错误信息)</td>
</tr>
<tr>
<td style="text-align:center">/var/log/secure</td>
<td style="text-align:center">记录涉及到输入用户账号密码时的信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/wtmp,/var/log/failog</td>
<td style="text-align:center">记录正确登录的用户信息,记录错误登录的用户信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/httpd/<em>,/var/log/news/</em>,/var/log/samba/*…</td>
<td style="text-align:center">个别服务制定的日志文件</td>
</tr>
</tbody>
</table>
<h3 id="日志文件管理所需服务"><a href="#日志文件管理所需服务" class="headerlink" title="  日志文件管理所需服务"></a><a name="ch1.2">  日志文件管理所需服务</a></h3><p>Linux用于管理日志文件有syslogd/rsyslog,klogd这两个服务与logrotate这个程序</p>
<ul>
<li>syslogd/rsyslog: rsyslog已经代替syslogd,其会把系统各种信息分类,放置到相应的日志文件中.</li>
<li>klogd: 记录内核产生的各项信息</li>
<li>logrotate:日志文件的轮替,由于时间久了,日志文件会越来越大,影响读取,故将旧文件替换</li>
</ul>
<h3 id="日志分析工具-logwatch"><a href="#日志分析工具-logwatch" class="headerlink" title="  日志分析工具:logwatch"></a><a name="ch1.3">  日志分析工具:logwatch</a></h3><p>我们除了可以直接去查看各日志文件信息外,也可以使用一些分析工具,比如logwatch,其会分析特定的日志信息.</p>
<h2 id="rsyslog-记录日志文件服务"><a href="#rsyslog-记录日志文件服务" class="headerlink" title="  rsyslog:记录日志文件服务"></a><a name="ch2">  rsyslog:记录日志文件服务</a></h2><p>rsyslog是常驻内存中的服务,用于记录系统各类信息,并输出到日志文件(或者设备上)</p>
<h3 id="日志文件一般格式"><a href="#日志文件一般格式" class="headerlink" title="  日志文件一般格式"></a><a name="ch2.1">  日志文件一般格式</a></h3><p>系统产生的信息经由rsyslog记录,会产生下面格式的日志信息.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Aug 17 16:36:09 kumho-Inspiron-3421 postfix/pickup[1524]: 6BCA960072: uid=1000 from=&lt;kumho@kumho-Inspiron-3421&gt;</div></pre></td></tr></table></figure>
其记录的几个重要数据,时间发生的日期与时间,发生此事件的主机名,启动此事件的服务名称或函数,该信息的实际数据内容</p>
<h3 id="rsyslog的配置文件"><a href="#rsyslog的配置文件" class="headerlink" title="  rsyslog的配置文件"></a><a name="ch2.2">  rsyslog的配置文件</a></h3><p>rsyslog的配置文件是/etc/rsyslog.conf与/etc/rsyslog.d/<em>,通常/etc/rsyslog.conf负责整体的配置信息,/etc/rsyslog.d/</em>则是负责配置输出的日志信息与日志文件的对应.比如以下是/etc/rsyslog.d/50-default.conf的内容
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">auth,authpriv.*                 /var/log/auth.log</div><div class="line">*.*;auth,authpriv.none          -/var/log/syslog</div><div class="line">cron.*                         /var/log/cron.log</div><div class="line">daemon.*                       -/var/log/daemon.log</div><div class="line">kern.*                          -/var/log/kern.log</div><div class="line">lpr.*                          -/var/log/lpr.log</div><div class="line">mail.*                          -/var/log/mail.log</div><div class="line">mail.err                        /var/log/mail.err</div></pre></td></tr></table></figure>
其分为日志信息与输出文件两部分</p>
<h4 id="日志信息分类"><a href="#日志信息分类" class="headerlink" title="日志信息分类"></a><a name="ch2.2.1">日志信息分类</a></h4><p>因为系统产生的信息各式各样,所以对这些信息进行了分类,如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型名</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">auth(authpriv)</td>
<td style="text-align:center">主要与认证有关的信息,比如login,su,ssh登录时产生的信息</td>
</tr>
<tr>
<td style="text-align:center">cron</td>
<td style="text-align:center">例行工作调度cron/at等信息</td>
</tr>
<tr>
<td style="text-align:center">daemon</td>
<td style="text-align:center">与各个daemon有关的信息</td>
</tr>
<tr>
<td style="text-align:center">kern</td>
<td style="text-align:center">内核产生的信息</td>
</tr>
<tr>
<td style="text-align:center">lpr</td>
<td style="text-align:center">打印相关的信息</td>
</tr>
<tr>
<td style="text-align:center">mail</td>
<td style="text-align:center">邮件相关的信息记录</td>
</tr>
<tr>
<td style="text-align:center">news</td>
<td style="text-align:center">新闻组信息</td>
</tr>
<tr>
<td style="text-align:center">syslog</td>
<td style="text-align:center">就是syslog/rsyslog本身产生的信息</td>
</tr>
<tr>
<td style="text-align:center">user,uucp,local0~local7</td>
<td style="text-align:center">与机器相关的一些信息</td>
</tr>
</tbody>
</table>
<h4 id="日志信息等级及连接符"><a href="#日志信息等级及连接符" class="headerlink" title=" 日志信息等级及连接符"></a><a name="ch2.2.2"> 日志信息等级及连接符</a></h4><p>日志信息等级用来描述事情的情况,如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">等级</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">none</td>
<td style="text-align:center">不输出任何信息</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">debug</td>
<td style="text-align:center">调试信息</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">info</td>
<td style="text-align:center">基本信息说明</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">notice</td>
<td style="text-align:center">注意事项说明</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">waring(warn)</td>
<td style="text-align:center">警告信息,但不影响运行</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">err(error)</td>
<td style="text-align:center">错误信息,已造成不能运行</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">crit</td>
<td style="text-align:center">比err严重,到临界点了</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">alert</td>
<td style="text-align:center">比crit还严重</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">emerg(panic)</td>
<td style="text-align:center">通常是硬件出错,内核已经无法运行的程度</td>
</tr>
</tbody>
</table>
<p>等级连接符是为了方便我们书写配置文件,产生的。有以下：</p>
<ul>
<li><code>.</code> 表示大于等于后接等级的日志信息都会记录<ul>
<li><code>.*</code> 任意等级</li>
</ul>
</li>
<li><code>.=</code> 表示只有等于后接等级的日志信息才记录</li>
<li><code>!=</code> 表示不等于后接等级的日志信息都会记录</li>
</ul>
<h4 id="输出日志文件或设备或主机"><a href="#输出日志文件或设备或主机" class="headerlink" title=" 输出日志文件或设备或主机"></a><a name="ch2.2.3"> 输出日志文件或设备或主机</a></h4><p>我们需要在配置文件中指定日志输出的地方,其可以是如下:</p>
<ul>
<li>一般文件: 以绝对路径书写</li>
<li>设备文件: 比如打印机(/dev/lp0)等</li>
<li>用户名称: 显示给用户</li>
<li>远程主机: @对方IP或@域名,需要对方也支持rsyslog服务</li>
<li><ul>
<li>: 当前系统在线的用户(相当于wall)</li>
</ul>
</li>
</ul>
<p>当输出文件前有<code>-</code>,表示日志信息先存在内存中,等数据量大才写入硬盘中.</p>
<h3 id="自定义日志文件"><a href="#自定义日志文件" class="headerlink" title="  自定义日志文件"></a><a name="ch2.3">  自定义日志文件</a></h3><p>我们只有在/etc/rsyslog.d/下新建相对的配置文件,配置文件格式如上说明,在重启rsyslog服务即可.(我在测试时,发觉输出日志文件定义在用户目录下没有输出日志信息,写在/var/log/下就有,很奇怪)</p>
<h2 id="logrotate-日志文件轮替"><a href="#logrotate-日志文件轮替" class="headerlink" title="  logrotate:日志文件轮替"></a><a name="ch3">  logrotate:日志文件轮替</a></h2><p>前面我们提到logrotate是进行日志文件轮替的一个程序,其挂在crond服务下.例行检测日志文件是否需要替换,其主要工作是新建一个新文件记录之后的日志信息,之前的日志文件改名(<em>.1/</em>.2/*.3等),当备份的日志文件一定量后,就会将最旧的文件删除</p>
<p>我们可以用<code>logrotate -vf logroate的配置文件</code>进行强制的轮替工作</p>
<h3 id="logrotate的配置文件"><a href="#logrotate的配置文件" class="headerlink" title="  logrotate的配置文件"></a><a name="ch3.1">  logrotate的配置文件</a></h3><p>logrotate针对日志文件(即前一节提到日志输出文件)进行轮替,所以其配置文件作用对象也是日志文件</p>
<p>logrotate的配置文件有/etc/logrotate.conf与/etc/logrotate.d/*
这两个文件的格式类型,如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">日志文件的绝对路径名&#123;</div><div class="line">      参数设置</div><div class="line">&#125;</div></pre></td></tr></table></figure>
相关参数说明可以<code>man logrotate.conf</code>,注意logrotate配置文件可以写入shell命令,使用特殊参数,如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sharedscripts</div><div class="line">    prerotate</div><div class="line">       /usr/bin/chattr -a /var/log/message</div><div class="line">endscript</div><div class="line"></div><div class="line">sharedscripts</div><div class="line">    postrotate</div><div class="line">       /usr/bin/chattr +a /var/log/message</div><div class="line">endscript</div></pre></td></tr></table></figure>
上面的配置文件的意思是在进行轮替工作前,将/var/log/message的a权限去掉,轮替后,再加上a权限</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 认识系统服务(daemon)]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E8%AE%A4%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1-daemon/</url>
      <content type="html"><![CDATA[<h2 id="什么是daemon"><a href="#什么是daemon" class="headerlink" title=" 什么是daemon"></a><a name="ch1"> 什么是daemon</a></h2><p>daemon是在后台运行,并提供某项服务的程序,通过以服务名+字符<code>d</code>来规定daemon的名称</p>
<h3 id="daemon的主要分类"><a href="#daemon的主要分类" class="headerlink" title=" daemon的主要分类"></a><a name="ch1.1"> daemon的主要分类</a></h3><p>daemon根据启动与管理方式,可分为独立启动的stand_alone,与通过一个super daemon来统一管理</p>
<ul>
<li>stand_alone:此类型daemon可自行独立启动<br>一直在内存中持续提供服务,对于客服端的请求,响应较快,常见的此类型daemon有提供WWW服务的daemon(httpd)与FTP服务的daemon(vsftpd)等</li>
<li>super daemon：一个stand_alone的daemon(xinetd,早期是inetd)管理<br>其内部提供多种服务,当客服端请求时,xinetd才会去唤醒相应的daemon提供服务,请求结束后,此唤醒的daemon也会关闭</li>
</ul>
<p>super daemon运行示意图如下:
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_28_1.png?raw=true" alt=""></p>
<p>daemon根据对请求的处理可分为单进程和多进程</p>
<p>daemon根据提供服务的工作状态可分为singal-control与interval-control</p>
<ul>
<li>singal-control:此类daemon通过信号管理<br>接收到客服端的请求,daemon就会去处理</li>
<li>interval-control:此类daemon每隔一段时间就主动去执行工作,我们需要在配置文件指定daemon的服务时间与工作内容,如周期例行工作调度的crond</li>
</ul>
<h3 id="服务与端口"><a href="#服务与端口" class="headerlink" title=" 服务与端口"></a><a name="ch1.2"> 服务与端口</a></h3><p>因为我们主机仅有一个IP,当要提供各种服务时,应该如何处理,我们想要的是用户可访问的是主机上的某项服务,而不是直接开放主机资源出来</p>
<p>如果我们在指定通道上提供一个服务,用户只要访问我们主机上的这个通道,就可以使用服务.那么这个通道(窗口)就是端口.</p>
<p>为了规范服务与端口的对应,所以我们有了协议,约定某服务的指定端口,我们可以查看<code>/etc/services</code>的内容,里面有各服务的协议端口信息</p>
<h3 id="daemon相关文件"><a href="#daemon相关文件" class="headerlink" title=" daemon相关文件"></a><a name="ch1.3"> daemon相关文件</a></h3><p>daemon不同与一般的进程,其启动除了需要执行文件外,还需配置文件,执行环境,运行数据存储等.
一个daemon的相关文件如下:</p>
<ul>
<li><code>/etc/init.d/*</code> : 放置stand_alone的daemon启动脚本<br>该脚本会进行环境检测,配置文件分析等工作,可以用来管理daemon的状态</li>
<li><code>/etc/sysconfig/*(RedHat) /etc/default/*(Debian)</code>:服务初始化环境配置文件
存放服务初始化的参数设置的文件,比如网络设置写在/etc/sysconfig/network中</li>
<li><code>/etc/*</code>：各服务的配置文件</li>
<li><code>/etc/xinetd.conf  /etc/xinetd.d/*</code>:super daemon及所属daemon的配置文件<br>/etc/xinted.conf是super daemon的配置文件,其是所属daemon最上级的配置文件,当所属daemon的配置文件(/etc/xinetd.d/*)中与xinetd.conf有相同项的配置,参考所属daemon</li>
<li><code>/var/lib/*</code>: 各服务产生的数据<br>一些会产生数据的服务将其数据写入/var/lib中,比如Mysql</li>
<li><code>/var/run/*</code>: 各服务的PID记录<br>为了能简单地管理各服务的进程,所以daemon会将其PID写入/var/run中</li>
</ul>
<h3 id="daemon的启动-关闭"><a href="#daemon的启动-关闭" class="headerlink" title=" daemon的启动/关闭"></a><a name="ch1.4"> daemon的启动/关闭</a></h3><h4 id="stand-alone的-etc-init-d-的启动-关闭"><a href="#stand-alone的-etc-init-d-的启动-关闭" class="headerlink" title="stand_alone的/etc/init.d/*的启动/关闭"></a>stand_alone的/etc/init.d/*的启动/关闭</h4><p>因为daemon的启动脚本帮我们完成了很多工作(检测环境,查找配置文件等),所以我们直接使用启动脚本来管理daemon
直接输入/etc/init.d/daemon名,会提示此脚本能接受的参数
比如启动/关闭syslog这个服务可以<code>/etc/init.d/syslog start</code>   <code>/etc/init.d/syslog stop</code></p>
<p>我们也可以用<code>services</code>来管理daemon,其用法如下:</p>
<ul>
<li><code>service [service name] (start|stop|restart...)</code></li>
<li><code>service --status-all</code>  //查看目前系统所有stand_alone服务状态</li>
</ul>
<h4 id="super-daemon所属daemon的启动-关闭"><a href="#super-daemon所属daemon的启动-关闭" class="headerlink" title="super daemon所属daemon的启动/关闭"></a>super daemon所属daemon的启动/关闭</h4><p>super daemon所属daemon在/etc/xinetd.d/*中有配置文件,当要启动daemon时,需要将其配置文件中的<code>disable</code>属性设置<code>no</code>,在通过/etc/init.d/xinetd重启xinetd,要关闭daemon也是这样做,将<code>disable</code>设为<code>yes</code></p>
<h2 id="super-daemon的配置"><a href="#super-daemon的配置" class="headerlink" title=" super daemon的配置"></a><a name="ch2"> super daemon的配置</a></h2><h3 id="解析super-daemon配置文件"><a href="#解析super-daemon配置文件" class="headerlink" title=" 解析super daemon配置文件"></a><a name="ch2.1"> 解析super daemon配置文件</a></h3><p>super daemon配置文件(/etc/xinetd.conf)与其属的daemon的配置文件(/etc/xinetd.d/*)格式上类似.</p>
<p>xinetd.conf的配置文件形如
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">defaults</div><div class="line">&#123;</div><div class="line">    instaces  =  50  #同一服务的最大同时连接数</div><div class="line">    per_source = 10 #同一来源的客服端最大连接数</div><div class="line">    cap  =  50 10 #同一秒内的最大连接数为50个,若超过则暂停服务10秒</div><div class="line">&#125;</div><div class="line"></div><div class="line">includedir /etc/xinetd.d   # 更多设置值在/etc/xinetd.d目录内</div></pre></td></tr></table></figure></p>
<p>而/etc/xinetd.d下的服务配置文件形如
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">service &lt;service name&gt;</div><div class="line">&#123;</div><div class="line">    属性       操作符     值</div><div class="line">&#125;</div><div class="line">其中操作符有= +=  -=</div></pre></td></tr></table></figure></p>
<p>相关的属性与值的说明可以查看 <code>man xinetd.conf</code></p>
<h3 id="etc-hosts管理"><a href="#etc-hosts管理" class="headerlink" title=" /etc/hosts管理"></a><a name="ch2.2"> /etc/hosts管理</a></h3><p>我们在xinetd配置文件中有两个值<code>only_from</code>与<code>no_access</code>其是用来限制IP访问的,<code>only_from</code>是允许访问的IP,<code>no_access</code>是限制访问的IP</p>
<p>除此之外,我们也可以通过/etc/hosts.allow与/etc/hosts.deny文件限制IP访问(hosts.allow优先与hosts.deny)
hosts.allow与hosts.deny的文件格式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;service name&gt; ： &lt;IP,domain,hostname&gt;：&lt;atcion&gt;</div></pre></td></tr></table></figure></p>
<ul>
<li><action> : 有allow/deny(允许/限制) 还有其他额外的操作(比如spawn与twist分析数据包,并加以处理)</action></li>
<li>特殊的参数(第一/二个字段):<ul>
<li>ALL : 代表全部的service或IP都接受</li>
<li>LOCAL:代表本机</li>
<li>UNKOWN:代表不可解析的IP等</li>
<li>KNOWN: 可解析的IP等</li>
</ul>
</li>
</ul>
<h2 id="系统已启动的服务与开机启动服务"><a href="#系统已启动的服务与开机启动服务" class="headerlink" title=" 系统已启动的服务与开机启动服务"></a><a name="ch3"> 系统已启动的服务与开机启动服务</a></h2><h3 id="查看系统已启动的服务"><a href="#查看系统已启动的服务" class="headerlink" title=" 查看系统已启动的服务"></a><a name="ch3.1"> 查看系统已启动的服务</a></h3><h4 id="查看目前系统正在监听的网络服务"><a href="#查看目前系统正在监听的网络服务" class="headerlink" title="查看目前系统正在监听的网络服务"></a>查看目前系统正在监听的网络服务</h4><p>netstat -lnp</p>
<h4 id="查看目前系统的服务状态"><a href="#查看目前系统的服务状态" class="headerlink" title="查看目前系统的服务状态"></a>查看目前系统的服务状态</h4><p>service –status-all</p>
<h3 id="开机启动服务"><a href="#开机启动服务" class="headerlink" title=" 开机启动服务"></a><a name="ch3.2"> 开机启动服务</a></h3><p>当我们要设置开机启动的服务时,可以通过<code>chkconfig</code>或<code>sysv-rc-conf</code></p>
<p>要了解开机的启动服务,需要知道开机的执行等级,执行等级可以理解成Linux的执行模式,共有[0-6]个等级,0为关机 3为命令模式 5为X window 6为重启</p>
<h4 id="查看系统已设置的开机启动服务"><a href="#查看系统已设置的开机启动服务" class="headerlink" title="查看系统已设置的开机启动服务"></a>查看系统已设置的开机启动服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig --list [服务名]</div></pre></td></tr></table></figure>
<p>其会列出各服务的不同等级的开启/关闭状态</p>
<h4 id="设置服务各等级的开机状态"><a href="#设置服务各等级的开机状态" class="headerlink" title="设置服务各等级的开机状态"></a>设置服务各等级的开机状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig --level [0-6] [服务名] [on|off]</div></pre></td></tr></table></figure>
<h4 id="Linux开机流程说明"><a href="#Linux开机流程说明" class="headerlink" title="Linux开机流程说明"></a>Linux开机流程说明</h4><ol>
<li>打开计算机电源,开机读取BIOS并进行主机的自我测试</li>
<li>通过BIOS取得第一个可开机设备,读取主引导分区(MBR)取得启动装载程序</li>
<li>通过启动装载程序的设置,取得内核并加载内存且检测系统硬件</li>
<li>内核主动调用init进程</li>
<li>init进程开始执行系统初始化(/etc/rc.d/rc.sysinit)</li>
<li>依据init的设置进行daemon start(/etc/rc.d/rc[0-6].d/*)</li>
<li>加载本机设置(/etc/rc.d/rc.local)</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 程序管理与SELinux]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86%E4%B8%8ESELinux/</url>
      <content type="html"><![CDATA[<h2 id="工作管理-Job-Control"><a href="#工作管理-Job-Control" class="headerlink" title=" 工作管理(Job Control)"></a><a name="ch1"> 工作管理(Job Control)</a></h2><h3 id="什么是工作管理"><a href="#什么是工作管理" class="headerlink" title=" 什么是工作管理"></a><a name="ch1.1"> 什么是工作管理</a></h3><p>工作管理是指在<b>单一终端</b>下同时进行多个工作的行为管理,不能管理其他终端上的工作,只关注自身终端</p>
<p>以下是进行工作管理时的一些限制与概念:</p>
<ul>
<li>只管理自己的bash上的工作(即bash只能管理其子进程的工作)</li>
<li>前台: 用户可以控制与执行命令的环境为前台</li>
<li>后台: 可以自行工作的环境,无法用[ctrl]+c终止工作,可用fg/bg调度工作</li>
</ul>
<h3 id="工作管理"><a href="#工作管理" class="headerlink" title=" 工作管理"></a><a name="ch1.2"> 工作管理</a></h3><h4 id="工作调入后台"><a href="#工作调入后台" class="headerlink" title="工作调入后台"></a>工作调入后台</h4><ul>
<li>将命令丢到后台运行: 命令尾+<code>&amp;</code>  如 <code>vim hello.txt &amp;</code>   </li>
<li>将运行中的工作放置后台暂停: <code>[ctrl]+z</code></li>
</ul>
<h4 id="后台工作的编号与状态"><a href="#后台工作的编号与状态" class="headerlink" title="后台工作的编号与状态"></a>后台工作的编号与状态</h4><p>工作调入后台时会返回一个工作编号(jobNum)给我们处理.
同时会标明工作调入后台后的状态. 其状态可分为<code>Done</code>,<code>Stopped</code>,<code>Killed</code>,<code>Running</code>(其中<code>Killed</code>是不正常终止)</p>
<h4 id="查看目前后台的工作-jobs"><a href="#查看目前后台的工作-jobs" class="headerlink" title="查看目前后台的工作:jobs"></a>查看目前后台的工作:<code>jobs</code></h4><p>我们可以用<code>jobs -l</code>列出当前后台中的工作,同时可以查看到它们的PID</p>
<h4 id="工作调回前台-fg"><a href="#工作调回前台-fg" class="headerlink" title="工作调回前台:fg"></a>工作调回前台:<code>fg</code></h4><p>通过<code>fg %jobNum</code>可以指定调出后台中的工作回前台运行</p>
<h4 id="后台中运行暂停的工作-bg"><a href="#后台中运行暂停的工作-bg" class="headerlink" title="后台中运行暂停的工作:bg"></a>后台中运行暂停的工作:<code>bg</code></h4><p>当我们用<code>[ctrl]+z</code>暂停工作到后台后,我们可以调用<code>bg %jobNum</code>在后台运行指定工作</p>
<h4 id="管理后台工作-kill"><a href="#管理后台工作-kill" class="headerlink" title="管理后台工作: kill"></a>管理后台工作: <code>kill</code></h4><p>通过<code>kill</code>+一个处理信号的方式来管理后台中的工作,形式如<code>kill -signal %jobNum</code>
处理信号可以用<code>kill -l</code>查阅,一些常见的信号: <code>-1 重载入 -9 强制杀死 -15 正常结束</code></p>
<h3 id="脱机工作管理"><a href="#脱机工作管理" class="headerlink" title=" 脱机工作管理"></a><a name="ch1.3"> 脱机工作管理</a></h3><p>当我们脱机或注销后,需要保持某些工作运行,好让我们下次登录时处理.该怎么做?</p>
<p>首先我们要明白<b>脱机/注销后</b>,系统分配给我们的用户进程(理解为登录后取得的终端,图形界面的是gnome-terminal)及子进程会被回收. </p>
<p>而我们需要做的是指定某进程不被系统回收,用<code>nohup</code>,在需要执行的命令前加上<code>nohup</code>即可.
此时输出信息会到<code>～/nohup.out</code>中.</p>
<h2 id="进程"><a href="#进程" class="headerlink" title=" 进程"></a><a name="ch2"> 进程</a></h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title=" 什么是进程"></a><a name="ch2.1"> 什么是进程</a></h3><p>其实我们前面提到的工作就是一个进程,其有一个程序触发,在内存中活动,以PID来标示一个内存单元(维护着程序数据以及执行者权限)</p>
<p>即 进程就是程序执行过程,执行者的权限与属性和程序代码与数据会加载至内存单元,并以PID来标示这个内存单元.</p>
<h3 id="子进程与父进程"><a href="#子进程与父进程" class="headerlink" title=" 子进程与父进程"></a><a name="ch2.2"> 子进程与父进程</a></h3><p>当我们父进程派生一个子进程后,父进程会休眠(关于进程状态,我们后面提),之后进入子进程的环境,通过PPID可以知道.</p>
<p>然后是父进程通过什么方式派生子进程?
父进程是通过<b>fork-and-exec</b>方式来派生子进程,系统先以fork复制一个与父进程相同的进程(数据相同,但PID不同,其PPID指向父进程),再以exec来加载子进程实际需要的数据.
如下图:
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_27_2.gif?raw=true" alt=""></p>
<h3 id="进程查看"><a href="#进程查看" class="headerlink" title=" 进程查看"></a><a name="ch2.3"> 进程查看</a></h3><p>查看当前系统正在运行当中的进程,可以使用ps查看静态数据,或者top动态查看进程,还能以pstree查看进程树</p>
<h4 id="查看自己bash所有进程和某进程-ps-l与ps-l-PID"><a href="#查看自己bash所有进程和某进程-ps-l与ps-l-PID" class="headerlink" title="查看自己bash所有进程和某进程:ps -l与ps -l PID"></a>查看自己bash所有进程和某进程:<code>ps -l</code>与<code>ps -l PID</code></h4><p>当我们使用<code>ps -l</code>查看自己bash,会出现如下信息
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</div><div class="line">0 S  1000  4616  2586  0  80   0 -  1786 wait   pts/13   00:00:00 bash</div><div class="line">4 R  1000  4620  4616  0  80   0 -  1605 -      pts/13   00:00:00 ps</div></pre></td></tr></table></figure>
第一行的各字段解释:</p>
<ul>
<li>F : 进程标志,说明进程权限 常见的<code>4</code>表root权限,<code>1</code>表进程只能fork不能exec,其中<code>0</code>表示没标志适用</li>
<li>S : 进程状态,<code>S</code>:Sleep,可唤醒 <code>R</code>:运行中 <code>D</code>:不可唤醒的睡眠状态 <code>T</code>:停止  <code>Z</code>:僵尸状态,进程终止却无法从内存中删除</li>
<li>UID/PID/PPID: 进程所有者/PID/父进程PID</li>
<li>C:CPU使用率</li>
<li>PRI/NI: 进程优先级,我们通过修改NI还改变PRI值,PRI决定进程优先,越小越优先</li>
<li>ADDR/SZ/WCHAN:内存相关,ADDR指示内存单元位置,SZ表示进程用掉多少内存,WCHAN表示进程是否运行中</li>
<li>TTY:指示终端机</li>
<li>CMD:触发进程的命令</li>
</ul>
<h4 id="查看系统所有进程-ps-Al或ps-aux"><a href="#查看系统所有进程-ps-Al或ps-aux" class="headerlink" title="查看系统所有进程:ps -Al或ps -aux"></a>查看系统所有进程:<code>ps -Al</code>或<code>ps -aux</code></h4><p>以下是用<code>ps -aux</code>以另一种呈现方式输出系统所有进程
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</div><div class="line">root         1  0.0  0.0   4616  3736 ?        Ss   08:08   0:01 /sbin/init</div><div class="line">root         2  0.0  0.0      0     0 ?        S    08:08   0:00 [kthreadd]</div><div class="line">root         3  0.0  0.0      0     0 ?        S    08:08   0:00 [ksoftirqd/0]</div><div class="line">root         5  0.0  0.0      0     0 ?        S&lt;   08:08   0:00 [kworker/0:0H]</div><div class="line">root         7  0.0  0.0      0     0 ?        S    08:08   0:03 [rcu_sched]</div><div class="line">root         8  0.0  0.0      0     0 ?        S    08:08   0:00 [rcu_bh]</div></pre></td></tr></table></figure>
字段的含义以之前类似,其中<code>VSZ</code>与<code>`RSS</code>分别表示进程使用的虚拟内存与固定内存量</p>
<h4 id="动态查看进程的变化-top"><a href="#动态查看进程的变化-top" class="headerlink" title="动态查看进程的变化:top"></a>动态查看进程的变化:top</h4><p>top可以持续监听进程的运行状态
其中选项<code>-d</code>:后接秒数,表示多少秒后更新状态  <code>-p</code>:接PID
在top内我们还可以通过操作来修改进程的状态,以下是一些top操作</p>
<ul>
<li><code>P</code>:以CPU使用率排序进程</li>
<li><code>M</code>:以内存使用率排序进程</li>
<li><code>N</code>:以PID排序进程</li>
<li><code>k</code>:给与某进程一个信号</li>
<li><code>r</code>:修改某进程的NI值(NICE)</li>
</ul>
<p>top的输出信息以下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">### 以下部分描述当前系统状态 load aveage:表示CPU的平均负载(1,5,15分钟)</div><div class="line">top - 10:00:41 up  1:51,  3 users,  load average: 0.37, 0.37, 0.33</div><div class="line">Tasks: 212 total,   1 running, 211 sleeping,   0 stopped,   0 zombie</div><div class="line">%Cpu(s): 14.0 us,  3.7 sy,  0.0 ni, 81.9 id,  0.5 wa,  0.0 hi,  0.0 si,  0.0 st</div><div class="line">KiB Mem:   6075096 total,  2214228 used,  3860868 free,   148028 buffers</div><div class="line">KiB Swap:  3998716 total,        0 used,  3998716 free.  1198676 cached Mem</div><div class="line"></div><div class="line">### top操作命令</div><div class="line">Send pid 4698 signal [15/sigterm] </div><div class="line"></div><div class="line">### 进程信息</div><div class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     </div><div class="line"> 4698 root      20   0       0      0      0 S   0.0  0.0   0:00.06 kworker/u4+ </div><div class="line"> 4697 kumho     20   0    6960   2796   2392 R   0.3  0.0   0:00.34 top   </div></pre></td></tr></table></figure></p>
<h4 id="进程的树结果-pstree"><a href="#进程的树结果-pstree" class="headerlink" title="进程的树结果:pstree"></a>进程的树结果:pstree</h4><p>通过<code>pstree</code>我们可以了解到进程间的相互关系,如果要同时输出PID及进程所有者,可加上<code>-up</code>选项,如果进程所有者是root,则进程树不会显示出来</p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title=" 进程管理"></a><a name="ch2.4"> 进程管理</a></h3><p>与工作管理类似,进程也是通过kill加信号量来管理的,不同的是,进程间可以彼此管理.</p>
<h4 id="需指定PID-kill"><a href="#需指定PID-kill" class="headerlink" title="需指定PID:kill"></a>需指定PID:<code>kill</code></h4><p>kill需要指定进程的PID,才能对进程进行管理,通常配合<code>ps</code>等
格式是<code>kill -signal PID</code>,signal如<code>工作管理</code>中提到,可通过<code>kill -l</code>才查看,
这里再补充下</p>
<ul>
<li><code>1</code>:重新启动</li>
<li><code>2</code>:相当与<code>[ctrl]+c</code></li>
<li><code>9</code>:强制杀死</li>
<li><code>15</code>:正常结束</li>
<li><code>17</code>:相当与<code>[ctrl]+z</code></li>
</ul>
<h4 id="管理指定命令启动的所有进程-killall"><a href="#管理指定命令启动的所有进程-killall" class="headerlink" title="管理指定命令启动的所有进程:killall"></a>管理指定命令启动的所有进程:<code>killall</code></h4><p>killall 格式是<code>killall -signal 命令</code>,其中<code>killall</code>也包含其他的选项 <code>i</code>:询问用户 <code>I</code>忽略命令大小写</p>
<h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title=" 进程优先级"></a><a name="ch2.5"> 进程优先级</a></h3><p>CPU会根据进程优先级来决定某进程的执行频率,一些冗长的进程应该较不优先
进程优先级由PRI值决定,值越低越优先,用户无法直接设置PRI值,而是通过NI值来修改PRI值.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PRI(new)=PRI(old)+Ni #这个加式,不是绝对的,PRI(new)可能会有点偏差,由系统分析后绝对</div></pre></td></tr></table></figure>
Ni值的修改有以下限制:</p>
<ul>
<li>Ni值可调整范围为-20~19</li>
<li>root可以随意调整自己或他人的进程的Ni值,范围是-20~19</li>
<li>一般用户仅可以调整自己进程的Ni值,范围是0~19,且值只能越调越大</li>
</ul>
<p>要调整Ni值有以下两种方式:</p>
<h4 id="nice-给予新执行命令一个NI值"><a href="#nice-给予新执行命令一个NI值" class="headerlink" title="nice: 给予新执行命令一个NI值"></a>nice: 给予新执行命令一个NI值</h4><p>格式<code>nice -n NI值 commad</code></p>
<h4 id="renice-修改已存在的进程的Ni值"><a href="#renice-修改已存在的进程的Ni值" class="headerlink" title="renice:修改已存在的进程的Ni值"></a>renice:修改已存在的进程的Ni值</h4><p>格式<code>renice NI值 PID</code></p>
<h3 id="进程与文件"><a href="#进程与文件" class="headerlink" title=" 进程与文件"></a><a name="ch2.6"> 进程与文件</a></h3><h4 id="查看正在使用某文件的进程-fuser"><a href="#查看正在使用某文件的进程-fuser" class="headerlink" title="查看正在使用某文件的进程:fuser"></a>查看正在使用某文件的进程:fuser</h4><p>fuser的格式: <code>fuser [-umv] [-k -signal] file/dir</code></p>
<ul>
<li><code>u</code> :显示进程执行者</li>
<li><code>m</code> :后接的文件,会上提到其所在的文件系统挂载点,等价与查看正在使用此文件系统的进程</li>
<li><code>v</code> : 显示列出文件与进程的相关数据</li>
<li><code>k</code> : 管理进程</li>
</ul>
<h4 id="列出某进程所打开的文件-lsof"><a href="#列出某进程所打开的文件-lsof" class="headerlink" title="列出某进程所打开的文件: lsof"></a>列出某进程所打开的文件: lsof</h4><p> lsof的格式: <code>lsof [-p PID] [-u username] [+d] [-a] [-U]</code></p>
<ul>
<li><code>a</code> ： 连接词，AND</li>
<li><code>u</code>  :  列出该用户相关进程所打开的文件</li>
<li><code>U</code>  : 列出系统的socket文件</li>
<li><code>+d</code> : 后接目录,列出该目录已被打开的文件</li>
</ul>
<h4 id="查看某命令所启动的进程-pidof"><a href="#查看某命令所启动的进程-pidof" class="headerlink" title="查看某命令所启动的进程: pidof"></a>查看某命令所启动的进程: pidof</h4><p>pidof格式是<code>pidof command</code></p>
<h2 id="系统资源查看"><a href="#系统资源查看" class="headerlink" title=" 系统资源查看"></a><a name="ch3"> 系统资源查看</a></h2><h3 id="free-查看内存使用情况"><a href="#free-查看内存使用情况" class="headerlink" title=" free:查看内存使用情况"></a><a name="ch3.1"> free:查看内存使用情况</a></h3><p>free输出的信息默认以KB为单位,如果我需要其他单位显示容量,可以使用<code>-b|-k|-m|-g</code></p>
<h3 id="uname-查看系统与内核相关信息"><a href="#uname-查看系统与内核相关信息" class="headerlink" title=" uname:查看系统与内核相关信息"></a><a name="ch3.2"> uname:查看系统与内核相关信息</a></h3><p>uname相关选项:</p>
<ul>
<li><code>a</code> : 所有信息</li>
<li><code>s</code> : 内核名称</li>
<li><code>r</code> ： 内核版本</li>
<li><code>m</code> : 本系统的硬件名称,如i686或x86_64</li>
<li><code>i</code> ： 硬件架构,i686等</li>
</ul>
<h3 id="uptime-查看系统启动时间与工作负载"><a href="#uptime-查看系统启动时间与工作负载" class="headerlink" title=" uptime:查看系统启动时间与工作负载"></a><a name="ch3.3"> uptime:查看系统启动时间与工作负载</a></h3><p>uptime所查看的信息就是top描述系统信息的部分</p>
<h3 id="netstat-跟踪网络"><a href="#netstat-跟踪网络" class="headerlink" title=" netstat:跟踪网络"></a><a name="ch3.4"> netstat:跟踪网络</a></h3><p>netstat被用在网络监控方面,以下网络连接,与本地socket的信息
以下是一些选项</p>
<ul>
<li><code>a</code> : 列出目前系统所有连接/socket/监听</li>
<li><code>t</code> : 列出tcp网络数据包的数据</li>
<li><code>u</code>：列出udp网络数据包的数据</li>
<li><code>n</code> : 不列出进程的服务名称,以端口号显示</li>
<li><code>l</code>: 列出目前正在网络监听的服务</li>
<li><code>p</code>:显示PID</li>
</ul>
<p>比如列出目前系统上已在监听的网络连接及PID:<code>netstat -tlnp</code></p>
<h3 id="dmesg-分析内核产生的信息-主机硬件信息"><a href="#dmesg-分析内核产生的信息-主机硬件信息" class="headerlink" title=" dmesg:分析内核产生的信息(主机硬件信息)"></a><a name="ch3.5"> dmesg:分析内核产生的信息(主机硬件信息)</a></h3><p>dmesg是用来查看内核分析出来的主机硬件信息的,通常配合grep一起使用</p>
<h3 id="vmstat-动态跟踪系统资源的变化"><a href="#vmstat-动态跟踪系统资源的变化" class="headerlink" title=" vmstat:动态跟踪系统资源的变化"></a><a name="ch3.6"> vmstat:动态跟踪系统资源的变化</a></h3><p>vmstat可以检测CPU/内存/磁盘的IO状态等.下面是常见的参数说明:</p>
<ul>
<li><code>vmstat time</code>:vmstat默认是检测CPU/内存等信息,time为秒数,表示动态跟踪</li>
<li><code>vmstat -d</code> 磁盘IO总量统计表</li>
<li><code>vmstat -p 分区</code> 显示该分区的IO总量统计表</li>
</ul>
<h3 id="proc目录"><a href="#proc目录" class="headerlink" title=" /proc目录"></a><a name="ch3.7"> /proc目录</a></h3><p>/proc目录存放的是内存中的数据,每一个进度都会在/proc下创建一个以PID为名的子目录,进程目录下存放着相当多的文件,比如cmdline是存放启动此进程的命令,environ是这个进程的环境变量</p>
<h2 id="SELinux"><a href="#SELinux" class="headerlink" title=" SELinux"></a><a name="ch4"> SELinux</a></h2><h3 id="什么是SELinux"><a href="#什么是SELinux" class="headerlink" title=" 什么是SELinux"></a><a name="ch4.1"> 什么是SELinux</a></h3><p>SELinux是在进行程序/文件等权限设置依据的一个内核模块,是程序进程能访问系统资源的一道关卡,通常用于控制网络服务.</p>
<p>SELinux是基于以策略规则制定特定程序访问特定文件的模式,即委托访问控制(MAC),我们之前用户访问文件,直接通过判断文件权限与用户对比,这种访问方式称为自主访问控制(DAC).</p>
<p>DAC的一些缺陷:</p>
<ul>
<li>root具有最高权限</li>
<li>用户取得进程来更改文件资源的访问权限</li>
</ul>
<p>而MAC是针对进程设置对文件的访问权限,通过提供一些策略来管理众多的进程与文件</p>
<h3 id="SELinux运行模式"><a href="#SELinux运行模式" class="headerlink" title=" SELinux运行模式"></a><a name="ch4.2"> SELinux运行模式</a></h3><p>SELinux是通过MAC方式控管进程的,其控管的主体是进程,而目标是文件资源,其相关性如下:</p>
<ul>
<li>主体(Subject)<ul>
<li>进程</li>
</ul>
</li>
<li>目标(Object)<ul>
<li>文件资源</li>
</ul>
</li>
<li>策略(Policy)<ul>
<li>由于进程与文件数量庞大,所有SELinux依据某些服务制定了基本的访问策略,这些策略内还会有详细的规则(rule)来制定不同服务的开放某些资源的程度</li>
<li>targetd: 针对网络服务限制较多,本机限制较少</li>
<li>strict:限制方面较严格</li>
</ul>
</li>
<li>安全上下文(security context)<ul>
<li>安全上下文是描述主体/目标的相关信息,只有当主体与目标的安全上下文匹配时,主体才能去访问目标.(当然,最后还要匹配目标的rwx权限)</li>
</ul>
</li>
</ul>
<p>SELinux 运行各组件的相关性如下图
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_27_1.gif?raw=true" alt=""></p>
<h3 id="安全上下文"><a href="#安全上下文" class="headerlink" title=" 安全上下文"></a><a name="ch4.3"> 安全上下文</a></h3><p>安全上下文存在于文件的inode上,因为进程也是由文件触发的,所以主体进程也有安全上下文
SELinux下,只有当主体通过策略与安全上下文的匹配后,才能得到放行.而最主要的部分就是安全上下文.</p>
<h4 id="安全上下文的查看"><a href="#安全上下文的查看" class="headerlink" title="安全上下文的查看"></a>安全上下文的查看</h4><p><b>文件安全上下文的查看: ls -Z</b>
<b>进程安全上下文的查看: ps -Z</b></p>
<p>安全上下文主要分为3个字段
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Identify:role:type</div></pre></td></tr></table></figure></p>
<ul>
<li><code>Identify</code>：标明数据所有者的身份,值为:<ul>
<li><code>root</code> root所有</li>
<li><code>system_u</code> 系统程序方面的标识,通常指服务进程</li>
<li><code>user_u</code> 一般用户</li>
</ul>
</li>
<li><code>role</code> :表明数据的角色,比如程序,文件资源等<ul>
<li><code>object_r</code>：代表文件资源</li>
<li><code>system_r</code> ： 代表进程</li>
</ul>
</li>
<li><code>type</code>:安全上下文的比较字段<ul>
<li><code>domain</code>:在主体的安全上下文中其type字段称为domain</li>
<li><code>type</code>: 在目标安全上下文其type字段称为type</li>
<li>只有domain与type匹配后,安全上下文才匹配成功</li>
<li>SELinux启动后会写入domain与type的映射表,匹配就是在映射表中搜索</li>
</ul>
</li>
</ul>
<h4 id="安全上下文的修改"><a href="#安全上下文的修改" class="headerlink" title="安全上下文的修改"></a>安全上下文的修改</h4><p>如果已知某文件的安全上下文的type字段错了,需要改回正常可以怎么做？</p>
<ul>
<li><code>chcon</code>:指定修改安全上下文的字段<ul>
<li>格式 <code>chcon [-R] [-t type] [-u user] [-r role] 文件</code>或 <code>chcon [-R] --reference=范例文件 文件</code></li>
<li>参数: <code>-R</code>是级联修改 <code>-t</code>修改type字段 <code>-u</code>修改Identify字段 <code>-r</code>修改role字段</li>
</ul>
</li>
<li><code>restorecon</code>:还原文件的默认安全上下文<ul>
<li>格式 <code>restorecon [-Rv] 文件</code></li>
</ul>
</li>
</ul>
<h3 id="SELinux的启动-关闭-查看"><a href="#SELinux的启动-关闭-查看" class="headerlink" title=" SELinux的启动/关闭/查看"></a><a name="ch4.4"> SELinux的启动/关闭/查看</a></h3><p>SELinux支持3种运行模式(注意与MAC策略模式的区别)</p>
<ul>
<li>enforcing: 强制模式,代表SELinux已正确限制访问</li>
<li>permissive:宽容模式,代表SELinux已启动,但不会限制访问,但会提出警告</li>
<li>disable:SELinux关闭</li>
</ul>
<h4 id="SELinux的查看"><a href="#SELinux的查看" class="headerlink" title="SELinux的查看"></a>SELinux的查看</h4><ul>
<li><code>getenforce</code>:查看SELinux的运行模式</li>
<li><code>sestatus</code>:查看SELinux目前的状态,如运行模式,策略模式等</li>
</ul>
<h4 id="SELinux的启动"><a href="#SELinux的启动" class="headerlink" title="SELinux的启动"></a>SELinux的启动</h4><ol>
<li>首先了解你的系统是否装了SELinux(apt-get install selinux)</li>
<li>打开SELinux的配置文件/etc/selinux/config,将其中的SELINUX项设为enforcing,SELINUXTYPE设为targeted</li>
<li>修改/boot配置文件(/boot/grub/menu.1st或/boot/grub/grub.cfg),将其中的selinux=0改为=1(或者去掉)</li>
<li>重启主机</li>
<li>查看getenforce
(可是我在Ubuntu14.04上进行以上操作,并不能启动SELinux,待解)</li>
</ol>
<h4 id="SELinux的关闭"><a href="#SELinux的关闭" class="headerlink" title="SELinux的关闭"></a>SELinux的关闭</h4><p>只要将SELinux配置文件SELINUX改回disable，重启即可</p>
<h4 id="SELinux运行模式切换"><a href="#SELinux运行模式切换" class="headerlink" title="SELinux运行模式切换"></a>SELinux运行模式切换</h4><p>我们SELinux启动/关闭要进行上面工作,但enforcing与permissive模式的切换只要用<code>setenforce</code>即可</p>
<h3 id="SELinux的错误回报处理"><a href="#SELinux的错误回报处理" class="headerlink" title=" SELinux的错误回报处理"></a><a name="ch4.5"> SELinux的错误回报处理</a></h3><p>当SELinux发生错误时,我们可以通过<code>setroubleshoot</code>或<code>auditd</code>服务收集SELinux的错误信息,并加以分析处理</p>
<h4 id="setroubleshoot：SELinux错误信息写入-var-log-messages"><a href="#setroubleshoot：SELinux错误信息写入-var-log-messages" class="headerlink" title="setroubleshoot：SELinux错误信息写入/var/log/messages"></a>setroubleshoot：SELinux错误信息写入/var/log/messages</h4><p>首先我们需要确认安装setroubleshoot,并将其启动</p>
<p>当SELinux报告错误信息后,我们可以查看/var/log/messages,其会提供解决的方法.</p>
<h4 id="auditd-SELinux日志信息写入-var-log-audit-audit-log"><a href="#auditd-SELinux日志信息写入-var-log-audit-audit-log" class="headerlink" title="auditd:SELinux日志信息写入/var/log/audit/audit.log"></a>auditd:SELinux日志信息写入/var/log/audit/audit.log</h4><p>auditd会收集SELinux的日志信息,由于auditd信息庞大,可以借由audit2why来处理导入的audit信息</p>
<h3 id="SELinuxde的策略与规则管理"><a href="#SELinuxde的策略与规则管理" class="headerlink" title=" SELinuxde的策略与规则管理"></a><a name="ch4.6"> SELinuxde的策略与规则管理</a></h3><p>我们知道,一个主体进程能否读取目标文件的重点在于SELinuxde的策略以及策略下的各项规则,然后在通过该规则的定义去处理各文件的安全上下文.</p>
<h4 id="查看当前策略提供的信息-seinfo"><a href="#查看当前策略提供的信息-seinfo" class="headerlink" title="查看当前策略提供的信息:seinfo"></a>查看当前策略提供的信息:<code>seinfo</code></h4><p>seinfo的参数有以下:</p>
<ul>
<li><code>b</code> 列出当前策略提供的所有规则种类(bool值,表示该规则启动与否)</li>
<li><code>t</code>  列出所能提供的安全上下文中的type种类</li>
<li><code>u</code> 列出所能提供的安全上下文中的Identify种类</li>
<li><code>r</code> 列出所能提供的安全上下文中的role种类</li>
</ul>
<p>比如以下看出所有与httpd有关的规则: <code>seinfo -b | grep httpd</code></p>
<h4 id="查看安全上下文type字段映射表-sesearch"><a href="#查看安全上下文type字段映射表-sesearch" class="headerlink" title="查看安全上下文type字段映射表:sesearch"></a>查看安全上下文type字段映射表:<code>sesearch</code></h4><p>基本格式 <code>sesearch [-a] [-s 主体type] [-t 目标type] [-b 策略bool]</code></p>
<ul>
<li><code>a</code> 列出该类型或布尔值的所有相关信息</li>
</ul>
<p>比如我要查找目标文件类型为httpd_sys_content_t的有关信息
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sesearch -a -t httpd_sys_content_t</div><div class="line"></div><div class="line">输出结果</div><div class="line">allow 主体安全上下文类型 目标安全上下文类型 目标文件资源格式</div></pre></td></tr></table></figure></p>
<h4 id="查看-设置规则的状态-getsebool-a-规则bool与setsebool-P-规则bool-0-1"><a href="#查看-设置规则的状态-getsebool-a-规则bool与setsebool-P-规则bool-0-1" class="headerlink" title="查看/设置规则的状态:getsebool [-a] 规则bool与setsebool [-P] 规则bool=[0|1]"></a>查看/设置规则的状态:<code>getsebool [-a] 规则bool</code>与<code>setsebool [-P] 规则bool=[0|1]</code></h4><p>我们通过<code>getsebool</code>来查看SELinux目前策略下的规则状态,<code>-a</code>是查看所有规则条款
而<code>setsebool</code>来设置规则条款的状态 0-关闭 1-开启 -P直接写入配置文件</p>
<h4 id="默认目录的安全上下文查询与修改-semanage"><a href="#默认目录的安全上下文查询与修改-semanage" class="headerlink" title="默认目录的安全上下文查询与修改:semanage"></a>默认目录的安全上下文查询与修改:<code>semanage</code></h4><p>semanage的查询格式：<code>semanage {user|port|interface|fcontext|login} -l</code> (其中fcontext是用与安全上下文方面)
semanage的修改格式 : <code>semanage fcontext -{a|d|m} [-tru] file_spec</code></p>
<ul>
<li><code>a|d|m</code> 增/删/改 一条安全上下文</li>
<li><code>tru</code>  对于安全上下文的类型/角色/身份上的处理</li>
<li><code>file_spec</code> 针对的目标文件或主体文件的路径名(如/srv/samba(/.*)?)</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 例行工作(at/crontab)]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E4%BE%8B%E8%A1%8C%E5%B7%A5%E4%BD%9C-at-crontab/</url>
      <content type="html"><![CDATA[<h2 id="什么是例行工作"><a href="#什么是例行工作" class="headerlink" title=" 什么是例行工作"></a><a name="ch1"> 什么是例行工作</a></h2><p>例行工作就是一些事先安排要进行的工作,其可能是周期发生,也可能是单次工作的.</p>
<h3 id="Linux工作调度种类"><a href="#Linux工作调度种类" class="headerlink" title=" Linux工作调度种类"></a><a name="ch1.1"> Linux工作调度种类</a></h3><ul>
<li>周期工作: <code>crontab</code>进行周期工作调度,其由<code>cron</code>服务支持</li>
<li>单次工作: <code>at</code>进行单次工作调度,其是一次性的,由<code>atd</code>服务支持</li>
</ul>
<h2 id="单次工作调度-at"><a href="#单次工作调度-at" class="headerlink" title=" 单次工作调度:at"></a><a name="ch2"> 单次工作调度:at</a></h2><h3 id="atd服务的启动"><a href="#atd服务的启动" class="headerlink" title=" atd服务的启动"></a><a name="ch2.1"> atd服务的启动</a></h3><p>单次工作调度：at需有atd服务支持,其启动方法如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/atd restart</div><div class="line"></div><div class="line"># 开机启动atd方法,Ubuntu不支持chkconfig,其会默认启动atd</div><div class="line">chkconfig atd on </div></pre></td></tr></table></figure></p>
<h3 id="at用户限制"><a href="#at用户限制" class="headerlink" title=" at用户限制"></a><a name="ch2.2"> at用户限制</a></h3><p>at进行工作调度,其是针对执行at命令的用户,我们并不想让所有用户都可以执行at(某些用户可能执行破坏系统的命令),所以我们会限制可at的用户.</p>
<p>at工作时会区查找/etc/at.allow和/etc/at.deny中限制的用户名单(通常at.allow与at.deny不同时存在)</p>
<h4 id="etc-at-allow"><a href="#etc-at-allow" class="headerlink" title="/etc/at.allow"></a>/etc/at.allow</h4><p>当其存在时,只有at.allow中的用户才能执行at</p>
<h4 id="etc-at-deny"><a href="#etc-at-deny" class="headerlink" title="/etc/at.deny"></a>/etc/at.deny</h4><p>当/etc/at.allow不存在,at会查找/etc/at.deny,这个文件内的用户都不能执行at</p>
<h4 id="以上两个文件都不存在"><a href="#以上两个文件都不存在" class="headerlink" title="以上两个文件都不存在"></a>以上两个文件都不存在</h4><p>只有root才能执行at</p>
<h3 id="at进行工作调度"><a href="#at进行工作调度" class="headerlink" title=" at进行工作调度"></a><a name="ch2.3"> at进行工作调度</a></h3><p><code>at</code>命令格式如下：
<code>at time</code>: 进行工作调度安排,以[CTRL]+[d]结束工作安排,并返回一个工作编号
<code>at -l</code>: 显示当前存在的工作
<code>at -d 工作编号</code>:取消某个工作
<code>at -c 工作编号</code>:显示某个工作具体的执行过程
其中<code>time</code>的格式可以有<code>HH:MM</code> <code>HH:MM YYYY-MM-DD</code> <code>now + num [minutes| hours | days | weeks]</code>等</p>
<p>一个例子:
主机预计在5小时后关机
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># at now + 5 hours    # 进入at shell的环境</div><div class="line">at &gt;  /bin/sync  #命令最好以绝对路径写,因为at shell的环境是其父进程的环境</div><div class="line">                        #比如我直接新建一个文件,其会在执行at时的目录下新建</div><div class="line">at &gt; /bin/sync</div><div class="line">at &gt; /sbin/shutdown -h 0</div><div class="line">at &gt; &lt;EOF&gt;</div><div class="line">job 5 at 2016-8-11 12:00</div></pre></td></tr></table></figure></p>
<h3 id="batch进行工作调度"><a href="#batch进行工作调度" class="headerlink" title=" batch进行工作调度"></a><a name="ch2.4"> batch进行工作调度</a></h3><p> batch其实就是at,只不过batch要求CPU工作负载低时才会进行工作.(Ubuntu的batch不能加入时间参数)
CPU负载是指单一时间点CPU负责的工作数量.</p>
<h2 id="周期工作调度-crontab"><a href="#周期工作调度-crontab" class="headerlink" title=" 周期工作调度:crontab"></a><a name="ch3"> 周期工作调度:crontab</a></h2><h3 id="cron服务"><a href="#cron服务" class="headerlink" title=" cron服务"></a><a name="ch3.1"> cron服务</a></h3><p>Linux原本就有很多周期性例行工作,所以<code>cron</code>服务会默认启动</p>
<h3 id="crontab用户限制"><a href="#crontab用户限制" class="headerlink" title=" crontab用户限制"></a><a name="ch3.2"> crontab用户限制</a></h3><p>与at用户限制类似,crontab也会限制执行的用户,crontab会去查找/etc/cron.allow与/etc/cron.deny这两个文件,如果这两个文件不存在,我们可自行创建,文件写入的用户名会被限制(一般只保留cron.deny)</p>
<h3 id="用户的周期工作调度"><a href="#用户的周期工作调度" class="headerlink" title=" 用户的周期工作调度"></a><a name="ch3.3"> 用户的周期工作调度</a></h3><p>上面提到的是对执行crontab命令的用户进行限制,当一个用户执行crontab,crontab会在<code>/var/spool/cron/crontabs</code>(Ubuntu)创建一个同用户名的文件,来记录用户的周期工作.
CentOS会在<code>/var/spool/cron</code>目录下创建同用户名的记录文件.</p>
<p>我们可以通过<code>crontab -e</code>来打开这个文件</p>
<p>这个文件的一条工作记录格式如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0   12   *   *    *   echo &quot;Hello World!&quot; &gt; /tmp/test.log</div><div class="line">#一条工作记录由5个字段组成,分别是</div><div class="line">#分 时 日 月 周 命令</div><div class="line">#时间参数可以用特殊值来表示如下:</div><div class="line">*  :  代表任何时刻都接受</div><div class="line">,   :  代表时刻A和时刻B都接受,比如 0 3,6 * * * 每天3点和6点</div><div class="line">-   :  代表某个时间段,比如0,3-6 * * * 每天3点到6点</div><div class="line">/n : 代表间隔n个时间单位,比如*/5 * * * * 每5分钟</div></pre></td></tr></table></figure></p>
<p>如果要删除某个工作,用<code>crontab -e</code>打开文件后删除相应的工作记录即可.</p>
<p>如果root要为某用户安排工作,可以使用<code>crontab -u username -e</code> 或者直接打开用户的工作记录文件.</p>
<h3 id="系统的周期工作调度"><a href="#系统的周期工作调度" class="headerlink" title=" 系统的周期工作调度"></a><a name="ch3.4"> 系统的周期工作调度</a></h3><p>系统的周期工作记录文件在/etc/crontab中,我们打开/etc/crontab,可以看到如下类似的工作记录
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> # m h dom mon dow user  command</div><div class="line">25 6    * * *   root    cd / &amp;&amp;run-parts --report /etc/cron.daily</div><div class="line"></div><div class="line"># 工作记录与用户的工作记录类似,多了一个user字段</div><div class="line"># 上面的工作是每天6时25分钟时执行/etc/cron.daily目录下的所有可执行文件.</div><div class="line"># run-parts是执行指定目录下的所有文件</div><div class="line"># 执行者是root</div><div class="line"># 当然我们可以不进行run-parts,直接执行某个命令.</div><div class="line"># 也可以指定某个目录,放置要执行的script文件,再进行run-parts</div></pre></td></tr></table></figure></p>
<h3 id="唤醒停机期间的工作调度-anacron"><a href="#唤醒停机期间的工作调度-anacron" class="headerlink" title=" 唤醒停机期间的工作调度:anacron"></a><a name="ch3.5"> 唤醒停机期间的工作调度:anacron</a></h3><p>当主机停机期间,安排好的工作并不能执行,哪该怎么办?
<code>anacron</code>会帮我们处理这个问题.其本质也是一个crontab</p>
<h4 id="anacron工作原理"><a href="#anacron工作原理" class="headerlink" title="anacron工作原理"></a>anacron工作原理</h4><p>当我们每次处理crontab安排的工作时,都会先处理anacron安排的工作,anacron安排的工作很简单,就是记录这次处理crontab的时间(时间记录在目录/var/spool/anacront/下的子文件).当我们下次处理anacron工作时,会比较与前一个时间的差值,看它是否满足工作记录的要求,不满足就进行差值时间内之前的crontab工作.</p>
<h4 id="anacron工作记录文件-etc-anacrontab"><a href="#anacron工作记录文件-etc-anacrontab" class="headerlink" title="anacron工作记录文件/etc/anacrontab"></a>anacron工作记录文件/etc/anacrontab</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># These replace cron&apos;s entries</div><div class="line">1       5       cron.daily      run-parts --report /etc/cron.daily</div><div class="line"></div><div class="line"># 上面工作记录表示:此条工作名为cron.daily,其每天执行的(1),执行会延迟5分钟才开始</div><div class="line"># 执行命令是 run-parts --report /etc/cron.daily</div><div class="line"></div><div class="line">7       10      cron.weekly     run-parts --report /etc/cron.weekly</div><div class="line"></div><div class="line"># 还有下面这条工作记录,应该看得懂吧</div></pre></td></tr></table></figure>
<p>如果我们自己要安排一些周期工作,又担心系统停机后没处理到数据,那就可以在/etc/anacrotab中指定.anacron记录的时间在文件/var/spool/anacron/工作名中</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 磁盘额度(Quota)与高级文件系统管理(RAID/LVM)]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E7%A3%81%E7%9B%98%E9%A2%9D%E5%BA%A6-Quota-%E4%B8%8E%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86-RAID-LVM/</url>
      <content type="html"><![CDATA[<h2 id="磁盘额度-quota"><a href="#磁盘额度-quota" class="headerlink" title=" 磁盘额度(quota)"></a><a name="ch1"> 磁盘额度(quota)</a></h2><h3 id="什么是quota"><a href="#什么是quota" class="headerlink" title=" 什么是quota"></a><a name="ch1.1"> 什么是quota</a></h3><p>在Linux系统中，多用户多任务的环境会经常抢占资源，quota则是制定用户/用户组，对硬盘资源的进行配额 ， 妥善分配资源。</p>
<ul>
<li>quota的一般用途<ul>
<li>针对WWW server ， 例如：限制用户的网页空间容量</li>
<li>针对 mail server  ， 例如 ： 限制用户的邮件空间</li>
<li>针对 file server ， 例如 ： 限制用户最大的可能网络磁盘空间</li>
<li>限制某用户的最大磁盘配额</li>
<li>限制某用户组的最大磁盘配额</li>
<li>以LINK方式对目录进行用户/用户组配额</li>
</ul>
</li>
<li>quota的使用限制<ul>
<li>仅能针对整个文件系统， 如果某文件系统没有设置quota，其下的文件可以通过link来指向设置了quota的文件系统</li>
<li>内核必须支持quota</li>
<li>只对一般身份用户有效（root没效）</li>
<li>quota的日志文件:kernel2.6的日志文件是aquota.user aquota.group ，文件名比旧版的quota前面多了个a</li>
</ul>
</li>
<li>quota的设置选项<ul>
<li>quota可以限制文件系统的block与inode的大小：限制block的大小就是其使用文件系统容量，限制inode就是限制其可创建的文件数</li>
<li>限制值（soft/hard） ：hard表示用户使用的容量绝对不能超过此值。soft表示用户超过此值就会警告，并倒数宽限时间，超过宽限时间后hard=soft。</li>
<li>宽限时间（grace time） </li>
</ul>
</li>
</ul>
<h3 id="文件系统启用quota"><a href="#文件系统启用quota" class="headerlink" title=" 文件系统启用quota"></a><a name="ch1.2"> 文件系统启用quota</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">下面以/home的文件系统为例</div><div class="line"></div><div class="line"><span class="comment"># 查看/home是否启用quota</span></div><div class="line"><span class="comment"># mount | grep home</span></div><div class="line">/dev/mapper/vg1-lv1 on /home <span class="built_in">type</span> ext4 (rw)  <span class="comment"># 没有</span></div><div class="line"></div><div class="line"><span class="comment"># 启用 quota （用户限制与用户组限制）</span></div><div class="line"><span class="comment"># mount -o remount,usrquota,grpquota /home</span></div><div class="line">/dev/mapper/vg1-lv1 on /home <span class="built_in">type</span> ext4 (rw,usrquota,grpquota)</div><div class="line"></div><div class="line"><span class="comment"># 如果要开机就启用quota</span></div><div class="line"><span class="comment"># 可以修改/etc/fstab文件系统的选项</span></div><div class="line"></div></pre></td></tr></table></figure>
<h3 id="新建quota日志文件"><a href="#新建quota日志文件" class="headerlink" title=" 新建quota日志文件"></a><a name="ch1.3"> 新建quota日志文件</a></h3><p>quota日志文件除了进行日志记录时，也是对用户/用户组的额度进行配置
使用<code>quotacheck</code> ： 扫描文件系统并新建quota日志文件（aquota.user   aquota.group）
命令格式 ： <code>quotacheck -vug /mount_point</code>   :  <code>v</code>：显示进度  <code>u</code>：新建用户日志 <code>g</code>：新建用户组日志</p>
<h3 id="启动-停止quota与限制值设置"><a href="#启动-停止quota与限制值设置" class="headerlink" title=" 启动/停止quota与限制值设置"></a><a name="ch1.4"> 启动/停止quota与限制值设置</a></h3><p>启动quota：quotaon /mount_point
停止quota：quotaoff /mount_point</p>
<p>限制值设置：edquota与setquota
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># 以限制用户额度为例</div><div class="line"># edquota -u user1 [-g groupname]  #其会打开一个关于此用户限值设置的文档</div><div class="line"></div><div class="line">FileSystem Blocks  soft hard Inodes  soft  hard</div><div class="line">/dev/sda9     80    0     0       10     0   0</div><div class="line"></div><div class="line">FileSystem：针对的文件系统</div><div class="line">Blocks：磁盘容量,单位KB</div><div class="line">soft：blocks的soft 单位KB,0表示不限制</div><div class="line">hard：block的hard</div><div class="line">inodes： Inode数量，单位个数</div><div class="line">soft:Inode的soft</div><div class="line">hard: Inode的hard</div><div class="line"></div><div class="line">我们通常只会设置block的soft与hard</div><div class="line"></div><div class="line">setquota可以帮助我们在shell script中设置quota</div><div class="line">其格式为：setquota [-u name][-g name] blockSoft blockHard inodeSoft inodeHard /mount_point</div><div class="line"></div><div class="line">设置宽限时间</div><div class="line">edquota -t </div></pre></td></tr></table></figure></p>
<h3 id="quota当前情况报表以及警告信息"><a href="#quota当前情况报表以及警告信息" class="headerlink" title=" quota当前情况报表以及警告信息"></a><a name="ch1.5"> quota当前情况报表以及警告信息</a></h3><p>针对用户/用户组的报表 ：  quota [-u|-g]vs name
针对文件系统的报表： repquota -augvs</p>
<p>发送警告信息：warnquota（当有用户超过soft时，才会成功送出两份mail，分别给root与该用户），如果要明天定时执行warnquota，可以在/etc/cron.daily/warnquota中写入<code>warnquota命令的绝对路径</code></p>
<h2 id="磁盘阵列-RAID"><a href="#磁盘阵列-RAID" class="headerlink" title=" 磁盘阵列(RAID)"></a><a name="ch2"> 磁盘阵列(RAID)</a></h2><h3 id="什么是RAID"><a href="#什么是RAID" class="headerlink" title=" 什么是RAID"></a><a name="ch2.1"> 什么是RAID</a></h3><p>磁盘阵列(RAID)，即容错廉价磁盘阵列，其有多个较小的磁盘整合成一个较大的磁盘。其不只具有存储功能，还有数据保护和性能优化等功能。 特别是用相同型号等大小的磁盘组成时性能最优，以下是其整合模式。</p>
<h4 id="RAID-0-等量模式-性能最优"><a href="#RAID-0-等量模式-性能最优" class="headerlink" title="RAID-0(等量模式):性能最优"></a>RAID-0(等量模式):性能最优</h4><p>数据依次放到各个磁盘中，由于磁盘是交错放置数据的，所以数据会被等量分到各个磁盘中。此中模式性能最优，但是没有对数据毁坏的处理。</p>
<h4 id="RAID-1-映像模式-完整备份"><a href="#RAID-1-映像模式-完整备份" class="headerlink" title="RAID-1(映像模式):完整备份"></a>RAID-1(映像模式):完整备份</h4><p>一份数据会存放在RAID中存放两次。所以RAID-1的容量只是组成磁盘总容量的一半(或者更小)。优点是完整备份数据，性能较差。</p>
<h4 id="RAID0-1与RAID1-0"><a href="#RAID0-1与RAID1-0" class="headerlink" title="RAID0+1与RAID1+0"></a>RAID0+1与RAID1+0</h4><p>磁盘先组成RAID0或1，再去组成RAID1或0，这种模式优化了性能，又备份了数据。但是组成的硬盘较多，容量也只有这些硬盘的一半。</p>
<h4 id="RAID-5：性能与数据均衡考虑"><a href="#RAID-5：性能与数据均衡考虑" class="headerlink" title="RAID-5：性能与数据均衡考虑"></a>RAID-5：性能与数据均衡考虑</h4><p>RAID-5：至少需要3个硬盘以上。数据以RAID-0方式依次循环写硬盘中，但是一个循环过程会在某个硬盘写入一同步检查码(其可以恢复此轮循环中写入其他盘的数据)，由于检查码会用掉一个硬盘，所以RAID-5的总量等于硬盘-1的容量。</p>
<h4 id="Spare-Disk：-预备盘"><a href="#Spare-Disk：-预备盘" class="headerlink" title="Spare Disk： 预备盘"></a>Spare Disk： 预备盘</h4><p>组成RAID时，会多准备出几个空盘，当RAID中某盘坏掉时，系统会抽出坏盘，抽入一个预备盘。</p>
<h3 id="软磁盘阵列"><a href="#软磁盘阵列" class="headerlink" title=" 软磁盘阵列"></a><a name="ch2.2"> 软磁盘阵列</a></h3><p>软磁盘阵列，相对与硬磁盘阵列，是用软件来模拟出RAID的功能，但实际上盘是不会改变的，坏盘了还是GG.</p>
<h4 id="软磁盘阵列的设置"><a href="#软磁盘阵列的设置" class="headerlink" title=" 软磁盘阵列的设置"></a><a name="ch2.2.1"> 软磁盘阵列的设置</a></h4><p>使用如下的命令
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 创建一个名为md0的RAID,RAID模式5，用sda8,9,10构成RAID,用sda11,12构成预备盘</div><div class="line">mdadm --create --auto=yes /dev/md0   --raid-devices=3 --level=5  --spare-devices=2  /dev/sda&#123;8,9,10,11,12&#125;</div><div class="line"></div><div class="line"># 查看md0情况</div><div class="line">mdadm --detail /dev/md0</div></pre></td></tr></table></figure></p>
<h4 id="软磁盘阵列的管理"><a href="#软磁盘阵列的管理" class="headerlink" title=" 软磁盘阵列的管理"></a><a name="ch2.2.2"> 软磁盘阵列的管理</a></h4><p>使用如下命令对raid进行管理
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mdadm --manage /dev/md0 [--add 设备名] [--remove 设备名] [--fail 设备名]</div><div class="line"># 其中fail是设置raid中的设备出错</div></pre></td></tr></table></figure></p>
<h4 id="软磁盘阵列的开机挂载"><a href="#软磁盘阵列的开机挂载" class="headerlink" title=" 软磁盘阵列的开机挂载"></a><a name="ch2.2.3"> 软磁盘阵列的开机挂载</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先查出raid设备的uuid</span></div><div class="line">mdadm --detail /dev/md0</div><div class="line"></div><div class="line"><span class="comment"># 设置mdadm的映射关系</span></div><div class="line">在/etc/mdadm.conf中添加`ARRAY /dev/md0 UUID=值</div><div class="line"></div><div class="line"><span class="comment"># 设置etc/fstab</span></div></pre></td></tr></table></figure>
<h4 id="软磁盘阵列的关闭"><a href="#软磁盘阵列的关闭" class="headerlink" title=" 软磁盘阵列的关闭"></a><a name="ch2.2.4"> 软磁盘阵列的关闭</a></h4><p>首先先停止RAID的挂载，再执行<code>mdadm --stop</code>，最后可能会要修改回/etc/mdadm.conf</p>
<h2 id="逻辑卷管理-LVM"><a href="#逻辑卷管理-LVM" class="headerlink" title=" 逻辑卷管理(LVM)"></a><a name="ch3"> 逻辑卷管理(LVM)</a></h2><h3 id="什么是LVM"><a href="#什么是LVM" class="headerlink" title=" 什么是LVM"></a><a name="ch3.1"> 什么是LVM</a></h3><p>LVM可以弹性调整文件系统的容量,其可以整合多个物理分区成为一个逻辑分区,当然也可以从逻辑分区中删除物理分区。</p>
<p>其作法是:将几个物理分区(PV)组合成一个分区组(VG),在从VG中划分从逻辑区(LV)供文件系统挂载。
LVM中的最小单位是物理扩展块(PE),有点类似blocks,PE是PV的最小单位,其可以指定大小(需2的倍数),我们可以通过LV中PE的数量来调整LV的大小。</p>
<p>PE/VG/LV关系图如下
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_25_2.gif?raw=true" alt="">
这图可以将每两组看作一个PV,更好理解LVM各单位的关系</p>
<p>LVM实现过程如下图：
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_25_3.jpg?raw=true" alt=""></p>
<h3 id="LVM实现过程"><a href="#LVM实现过程" class="headerlink" title=" LVM实现过程"></a><a name="ch3.2"> LVM实现过程</a></h3><h4 id="PV阶段"><a href="#PV阶段" class="headerlink" title="PV阶段"></a>PV阶段</h4><ul>
<li>pvcreate : 将物理分区(System Id 要改为8e)新建成PV</li>
<li>pvdisplay: 显示目前系统的PV状态</li>
<li>pvremove: 将PV属性删除,物理无法不具有PV属性
以下命令将sda6,7,8,9构建成pv<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pvcreate /dev/sda&#123;6,7,8,9&#125;  #pv名同设备名</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="VG阶段"><a href="#VG阶段" class="headerlink" title="VG阶段"></a>VG阶段</h4><ul>
<li>vgcreate:新建vg,基本格式是 <code>vgcreate -s PE大小 VG名 PV名</code></li>
<li>vgdisplay:显示目前系统的vg状态</li>
<li>vgextend:vg内增加额外的pv 格式是<code>vgextend VG名 PV名</code></li>
<li>vgreduce:vg内删除pv,格式类似vgextend</li>
<li>vgchange:激活/失活vg,在删除pv时都要失活vg,格式<code>vgchange -a n vg名</code></li>
<li>vgremove:删除vg
以下命令是将sda6,7,8构成一个vg,再添加sda9<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vgcreate -s 4M vg1 /dev/sda&#123;6,7,8&#125;  #构成出的vg1设备名是/dev/vg1</div><div class="line">vgextend vg1 /dev/sda9</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="LV阶段"><a href="#LV阶段" class="headerlink" title="LV阶段"></a>LV阶段</h4><ul>
<li>lvcreate:新建LV,可以直接指定大小(-L)或者通过PE个数来指定大小(-l) 基本格式是<code>lvcreate -l num -n lv名 vg名</code></li>
<li>lvdisplay:显示目前系统的lv状态</li>
<li>lvresize:对LV进行容量大小调整(+|-)</li>
<li>lvremove:删除一个LV
以下命令是在vg1下构建一个由365个PE构成的lv<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lvcreate -l 365 -n lv1 /dev/vg1 # 构建成的lv 设备名是/dev/vg1/lv1</div></pre></td></tr></table></figure>
最后就可以直接格式话化lv,并进行挂载</li>
</ul>
<h3 id="放大-缩小LV容量"><a href="#放大-缩小LV容量" class="headerlink" title=" 放大/缩小LV容量"></a><a name="ch3.3"> 放大/缩小LV容量</a></h3><h4 id="放大LV容量"><a href="#放大LV容量" class="headerlink" title="放大LV容量"></a>放大LV容量</h4><p>其过程可以在线完成(即vg活动时),一般步骤如下:</p>
<ol>
<li>构建pv (pvcreate)</li>
<li>将pv加入vg (vgextend)</li>
<li>放大lv容量 (lvresize)</li>
<li>修改文件系统容量(修改超级块信息,resize2fs):resize2fs格式是<code>resize2fs 设备 [size]</code>
以下将sda10加入到vg,以扩展lv<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 创建pv</div><div class="line">pvcreate /dev/sda10</div><div class="line"></div><div class="line"># 向vg添加pv</div><div class="line">vgextend vg1 /dev/sda10</div><div class="line"></div><div class="line"># 放大lv容量</div><div class="line">lvresize -l +179 /dev/vg1/lv1</div><div class="line"></div><div class="line"># 修改文件系统容量</div><div class="line">resize2fs /dev/vg1/lv1</div><div class="line"></div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="缩小LV容量"><a href="#缩小LV容量" class="headerlink" title="缩小LV容量"></a>缩小LV容量</h4><p>缩小lv容量不能在vg活动时进入,具体过程就是放大lv容量的逆过程(注意:一定要先resize2fs,不然可能文件系统损坏)
以下将/dev/sda10移出vg1
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># 系统要求在resize2fs时先进行磁盘检查</div><div class="line">e2fsck -f /dev/vg1/lv1</div><div class="line"></div><div class="line"># 修改文件系统size,以减去/dev/sda10的大小</div><div class="line">resize2fs /dev/vg1/lv1 6900M</div><div class="line"></div><div class="line"># 失活vg1</div><div class="line">vgchange -a n vg1  (-a y 是激活)</div><div class="line"></div><div class="line"># lv缩小容量</div><div class="line">lvresize -l -179 /dev/vg1/lv1</div><div class="line"></div><div class="line"># vg1移出/dev/sda10</div><div class="line">vgreduce vg1 /dev/sda10</div><div class="line"></div><div class="line"># /dev/sda10删除pv属性</div><div class="line">pvremove /dev/sda10</div><div class="line"></div><div class="line"># 激活vg1</div><div class="line">vgchange -a y vg1</div></pre></td></tr></table></figure></p>
<h3 id="LVM的快照功能"><a href="#LVM的快照功能" class="headerlink" title=" LVM的快照功能"></a><a name="ch3.4"> LVM的快照功能</a></h3><p>LVM的快照区会保存建立快照时的文件系统中的数据,当然这个快照区有一定的最值,当系统变化太多时,快照区就会饱满,通过我们建立快照区来备份某个时刻的数据,以恢复文件系统(比如,教学环境中,老师会将系统建立快照区,再将挂载快照区的文件系统供学生使用.这样并不会影响到原文件系统)</p>
<p>建立快照区的命令
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 建立了lv1的100M快照区</div><div class="line">lvcreate -L 100M -s -n lv1ss /dev/vg1/lv1</div><div class="line"></div><div class="line"># 之后我们可以挂载这个快照区</div><div class="line">mount /dev/vg1/lv1ss /mnt/tmp</div><div class="line"></div><div class="line"># 再备份数据出来待恢复使用</div><div class="line">tar -jcv -f /mnt/backup/lv1.backup /mnt/tmp </div><div class="line"># 注意不能直接从快照区复制数据到原区,原区数据会覆盖删去后都转到快照区的</div></pre></td></tr></table></figure></p>
<h3 id="LVM的相关命令汇总与LVM的关闭"><a href="#LVM的相关命令汇总与LVM的关闭" class="headerlink" title=" LVM的相关命令汇总与LVM的关闭"></a><a name="ch3.5"> LVM的相关命令汇总与LVM的关闭</a></h3><p>LVM相关命令汇总如下图:
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_25_1.png?raw=true" alt=""></p>
<p>LVM的关闭步骤如下:</p>
<ol>
<li>使用lvremove删除所有lv</li>
<li>使vg失活 vgchange -a n vgname</li>
<li>使用vgremove删除vg</li>
<li>使用pvremoe删除pv</li>
<li>fdisk 回收 分区</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 账号管理与ACL权限]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E4%B8%8EACL%E6%9D%83%E9%99%90/</url>
      <content type="html"><![CDATA[<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="  用户管理"></a><a name="ch1">  用户管理</a></h2><p>Linux用户信息保存在<code>/etc/passwd</code>,用户密码信息保存在<code>/etc/shadow</code>,用户组信息保存在<code>/etc/group</code>,用户组密码信息保存在<code>/etc/gshadow</code>中.</p>
<p>下面我们以手工创建一个用户为例,了解上述各文件的结构.</p>
<h3 id="手工新建用户"><a href="#手工新建用户" class="headerlink" title="  手工新建用户"></a><a name="ch1.1">  手工新建用户</a></h3><p>手工新建用户流程 :</p>
<ol>
<li>新建所需要的用户组 (<code>vim /etc/group</code>)</li>
<li>将<code>/etc/group</code>与<code>/etc/gshadow</code>同步 (<code>grpconv</code>)</li>
<li>新建用户信息 (<code>vim /etc/passwd</code>)</li>
<li>将<code>/etc/passwd</code>与<code>/etc/shadow</code>同步 (<code>pwconv</code>)</li>
<li>新建用户密码 (<code>passwd username</code>)</li>
<li>新建用户主文件夹 (<code>cp -a /etc/skel /home/username</code>)</li>
<li>更改用户主文件夹属性 (<code>chown -R username:groupname /home/username</code>)</li>
<li>检查设置 (<code>pwck</code>)</li>
</ol>
<p>具体步骤:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">1.新建所需的用户组  (vim /etc/group)</div><div class="line">在最后一行加入一条用户组信息(其由4个字段组成, 组名:用户组密码(通常在/etc/gshadow设置,不设置以x表示)</div><div class="line">:GID(通常500以下保留给系统,新建的用户组用现有最大GID+1):用户组成员)</div><div class="line">比如加入一条用户组信息</div><div class="line">normal:x:1001:</div><div class="line"></div><div class="line">2.将/etc/group与/etc/gshadow同步 (grpconv)</div><div class="line">我们使用grpconv将在/etc/group加入的用户组信息同步到/etc/gshadow中.</div><div class="line">/etc/gshadow的结构也由4个字段组成,组名:密码列(开头以!表示不合法密码):用户组管理员:组员</div><div class="line">比如加入一条用户组密码信息(grpconv会同步创建)</div><div class="line">normal:*::</div><div class="line"></div><div class="line">3.新建用户信息 (vim /etc/passwd)</div><div class="line">同样我们在最后一行加入一条用户信息,(由7个字段组成,用户名:用户密码(也由/etc/shadow中代替)</div><div class="line">:UID(通常500以下为系统账号,100以下为系统默认创建,root=0):GID(初始用户组):备注:用户主目录:shell)</div><div class="line">比如加入一条用户信息</div><div class="line">myuser:x:1000:1002::/home/myuser:/bin/bash</div><div class="line"></div><div class="line">4.将/etc/passwd与/etc/shadow同步 (pwconv)</div><div class="line">pwconv将/etc/passwd的用户信息同步到/etc/shadow中,/etc/shadow由9个字段组成,用户名:用户密码(通常由MD5加密后):</div><div class="line">最近密码修改的时间(以天数为单位,后面的字段也是):密码可再次修改的最短时间:</div><div class="line">密码需要重新修改的时间:密码需重新修改的提醒时间(以上个字段为基准):</div><div class="line">密码过期后的宽限时间:账号失效时间(过了这个时间,账号就失效):保留</div><div class="line"></div><div class="line">比如下面这条用户密码信息(pwconv会帮我们创建,其会去参考/etc/default/useradd与/etc/login.defs)</div><div class="line">myuser:$6$4EZkAqYO$ghF87vQWxWAB17Z05OFQrCNfPrkWpceUhSzmxXHQ57hvH/U4PvVPs7r</div><div class="line">tzRAt17VNMYcUD2yhdGgZirNGqX6Il.:17000:0:99999:7::::</div><div class="line"></div><div class="line">5.新建用户密码 (passwd username)</div><div class="line">新建密码我们使用工具passwd来信息</div><div class="line"></div><div class="line">6.新建用户主文件夹 (cp -a /etc/skel /home/username)</div><div class="line">当然我们可以直接新建/home/username,但是我们有些默认的文件想在用户创建时就给予用户,</div><div class="line">通常会将/etc/skel文件给用户,系统创建时也是将/etc/skel的文件给与用户</div><div class="line">(同样,这个操作系统参考/etc/default/useradd的配置),所以我们可以将文件加到/etc/skel中</div><div class="line"></div><div class="line">7.更改用户主文件夹属性及权限 (chown -R username:groupname /home/username 与chmod)</div><div class="line">将用户主文件夹及子文件都改成用户所属</div><div class="line"></div><div class="line"></div><div class="line">8.检查设置 (pwck)</div><div class="line">pwck会报出设置错误信息</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>通过手工新建用户,我们知道系统在新建用户时会进行的操作,就是修改<code>/etc/passwd</code>  <code>/etc/shadow</code>
<code>/etc/group</code> <code>/etc/gshadow</code>还有就是创建用户主文件夹</p>
<h3 id="用户管理工具"><a href="#用户管理工具" class="headerlink" title="  用户管理工具"></a><a name="ch1.2">  用户管理工具</a></h3><h4 id="新建用户-useradd"><a href="#新建用户-useradd" class="headerlink" title="  新建用户 : useradd"></a><a name="ch1.2.1">  新建用户 : useradd</a></h4><p>useradd会参考/etc/default/useradd与/etc/login.defs文件来新建用户,其会去修改上述的/etc/passwd等4个文件</p>
<p> /etc/default/useradd的默认配置(各系统可能不一样)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GROUP=100    # 默认的初始用户组</div><div class="line">HOME=/home  # 用户主文件夹所在目录</div><div class="line">INACTIVE=-1   # 密码过期宽限时间(-1 表示密码过期后永远不失效)</div><div class="line">EXPIRE=          # 账号失效时间</div><div class="line">SKEL=/etc/skel # 用户主文件夹参考目录</div><div class="line">CREATE_MAIL_SPOOL=no # 不创建用户邮件邮箱</div><div class="line">SHELL=/bin/sh   #默认的shell</div></pre></td></tr></table></figure></p>
<p>/etc/login.defs的默认配置(各系统可能不一样)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PASS_MAX_DAYS   99999  #密码需要重新修改的时间</div><div class="line">PASS_MIN_DAYS  0  # 密码可再次修改的最短时间</div><div class="line">PASS_MIN_LEN  5  # 密码最短长度,已失效,被PAM模块代替(PAM是Linux下应用程序需要鉴定功能的调用的API)</div><div class="line">PASS_WARN_AGE 7 #密码需重新修改的提醒时间</div><div class="line"></div><div class="line">UID_MIN   500  # 一般用户最小的UID,小于500被系统保留</div><div class="line">UID_MAX  60000 # 一般用户最大的UID</div><div class="line">GID_MIN 500  # 用户组最小GID,小于500被系统保留</div><div class="line">GID_MAX 60000 # 用户组最大的GID</div><div class="line"></div><div class="line">UMASK 077  # 用户主文件夹的默认权限</div></pre></td></tr></table></figure></p>
<p>useradd的基本格式是: useradd [参数] 用户名
常用参数:</p>
<ul>
<li><code>m</code>  强制创建用户主目录</li>
<li><code>M</code>  强制不创建用户主目录</li>
<li><code>r</code>   创建系统账号</li>
<li><code>G</code>  次要用户组,如果要添加用户组,也可以在这里指定 - <code>aG</code></li>
<li><code>s</code>  指定shell</li>
<li><code>d</code>  指定用户主目录</li>
</ul>
<h4 id="修改用户-usermod"><a href="#修改用户-usermod" class="headerlink" title="  修改用户 : usermod"></a><a name="ch1.2.2">  修改用户 : usermod</a></h4><p>usermod与useradd的参数类似, 这里列一些
参数:</p>
<ul>
<li><code>l</code>  修改用户名,后接新的用户名</li>
<li><code>L</code>  冻结用户密码,使其无法登录(其实就是在/etc/shadow中的密码字段最前面加了!!)</li>
<li><code>U</code>  解冻用户</li>
</ul>
<h4 id="删除用户-userdel"><a href="#删除用户-userdel" class="headerlink" title="  删除用户 : userdel"></a><a name="ch1.2.3">  删除用户 : userdel</a></h4><p>userdel -r 会删除用户相关数据,删除了/etc/passwd,/etc/shadow,/etc/group,/etc/gshadow相关数据与/home/username,/var/spool/mail/username</p>
<h3 id="用户密码管理工具"><a href="#用户密码管理工具" class="headerlink" title="  用户密码管理工具"></a><a name="ch1.3">  用户密码管理工具</a></h3><h4 id="修改用户密码-passwd-与chpasswd"><a href="#修改用户密码-passwd-与chpasswd" class="headerlink" title="  修改用户密码 : passwd 与chpasswd"></a><a name="ch1.3.1">  修改用户密码 : passwd 与chpasswd</a></h4><p>查看密码状态可以使用 passwd -S</p>
<p>其中如果想在shell script中输入用户密码可以
echo “Userpasswd” | passwd –stdin $username 或者 printf “Userpasswd\nUserpasswd\n” | passwd $username</p>
<p>chpasswd也是用来修改密码的,其格式一定要”username:password”这个形式,如下
echo “username:password” | chpasswd -m 
-m 以MD5加密</p>
<h4 id="修改用户密码时间-chage"><a href="#修改用户密码时间-chage" class="headerlink" title="  修改用户密码时间 : chage"></a><a name="ch1.3.2">  修改用户密码时间 : chage</a></h4><p>记住我们/etc/shadow中有关密码时间由很多字段吧,chage -l 可以更直观地列出这些字段的信息.
除外也可以用相关的参数去修改这些字段,如-d 修改最近一次改动密码的时间(如果我们想用户第一次登录系统后就要求其修改密码 可以 <code>chage -d 0 username</code>)</p>
<h3 id="用户组管理工具"><a href="#用户组管理工具" class="headerlink" title="  用户组管理工具"></a><a name="ch1.4">  用户组管理工具</a></h3><h4 id="用户初始用户组与有效用户组"><a href="#用户初始用户组与有效用户组" class="headerlink" title="  用户初始用户组与有效用户组"></a><a name="ch1.4.1">  用户初始用户组与有效用户组</a></h4><p>当用户创建会指定用户组(-g),那个用户就是初始用户组,也可以那么说,/etc/passwd中相关用户信息的那个用户组字段就是初始用户组</p>
<p>有效用户组就是当前用户作用的用户组,比如新建文件时的用户组信息等.</p>
<p>显示当前用户的用户组信息可以使用<code>groups</code>(第1个用户组为有效用户组)或者<code>id</code></p>
<p>切换当前有效用户组 可以使用<code>newgrp</code></p>
<h4 id="新建用户组-groupadd"><a href="#新建用户组-groupadd" class="headerlink" title="  新建用户组 : groupadd"></a><a name="ch1.4.2">  新建用户组 : groupadd</a></h4><p>-r 会修改系统用户组</p>
<h4 id="修改用户组信息-groupmod"><a href="#修改用户组信息-groupmod" class="headerlink" title="  修改用户组信息: groupmod"></a><a name="ch1.4.3">  修改用户组信息: groupmod</a></h4><p>groupmod会去修改/etc/group相关字段</p>
<h4 id="删除用户组-groupdel"><a href="#删除用户组-groupdel" class="headerlink" title="  删除用户组:groupdel"></a><a name="ch1.4.4">  删除用户组:groupdel</a></h4><h4 id="用户组管理员-gpasswd"><a href="#用户组管理员-gpasswd" class="headerlink" title="  用户组管理员:gpasswd"></a><a name="ch1.4.5">  用户组管理员:gpasswd</a></h4><ul>
<li>添加用户组密码:gpasswd groupname</li>
<li>删除用户组密码:gpasswd -r groupname</li>
<li>添加用户组管理员(那么其可以执行gpasswd):gpasswd -A user1,user2.. groupname</li>
<li>添加用户组成员:gpasswd -M user1,user2…groupname</li>
<li>添加用户至用户组:gpasswd -a user1 groupname</li>
<li>删除用户:gpasswd -d user1 groupname</li>
</ul>
<h2 id="ACL权限"><a href="#ACL权限" class="headerlink" title="  ACL权限"></a><a name="ch2">  ACL权限</a></h2><p>ACL可以针对单一用户,单一用户组,单个文件进行rwx的权限设置.</p>
<h3 id="启用ACL"><a href="#启用ACL" class="headerlink" title="  启用ACL"></a><a name="ch2.1">  启用ACL</a></h3><p>查看你需要设置的文件对应的文件系统是否启用ACL功能.</p>
<p>首先查看文件系统的挂载情况:mount
比如我要设置的文件在/的文件系统下,其挂载至/dev/sda9,我们用dumpe2fs -h /dev/sda9的超级块的Default mount options情况.</p>
<p>如果没有acl功能,可以在/etc/fstab中options加入acl.这样开机就是启动acl. </p>
<h3 id="设置ACL-setfacl"><a href="#设置ACL-setfacl" class="headerlink" title="  设置ACL:setfacl"></a><a name="ch2.2">  设置ACL:setfacl</a></h3><p>setfacl最常用的参数就是 <code>-m</code>,设置权限列表, 比如 <code>-m u:user1:rx</code>就是针对某目录设置user1可以rx权限
删除acl权限可以使用 <code>-b</code></p>
<p>如果想某目录下所有文件都设置acl权限可以这样设置权限列表 <code>-m d:u:user1:rx</code></p>
<h3 id="查看ACL-getfacl"><a href="#查看ACL-getfacl" class="headerlink" title="  查看ACL:getfacl"></a><a name="ch23">  查看ACL:getfacl</a></h3><p>当我们文件设置setfacl后,ls查看的文件属性中权限字段会有个<code>+</code>,表示设置了acl权限.
如果要详细查看acl信息,使用getfacl</p>
<h2 id="用户身份切换工具"><a href="#用户身份切换工具" class="headerlink" title="  用户身份切换工具"></a><a name="ch3">  用户身份切换工具</a></h2><h3 id="切换用户-su"><a href="#切换用户-su" class="headerlink" title="  切换用户:su"></a><a name="ch3.1">  切换用户:su</a></h3><p>如果单纯使用<code>su username</code>来切换用户,系统会以non-login shell方式去读取用户相关环境变量(只会读取~/.bashrc),如果向使用login shell以完整的流程去读取用户相关的环境变量可以使用 <code>su - username</code></p>
<h3 id="以root身份去执行命令-sudo"><a href="#以root身份去执行命令-sudo" class="headerlink" title="  以root身份去执行命令:sudo"></a><a name="ch3.2">  以root身份去执行命令:sudo</a></h3><p>一般用户想使用sudo,获取root身份去执行一次命令,需要此用户被选中为sudoer(要root在/etc/sudoers设置).
/etc/sudoers文件的格式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># Host alias specification</div><div class="line"></div><div class="line"> # User alias specification</div><div class="line">User_Alias ADMPW = kumho, jinhu  # 设置用户集合</div><div class="line"></div><div class="line"> # Cmnd alias specification</div><div class="line">Cmnd_Alias ADMPWCOM=!/usr/bin/passwd, !/usr/bin/passwd root, /usr/bin passwd [A-Za-z]*  # 设置命令集  命令一定要以绝对路径写</div><div class="line"></div><div class="line"> # User privilege specification</div><div class="line"> root    ALL=(ALL:ALL) ALL  # 用户   登录者的来源主机名=(可切换的身份:用户组) 命令</div><div class="line"> ADMPW   ALL=(ALL:ALL) ADMPWCOM</div><div class="line"></div><div class="line"> # Members of the admin group may gain root privileges</div><div class="line"> %admin ALL=(ALL) ALL     #admin用户组成员都是sudoer</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux Shell Script]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-Shell-Script/</url>
      <content type="html"><![CDATA[<h2 id="Script的执行方式"><a href="#Script的执行方式" class="headerlink" title="  Script的执行方式"></a><a name="ch1">  Script的执行方式</a></h2><p>Script执行方式分为直接执行和source执行</p>
<h3 id="直接执行"><a href="#直接执行" class="headerlink" title="直接执行"></a>直接执行</h3><p>其中直接执行,是启动<b>子进程</b>执行Script,父进程休眠,Script中的操作不影响父进程.</p>
<p>可以分为路径执行,PATH执行与sh执行(sh是/bin/bash的硬连接)</p>
<p>这里说下sh执行,sh可以调试script
使用参数-n 不执行script,仅检查语法
使用参数-x 调试模式,显示执行时的script(变量都被准确赋值)</p>
<h3 id="source执行"><a href="#source执行" class="headerlink" title="source执行"></a>source执行</h3><p>父进程中执行,操作会影响父进程</p>
<h2 id="Shell中的数值运算"><a href="#Shell中的数值运算" class="headerlink" title="  Shell中的数值运算"></a><a name="ch2">  Shell中的数值运算</a></h2><p>我们除了可以使用 <code>declare</code>来定义数值型变量外,也可以直接使用<code>$((运算式))</code>来进执行数值处理,比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x=<span class="string">"10"</span></div><div class="line">y=<span class="string">"4"</span></div><div class="line"><span class="built_in">echo</span> $((<span class="variable">$x</span>%<span class="variable">$y</span>))</div></pre></td></tr></table></figure>
<h2 id="test与判断式"><a href="#test与判断式" class="headerlink" title="  test与判断式"></a><a name="ch3">  test与判断式</a></h2><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>我们可以使用<code>test</code>来查看文件是否存在及其属性,也可进行数值比较与字符串比较(这两个也可以在判断式中比较)
以下是test的一部分参数表</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">判断文件存在与类型</td>
<td style="text-align:center">格式 test -e filename</td>
</tr>
<tr>
<td style="text-align:center">-e</td>
<td style="text-align:center">该文件是否存在</td>
</tr>
<tr>
<td style="text-align:center">-f</td>
<td style="text-align:center">该文件是否存在且为文件</td>
</tr>
<tr>
<td style="text-align:center">-d</td>
<td style="text-align:center">该文件是否存在且为目录</td>
</tr>
<tr>
<td style="text-align:center">-b</td>
<td style="text-align:center">该文件是否存在为块设备</td>
</tr>
<tr>
<td style="text-align:center">判断文件权限</td>
<td style="text-align:center">格式 test -r filename</td>
</tr>
<tr>
<td style="text-align:center">-r</td>
<td style="text-align:center">该文件是否可读</td>
</tr>
<tr>
<td style="text-align:center">-w</td>
<td style="text-align:center">该文件是否可写</td>
</tr>
<tr>
<td style="text-align:center">-x</td>
<td style="text-align:center">该文件是否可执行</td>
</tr>
<tr>
<td style="text-align:center">-u</td>
<td style="text-align:center">是否具有SUID</td>
</tr>
<tr>
<td style="text-align:center">-g</td>
<td style="text-align:center">是否具有SGID</td>
</tr>
<tr>
<td style="text-align:center">-k</td>
<td style="text-align:center">是否具有SBIT</td>
</tr>
<tr>
<td style="text-align:center">比较两数值</td>
<td style="text-align:center">test n1 -eq n2</td>
</tr>
<tr>
<td style="text-align:center">-eq</td>
<td style="text-align:center">==</td>
</tr>
<tr>
<td style="text-align:center">-ne</td>
<td style="text-align:center">!=</td>
</tr>
<tr>
<td style="text-align:center">-gt</td>
<td style="text-align:center">&gt;(greater than)</td>
</tr>
<tr>
<td style="text-align:center">-lt</td>
<td style="text-align:center">&lt;</td>
</tr>
<tr>
<td style="text-align:center">-ge</td>
<td style="text-align:center">&gt;=</td>
</tr>
<tr>
<td style="text-align:center">-le</td>
<td style="text-align:center">&lt;=</td>
</tr>
<tr>
<td style="text-align:center">判断字符串数据</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">test str1=str2</td>
<td style="text-align:center">相等</td>
</tr>
<tr>
<td style="text-align:center">test str1!=str2</td>
<td style="text-align:center">不相等</td>
</tr>
<tr>
<td style="text-align:center">多重条件判定</td>
<td style="text-align:center">逻辑操作</td>
</tr>
<tr>
<td style="text-align:center">-a</td>
<td style="text-align:center">AND : test -e file1 -a test -e file2</td>
</tr>
<tr>
<td style="text-align:center">-o</td>
<td style="text-align:center">OR</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">反向:test ! -e file1</td>
</tr>
</tbody>
</table>
<h3 id="判断式"><a href="#判断式" class="headerlink" title="判断式[]"></a>判断式[]</h3><p>判断式基本格式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x=1</div><div class="line">[□$x□-le□0□]</div></pre></td></tr></table></figure>
注意<code>□</code>为空格,在变量/常量/操作符间一定要有空格</p>
<h2 id="shell-script的默认变量"><a href="#shell-script的默认变量" class="headerlink" title="  shell script的默认变量"></a><a name="ch4">  shell script的默认变量</a></h2><p>当我们执行命令时,会带参数(执行操作,文件参数等)
我们在script中怎么读取这些参数,script内置了变量<code>$#</code>,<code>$@</code>,<code>$num</code>来表示这些参数</p>
<ul>
<li><code>$#</code> 参数个数</li>
<li><code>$@</code> 参数列表</li>
<li><code>$num</code> 其中$0表示script名 $1..$num表示第num个参数</li>
</ul>
<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="  程序结构"></a><a name="ch5">  程序结构</a></h2><h3 id="判断结构"><a href="#判断结构" class="headerlink" title="判断结构"></a>判断结构</h3><h4 id="if结构"><a href="#if结构" class="headerlink" title="if结构"></a>if结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if [ 条件1 ] ; then</div><div class="line">     代码段1</div><div class="line">elif [ 条件2 ] ; then</div><div class="line">    代码段2</div><div class="line">esle </div><div class="line">    代码段3</div><div class="line">fi</div></pre></td></tr></table></figure>
<h4 id="swicth结构"><a href="#swicth结构" class="headerlink" title="swicth结构"></a>swicth结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">case $var in</div><div class="line">       constant1 )</div><div class="line">           代码段1</div><div class="line">         ;;</div><div class="line">       constant2 )</div><div class="line">             代码段2</div><div class="line">          ;;</div><div class="line">         * )</div><div class="line">             代码段 </div><div class="line">          ;;</div><div class="line">esac          </div></pre></td></tr></table></figure>
<p>注意这里的swicth不能跨段,就是<code>constant1</code>后一定有<code>;;</code>  <code>constant</code>可以是通配符,比如<code>[Yy]</code></p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="while-done-满足条件循环"><a href="#while-done-满足条件循环" class="headerlink" title="while..done : 满足条件循环"></a>while..done : 满足条件循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">while [ 条件 ]</div><div class="line">do</div><div class="line">   代码段</div><div class="line">done</div></pre></td></tr></table></figure>
<h4 id="utile…done-满足条件终止循环"><a href="#utile…done-满足条件终止循环" class="headerlink" title="utile…done : 满足条件终止循环"></a>utile…done : 满足条件终止循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">util [ 条件 ]</div><div class="line">do</div><div class="line">   代码段</div><div class="line">done</div></pre></td></tr></table></figure>
<h4 id="for…each-循环遍历"><a href="#for…each-循环遍历" class="headerlink" title="for…each : 循环遍历"></a>for…each : 循环遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for var in con1 con2 con3 ...</div><div class="line">do</div><div class="line">   代码段</div><div class="line">done</div></pre></td></tr></table></figure>
<p>例子
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for filename in $(ls -al .)</div><div class="line">do</div><div class="line">    echo $filename</div><div class="line">done</div></pre></td></tr></table></figure></p>
<h4 id="for…done-条件遍历"><a href="#for…done-条件遍历" class="headerlink" title="for…done : 条件遍历"></a>for…done : 条件遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s=0</div><div class="line">for (( i=1 ; i &lt;= $num ; i++ ))</div><div class="line">do</div><div class="line">    s=$(($s+$i))</div><div class="line">done </div></pre></td></tr></table></figure>
<h2 id="function"><a href="#function" class="headerlink" title="  function"></a><a name="ch6">  function</a></h2><p>function需要写在执行之前,因为script执行顺序是<code>从上到下,从左到右</code>
而且function内置有变量,跟script类似
需要返回值是使用<code>return</code>
例子:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function calnum ()&#123;</div><div class="line">  if [ $1 -le 0 ] ; then</div><div class="line">     return 1</div><div class="line">  fi</div><div class="line">   </div><div class="line">   sum=0</div><div class="line">   for (( i=1 ;  i&lt;=$1 ; i++ ))</div><div class="line">   do</div><div class="line">      sum=$(($sum+$i))</div><div class="line">   done</div><div class="line">   echo $sum</div><div class="line">   return 0</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 正则表达式]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="正则表达式-字符的模式"><a href="#正则表达式-字符的模式" class="headerlink" title="正则表达式-字符的模式"></a><a name="ch1">正则表达式-字符的模式</a></h2><h3 id="语系对正则表达式的影响"><a href="#语系对正则表达式的影响" class="headerlink" title="语系对正则表达式的影响"></a><a name="ch1.1">语系对正则表达式的影响</a></h3><p>正则表达式中字符的编码顺序会对正则式匹配的结果造成影响</p>
<p>比如zh_CN和C语系的数字字母编码顺序:</p>
<ul>
<li>LANG=zh_CN :  0 1 2 3 4 … a A b B c C … z Z</li>
<li>LANG=C : 0 1 2 3 4… A B C … Z a b c …z</li>
</ul>
<p>所以我们需要指定编码,通常我们会指定LANG=C  (ASCII码)</p>
<p>为了能规范这种差异,正则表达式中也存在特殊符号来表示一些字符,如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">特殊符号</th>
<th style="text-align:center">代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[:alnum:]</td>
<td style="text-align:center">代表大小写字母和数字,即0-9,A-Z,a-z</td>
</tr>
<tr>
<td style="text-align:center">[:alpha:]</td>
<td style="text-align:center">代表大小写字母,即A-Z,a-z</td>
</tr>
<tr>
<td style="text-align:center">[:blank:]</td>
<td style="text-align:center">空格与[TAB]</td>
</tr>
<tr>
<td style="text-align:center">[:cntrl:]</td>
<td style="text-align:center">键盘上控制键,即CR,LF,TAB,DEL等</td>
</tr>
<tr>
<td style="text-align:center">[:digit:]</td>
<td style="text-align:center">代表数字</td>
</tr>
<tr>
<td style="text-align:center">[:graph:]</td>
<td style="text-align:center">除空格与[TAB]外的其他字符</td>
</tr>
<tr>
<td style="text-align:center">[:lower:]</td>
<td style="text-align:center">小写字母</td>
</tr>
<tr>
<td style="text-align:center">[:upper:]</td>
<td style="text-align:center">大写字母</td>
</tr>
<tr>
<td style="text-align:center">[:print:]</td>
<td style="text-align:center">代表任何可以被打印出来的字符</td>
</tr>
<tr>
<td style="text-align:center">[:space:]</td>
<td style="text-align:center">任何会产生空白的字符,如空格,[TAB],CR等</td>
</tr>
<tr>
<td style="text-align:center">[:punct:]</td>
<td style="text-align:center">代表标点符号,即” ‘ ? ! ; 等</td>
</tr>
<tr>
<td style="text-align:center">[:xdigit:]</td>
<td style="text-align:center">代表十六进制数,即0-9,A-F,a-f</td>
</tr>
</tbody>
</table>
<h3 id="支持正则式的命令"><a href="#支持正则式的命令" class="headerlink" title=" 支持正则式的命令"></a><a name="ch1.2"> 支持正则式的命令</a></h3><h4 id="基础正则式命令-grep"><a href="#基础正则式命令-grep" class="headerlink" title="基础正则式命令: grep"></a>基础正则式命令: grep</h4><p>基础正则式的特殊字符如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">特殊符号</th>
<th style="text-align:center">代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">^word</td>
<td style="text-align:center">待查找字符串word在行首</td>
</tr>
<tr>
<td style="text-align:center">word$</td>
<td style="text-align:center">待查找字符串word在行尾</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">代表一定有一个任意字符</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">转义字符</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">重复零个到无穷个的前一个字符</td>
</tr>
<tr>
<td style="text-align:center">[list]</td>
<td style="text-align:center">匹配list中的任意字符</td>
</tr>
<tr>
<td style="text-align:center">[n1-n2]</td>
<td style="text-align:center">匹配编码从n1-n2的任意字符</td>
</tr>
<tr>
<td style="text-align:center">[^list]</td>
<td style="text-align:center">匹配非list中的任意字符</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td style="text-align:center">重复前一个字符n-m遍</td>
</tr>
</tbody>
</table>
<h4 id="扩展正则式命令-egrep"><a href="#扩展正则式命令-egrep" class="headerlink" title="扩展正则式命令: egrep"></a>扩展正则式命令: egrep</h4><p>egrep与grep一样使用,其支持了更多的特殊字符</p>
<p>扩展正则式的特殊字符如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">特殊符号</th>
<th style="text-align:center">代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">重复一个或一个以上的前一个字符</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">重复零或一个的前一个字符</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>或者</td>
</tr>
<tr>
<td style="text-align:center">()</td>
<td style="text-align:center">匹配组: 如查找glad或good这两个字符,正则式:g(la\</td>
<td>oo)d<br>对比g[la\loo]d 这种正则式没有组合性</td>
</tr>
<tr>
<td style="text-align:center">()+</td>
<td style="text-align:center">重复匹配组</td>
</tr>
</tbody>
</table>
<h4 id="分析stdin并处理筛选命令-sed"><a href="#分析stdin并处理筛选命令-sed" class="headerlink" title="分析stdin并处理筛选命令: sed"></a>分析stdin并处理筛选命令: sed</h4><p>sed工具:分析stdin,并可以对数据进行替换/删除/增加/选取特定行的功能</p>
<p>sed的格式: <code>sed [-nefri] function</code></p>
<p>命令参数:</p>
<ul>
<li><code>n</code> 打印模式</li>
<li><code>e</code> 直接在命令行处理,当进行多个function动作时须要指定</li>
<li><code>i</code> 直接修改文件</li>
<li><code>r</code> 使sed支持扩展正则式(默认支持基础正则式)</li>
<li><code>f</code> 将function写到文件中,读取该文件进行动作</li>
</ul>
<p>function参数:</p>
<ul>
<li><code>a</code> 新增,形如’n1a str’ : 在当前第n1行后增加str行</li>
<li><code>c</code> 替换, 形如’n1,n2c str’,用str替换n1到n2行</li>
<li><code>d</code> 删除, 形如’n1,n2d’,删除n1到n2行,删除n1到最后(n1,$d)</li>
<li><code>i</code>  插入,形如’n1i str’,在当前第n1行前增加str行</li>
<li><code>p</code> 打印,形如’n1,n2p’,打印n1到n2行,须要加-n</li>
<li><code>s</code> 替换,形如’s/str1/str2/g’ 全文搜索,将str2代替str1</li>
</ul>
<h3 id="文件格式化命令"><a href="#文件格式化命令" class="headerlink" title=" 文件格式化命令"></a><a name="ch1.3"> 文件格式化命令</a></h3><h4 id="格式化打印-printf"><a href="#格式化打印-printf" class="headerlink" title="格式化打印:printf"></a>格式化打印:printf</h4><p>printf不是管道命令,其处理的是文本数据,当读取文件时,须先提出文件的内容,如$(cat filename)</p>
<p>printf的基本格式:<code>printf &#39;打印格式&#39; 文本内容</code>
其中打印格式如C语言的printf</p>
<p>比如我要打印如下格式的文本(test.txt),并去掉Name行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Name    Chinese    English   Math    Average</div><div class="line">DmTsai      80         60     70       70</div><div class="line">VBrid        70        60    65        65</div></pre></td></tr></table></figure>
<p>可以使用如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printf &apos;%10s %5d %5d %5d %5.2f&apos; $(cat test.txt|grep -v &apos;Name&apos;)</div></pre></td></tr></table></figure>
<h4 id="字段处理-awk"><a href="#字段处理-awk" class="headerlink" title="字段处理:awk"></a>字段处理:awk</h4><p>awk是管道命令. 其用分隔符(默认是空格或[TAB])将一行分隔成多个字段,并用变量$0,$1,$2…$n来表示整行,第1个字段,第2个字段…第n个字段</p>
<p>awk的基本格式 awk ‘条件1{动作1} 条件2{动作2}… 条件n{动作n}’ filename</p>
<p>awk内置的变量</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量名称</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$n</td>
<td style="text-align:center">n为数字,其中0表示整行,其他表示第n个字段</td>
</tr>
<tr>
<td style="text-align:center">NF</td>
<td style="text-align:center">每一行($0)的字段总数</td>
</tr>
<tr>
<td style="text-align:center">NR</td>
<td style="text-align:center">目前awk处理的当前行号</td>
</tr>
<tr>
<td style="text-align:center">FS</td>
<td style="text-align:center">目前的分隔符,默认是空格,设置分隔符可以 ‘BEGIN {FS=”str”}’</td>
</tr>
</tbody>
</table>
<p>awk的条件逻辑运算符是<code>&gt; &lt; &gt;= &lt;= == !=</code></p>
<p>例子:将1.3.1的例子test.txt添加总分字段’Total’,重新打印处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat test.txt | \</div><div class="line">&gt; awk &apos; NR==1 &#123;printf &quot;%10s  %10s  %10s  %10s  %10s  %10s\n&quot;, $1,$2,$3,$4,$5,&quot;Total&quot;&#125;</div><div class="line">&gt; NR&gt;=2 &#123;total=$2+$3+$4 printf &quot;%10s  %10d %10d %10d %10.2f %10.2f&quot;,$1,$2,$3,$4,$5,total&#125;&apos;</div></pre></td></tr></table></figure>
<h4 id="文件比较及补丁-diff与patch"><a href="#文件比较及补丁-diff与patch" class="headerlink" title="文件比较及补丁:diff与patch"></a>文件比较及补丁:diff与patch</h4><p>当我们比较两个相识(新旧版本)的文本文件时,可以使用diff filename1 filename2
如果是打出补丁文件 <code>diff -Naur filename1 filename2 &gt; filename.patch</code></p>
<p>对文件进行补丁 <code>patch -p0 &lt; filename.patch</code> (新旧文件同目录中)</p>
<p>还原文件 <code>patch -R -p0 &lt; filename.patch</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 认识Bash]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E8%AE%A4%E8%AF%86Bash/</url>
      <content type="html"><![CDATA[<h2 id="认识Bash"><a href="#认识Bash" class="headerlink" title="  认识Bash"></a><a name="ch1">  认识Bash</a></h2><h3 id="硬件-内核-Shell"><a href="#硬件-内核-Shell" class="headerlink" title="  硬件/内核/Shell"></a><a name="ch1.1">  硬件/内核/Shell</a></h3><p>硬件/内核/Shell三者关系如下图:
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_21_1.jpg?raw=true" alt=""></p>
<p>就是说:Shell是一个应用程序,解析用户输入(点击鼠标/键盘)的命令,然后去调用相应的应用程序完成功能</p>
<h3 id="系统上的Shell"><a href="#系统上的Shell" class="headerlink" title="  系统上的Shell"></a><a name="ch1.2">  系统上的Shell</a></h3><p>一个Linux下支持多种的Shell,它们在/etc/shells这个文件中
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/bin/sh  (第一个流行的Shell,已被Bash代替)</div><div class="line">/bin/bash (兼容sh,Linux默认的Shell)</div><div class="line">/bin/tcsh  (整合C shell)</div><div class="line">/bin/ksh  (兼容Bash)</div></pre></td></tr></table></figure><br>系统会为每个登陆的用户指定一个Shell,当然也有no-login的Shell,我们可以在/etc/passwd中查看到用户指定的Shell</p>
<h3 id="Bash的功能"><a href="#Bash的功能" class="headerlink" title="  Bash的功能"></a><a name="ch1.3">  Bash的功能</a></h3><ul>
<li>命令记忆能力(history)<ul>
<li>历史命令记录在~/.bash_history里中,默认记录$HISTSIZE条,当用户注销系统后,历史命令才会写到~/.bash_history(强制写入history -w)</li>
</ul>
</li>
<li>命令与文件补齐([TAB])</li>
<li>命令别名设置(alias)</li>
<li>作业控制/前台与后台控制(job control/foreground/background)</li>
<li>程序脚本(shell script)</li>
</ul>
<h3 id="查看命令的类型-type"><a href="#查看命令的类型-type" class="headerlink" title="  查看命令的类型(type)"></a><a name="ch1.4">  查看命令的类型(type)</a></h3><p>当我们在终端执行命令时,命令可分为alias别名命令,bash内置命令,外部程序</p>
<p>我们可以使用<code>type 命令名</code>查看此命令的类型</p>
<h2 id="Shell的变量"><a href="#Shell的变量" class="headerlink" title="  Shell的变量"></a><a name="ch2">  Shell的变量</a></h2><h3 id="变量的显示与设置"><a href="#变量的显示与设置" class="headerlink" title="  变量的显示与设置"></a><a name="ch2.1">  变量的显示与设置</a></h3><blockquote>
<p>变量的显示 : echo
echo $varname 或者 echo ${varname}       </p>
</blockquote>
<p>.</p>
<blockquote>
<p>变量的设置规则</p>
<ol>
<li>变量与变量值以一个等号”=”连接,如<code>var=value</code></li>
<li>等号两边不能直接接空格,如<code>var= value</code>(错误的)</li>
<li>变量名只能是英文或数字,不能以数字开头</li>
<li>变量值若有空格可以用””或’’括起来,其中””保持特殊字符的原本特性,’’则将特殊字符视为一般字符</li>
<li>可以使用转义字符”\”转义特殊字符</li>
<li>如要定义变量时引用另一个变量的值,如<code>path=&quot;$path:other&quot;</code>或<code>path=${path}:other</code></li>
<li>定义变量时引用命令处理结果,可以使用$(command)</li>
<li>环境变量(子进程可以使用的变量,通过bash开启子进程)用export来定义变量</li>
<li>自定义变量名用小写,系统变量用大写</li>
</ol>
</blockquote>
<p>.</p>
<blockquote>
<p>变量的取消: unset varname</p>
</blockquote>
<h3 id="变量的有效范围"><a href="#变量的有效范围" class="headerlink" title="  变量的有效范围"></a><a name="ch2.2">  变量的有效范围</a></h3><p>变量分为一般变量与环境变量,环境变量可以在子进程中引用,也叫全局变量.
当启动一个Shell,操作系统会分配一个内存记录块给Shell的进程维护.
进程使用<code>export</code>,将一般变量写到其的内存记录块中.
当启动子进程,子进程将父进程的内存记录块中的信息导入自己的环境变量块中.</p>
<p>我们使用<code>export</code>将一般变量转出环境变量
<code>bash</code>启动子进程后,父进程会sleep</p>
<h3 id="查看系统的变量"><a href="#查看系统的变量" class="headerlink" title="  查看系统的变量"></a><a name="ch2.3">  查看系统的变量</a></h3><blockquote>
<p>查看环境变量 : env</p>
<ul>
<li>HOME :  用户主文件夹</li>
<li>SHELL: 用户使用的Shell</li>
<li>HISTSIZE: 历史命令条数</li>
<li>PATH : 执行文件查找路径</li>
<li>LANG : 语系</li>
<li>RANDOM: 生成随机数</li>
</ul>
</blockquote>
<p>.</p>
<blockquote>
<p>查看所有变量(含环境变量及自定义变量) : set</p>
<ul>
<li>PS1 : 命令提示符</li>
<li>$ : 关于此Shell的PID</li>
<li>? : 上个命令的回传码,0表示执行成功</li>
<li><ul>
<li>: 被unset的变量</li>
</ul>
</li>
<li>OSTYPE: 操作系统类型</li>
<li>HOSTTYPE: 主机架构,i686 x86_64等</li>
</ul>
</blockquote>
<p>.</p>
<blockquote>
<p>查看系统当前支持的语系 : locale</p>
<ul>
<li>如果用户需要设置shell的语系,可以设置LANG或LC_ALL的值(注销后失效)</li>
<li>如果要设置系统的语系,需要在/etc/sysconfig/i18n(CentOS)或/etc/default/locale(ubuntu)设置</li>
</ul>
</blockquote>
<h3 id="变量值键盘读取-声明变量类型"><a href="#变量值键盘读取-声明变量类型" class="headerlink" title="  变量值键盘读取/声明变量类型"></a><a name="ch2.4">  变量值键盘读取/声明变量类型</a></h3><blockquote>
<p>变量值键盘读取 : read</p>
<ul>
<li>格式 : read [-pt] varname</li>
<li><code>p</code>: 接提示符  </li>
<li><code>t</code>:等待时限</li>
</ul>
</blockquote>
<p>.</p>
<blockquote>
<p>声明变量类型: declare/typeset</p>
<ul>
<li>格式: declare [-aixr] varname</li>
<li><code>a</code> 定义数组变量</li>
<li><code>i</code> 定义整型变量</li>
<li><code>x</code> 定义环境变量</li>
<li><code>r</code> 定义readonly变量<br>注意: 我们读取数组变量值时,需要使用${varname[1]},${varname[2]}这种格式(所以我们读取变量时最好习惯成${varname})</li>
</ul>
</blockquote>
<h3 id="变量值的删除-替换-测试"><a href="#变量值的删除-替换-测试" class="headerlink" title="  变量值的删除/替换/测试"></a><a name="ch2.5">  变量值的删除/替换/测试</a></h3><p>变量值的删除与替换设置方式如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量设置方式</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">${变量#关键字}</td>
<td style="text-align:center">若变量值从头开始的数据,则将符合的最短数据删除</td>
<td style="text-align:center">从头开始,最短匹配</td>
</tr>
<tr>
<td style="text-align:center">${变量##关键字}</td>
<td style="text-align:center">若变量值从头开始的数据,则将符合的最长数据删除</td>
<td style="text-align:center">从头开始,最长匹配</td>
</tr>
<tr>
<td style="text-align:center">${变量%关键字}</td>
<td style="text-align:center">若变量值从尾开始的数据,则将符合的最短数据删除</td>
<td style="text-align:center">从尾开始,最短匹配</td>
</tr>
<tr>
<td style="text-align:center">${变量%%关键字}</td>
<td style="text-align:center">若变量值从尾开始的数据,则将符合的最长数据删除</td>
<td style="text-align:center">从尾开始,最长匹配</td>
</tr>
<tr>
<td style="text-align:center">${变量/旧字符/新字符}</td>
<td style="text-align:center">将变量值中第一个符合旧字符的数据替换</td>
<td style="text-align:center">第一个替换</td>
</tr>
<tr>
<td style="text-align:center">${变量//旧字符/新字符}</td>
<td style="text-align:center">将变量值中全部符合旧字符的数据替换</td>
<td style="text-align:center">全部替换</td>
</tr>
</tbody>
</table>
<p>测试变量值的测试方式如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量设置方式</th>
<th style="text-align:center">var没有设置</th>
<th style="text-align:center">var为空字符</th>
<th style="text-align:center">var已设置非空字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">testvar=${var?tipstr}</td>
<td style="text-align:center">将tipstr输出至stderr</td>
<td style="text-align:center">testvar=</td>
<td style="text-align:center">testvar=var</td>
</tr>
<tr>
<td style="text-align:center">testvar=${var:?tipstr}</td>
<td style="text-align:center">将tipstr输出至stderr</td>
<td style="text-align:center">将tipstr输出至stderr</td>
<td style="text-align:center">testvar=var</td>
</tr>
</tbody>
</table>
<h2 id="Bash的操作环境"><a href="#Bash的操作环境" class="headerlink" title="  Bash的操作环境"></a><a name="ch3">  Bash的操作环境</a></h2><h3 id="命令查找顺序"><a href="#命令查找顺序" class="headerlink" title="  命令查找顺序"></a><a name="ch3.1">  命令查找顺序</a></h3><ol>
<li>以相对/绝对路径执行的命令alias</li>
<li>由alias找到此别名命令来执行</li>
<li>由bash内置的builitin命令执行</li>
<li>通过$PATH查找执行</li>
</ol>
<h3 id="命令别名与历史命令"><a href="#命令别名与历史命令" class="headerlink" title="  命令别名与历史命令"></a><a name="ch3.2">  命令别名与历史命令</a></h3><blockquote>
<p>命令别名: alias</p>
<ul>
<li>查看当前系统内的别名命令 : <code>alias</code></li>
<li>设置别名命令 : <code>alias name=commad</code></li>
<li>取消别名命令 : <code>unalias name</code></li>
</ul>
</blockquote>
<p>.</p>
<blockquote>
<p>历史命令: history</p>
<ul>
<li>列出目前内存中的历史命令 : hitory ([-n]:表示最近n条命令)</li>
<li>历史命令默认保存在~/.bash_history中,最大保存$HISTSIZE条,当Shell注销时,就会将内存中的历史命令写入~/.bash_history(强制写入hitory -w) </li>
</ul>
</blockquote>
<h3 id="Bash的欢迎与登录信息"><a href="#Bash的欢迎与登录信息" class="headerlink" title="  Bash的欢迎与登录信息"></a><a name="ch3.3">  Bash的欢迎与登录信息</a></h3><p><code>/etc/issue</code>  记录Bash的欢迎信息
<code>/etc/issue.net</code> 记录远程Bash的欢迎信息
<code>/etc/motd</code>  记录用户登录后提示的信息</p>
<h3 id="Bash的环境配置文件"><a href="#Bash的环境配置文件" class="headerlink" title="  Bash的环境配置文件"></a><a name="ch3.4">  Bash的环境配置文件</a></h3><p>我们需要将设置好的环境(如命令别名,自定义变量)写入到bash的环境配置文件中才能持久生效,否则在注销后都会失效.</p>
<p>那要写入到哪个bash的环境配置文件?
bash分为”login shell” 与”non-login shell”,两者读取的环境配置文件有差异,如下图所示:
<img src="https://github.com/HiKumho/blog/blob/master/img/bash%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B%20.png?raw=true" alt=""></p>
<p>当我们需要设置bash环境时,可以在~/.bashrc中设置</p>
<p>其他的bash配置文件:</p>
<ul>
<li>~/.bash_logout: 用户注销后所执行的操作</li>
<li>~/.bash_history: 记录历史命令</li>
<li>/etc/man.config: 关于man手册查找路径</li>
</ul>
<h3 id="Bash的通配符与特殊符号"><a href="#Bash的通配符与特殊符号" class="headerlink" title="  Bash的通配符与特殊符号"></a><a name="ch3.5">  Bash的通配符与特殊符号</a></h3><p>常用通配符如下表:</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">代表0到无穷多个任意字符</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">一定有1个任意字符</td>
</tr>
<tr>
<td style="text-align:center">[]</td>
<td style="text-align:center">代表一定有一个[]内的字符</td>
</tr>
<tr>
<td style="text-align:center">[-]</td>
<td style="text-align:center">代表编码顺序内的所有字符</td>
</tr>
<tr>
<td style="text-align:center">[^]</td>
<td style="text-align:center">代表含有非[]内的字符</td>
</tr>
</tbody>
</table>
<p>bash的特殊符号如下表:</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">#</td>
<td style="text-align:center">注释符号</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">转义符号</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td>管道</td>
</tr>
<tr>
<td style="text-align:center">;</td>
<td style="text-align:center">连续命令执行分隔符</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">用户主目录</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">变量前导符</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">作业控制,将命令变成后台工作</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">逻辑非</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">目录符号</td>
</tr>
<tr>
<td style="text-align:center">&gt;,&gt;&gt;</td>
<td style="text-align:center">数据重定向,输出导向,分别是’替换’与’累加’</td>
</tr>
<tr>
<td style="text-align:center">&lt;,&lt;&lt;</td>
<td style="text-align:center">数据重定向,输入导向,&lt;&lt;后接一个尾符,表示遇到此尾符,结束输入</td>
</tr>
<tr>
<td style="text-align:center">‘’</td>
<td style="text-align:center">单引号,特殊字符转为一般字符</td>
</tr>
<tr>
<td style="text-align:center">“”</td>
<td style="text-align:center">双引号,特殊字符保持殊性</td>
</tr>
<tr>
<td style="text-align:center">``</td>
<td style="text-align:center">先执行的命令,可使用$()代替</td>
</tr>
<tr>
<td style="text-align:center">{}</td>
<td style="text-align:center">命令块组合</td>
</tr>
</tbody>
</table>
<h2 id="数据重定向"><a href="#数据重定向" class="headerlink" title="  数据重定向"></a><a name="ch4">  数据重定向</a></h2><p>当我们执行一个命令是输出结果信息或错误信息都是输到屏幕上的,这两个流我们称为标准输出(stdout)与标准错误输出(stderr),此外还有一个从文件读入数据的流称为标准输入(stdin)</p>
<p>可是当我们想将输出信息输出到文件时,此时不能使用stdout/stderr流,我们需要将它们导向,故称为数据重定向</p>
<p>数据重定向的特殊字符规则如下:</p>
<ol>
<li>标准输入(stdin),代码为0,使用&lt;或&lt;&lt;</li>
<li>标准输出(stdout),代码为1,使用&gt;或&gt;&gt;</li>
<li>标准错误输出(stderr),代码为2,使用2&gt;或2&gt;&gt;</li>
</ol>
<p>例子:</p>
<ol>
<li>查看根目录文件信息并输出到~/rootfile中: <code>ll / &gt; ~/rootfile</code> (文件不存在,会自动创建)</li>
<li>查找/home中文件名为.bashrc并添加至~/rootfile中 : <code>find /home -name .bashrc &gt;&gt; ~/rootfile</code></li>
<li>将ll filename的错误信息丢弃 : <code>ll filename 2&gt; /dev/null</code></li>
<li>将ll filename的结果信息及错误信息一同显示在~/rootfile中 <code>ll filename &gt; ~/rootfile 2&gt;&amp;1</code></li>
<li>将~/.bashrc的数据导进~/rootfile中 : <code>cat &gt; ~/rootfile &lt; ~/.bashrc</code></li>
<li>从键盘输入信息到~/rootfile,并以”eof”表示结束输入 : <code>cat &gt; ~/rootfile &lt;&lt;&quot;eof&quot;</code></li>
</ol>
<h2 id="命令执行次序判断"><a href="#命令执行次序判断" class="headerlink" title="  命令执行次序判断"></a><a name="ch5">  命令执行次序判断</a></h2><p>当我们有一批命令需依次执行时,需要判断命令执行的次序.</p>
<ul>
<li>多命令不存在相关性: cmd;cmd;cmd;<ul>
<li>连续执行多个不相关的命令,使用<code>;</code>分隔命令</li>
</ul>
</li>
<li>多命令存在相关性: &amp;&amp;与||<ul>
<li>连续执行多个相关命令时,存在且与或的情况</li>
<li><code>cmd1&amp;&amp;cmd2</code>  表示cmd1正确执行($?=0)时,才会执行cmd2</li>
<li><code>cmd1||cmd2</code> 表示cmd1正确执行($?=0)时,就不会去执行cmd2</li>
</ul>
</li>
</ul>
<h2 id="管道命令"><a href="#管道命令" class="headerlink" title="  管道命令"></a><a name="ch6">  管道命令</a></h2><p>管道命令仅能处理stdout流传来的数据,对于stderr流会忽视,其将前一个命令的stdout流作为stdin输入,处理加工后再作为stdout输出,其中管道命令中用<code>-</code>表示stdin或stdout</p>
<h3 id="选取命令-cut-grep"><a href="#选取命令-cut-grep" class="headerlink" title="  选取命令:cut/grep"></a><a name="ch6.1">  选取命令:cut/grep</a></h3><ul>
<li><code>cut</code> : 选段命令(先分段)<ul>
<li>格式  <code>cut -d &#39;分隔符&#39; -f num -c 字符范围</code>  (num是段号 字符范围表示第几个字符到第几个字符,通常分段后,不用c)</li>
<li>例子: 选择PATH中的第1个目录 : <code>echo $PATH | cut -d &quot;:&quot; -f 1</code></li>
</ul>
</li>
<li><code>grep</code> : 正则选行命令,利用正则分析一行的数据,满足则选择<ul>
<li>格式 <code>grep [-acinv] 查找字符 filename</code></li>
<li>参数<ul>
<li><code>a</code>  将二进制文件以文本文件方式查找</li>
<li><code>c</code>  统计满足查找字符的次数</li>
<li><code>i</code>  忽视大小写</li>
<li><code>n</code> 输出行号</li>
<li><code>v</code> 反向选择</li>
<li>例子 : 查找root的登录信息 <code>last | grep &#39;root&#39;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="排序命令-sort-wc-uniq"><a href="#排序命令-sort-wc-uniq" class="headerlink" title="  排序命令:sort/wc/uniq"></a><a name="ch6.2">  排序命令:sort/wc/uniq</a></h3><ul>
<li><code>sort</code> : 排序命令<ul>
<li>格式 : <code>sort [-fbnrutk] file或stdin</code></li>
<li>参数:<ul>
<li><code>f</code> 忽略大小写</li>
<li><code>b</code> 忽略最前面空格</li>
<li><code>n</code> 比较数值进行排序</li>
<li><code>r</code> 反向排序</li>
<li><code>u</code> uniq 唯一行</li>
<li><code>t</code> 分隔符</li>
<li><code>k</code> 进行比较的分隔区间</li>
</ul>
</li>
<li>例子 : 将/etc/passwd以”:”分割,并以第3个分隔区间进行比较排序 <code>cat /etc/passwd | sort -t &#39;:&#39; -k 3</code></li>
</ul>
</li>
<li><code>wc</code> : 统计命令<ul>
<li>格式 : wc [-lwm] stdin 或 file</li>
<li>参数 : <ul>
<li><code>l</code>  列出行数</li>
<li><code>m</code> 列出字符数</li>
<li><code>w</code> 列出单字数</li>
</ul>
</li>
</ul>
</li>
<li><code>uniq</code> : 唯一命令<ul>
<li>格式 : <code>uniq [-ic]</code></li>
<li>参数:<ul>
<li><code>i</code> 忽略大小写</li>
<li><code>c</code> 进行计数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="双向重定向-tee"><a href="#双向重定向-tee" class="headerlink" title="  双向重定向:tee"></a><a name="ch6.3">  双向重定向:tee</a></h3><p><code>tee</code>可以将stdout转存到文件,并以同样的数据往下传递(即 tee可以将数据同时流向文件和屏幕)</p>
<p>例子:将用户登录信息存到last.list并显示在屏幕上<br><code>last | tee ~/last.list | more</code></p>
<h3 id="字符转换命令"><a href="#字符转换命令" class="headerlink" title="  字符转换命令"></a><a name="ch6.4">  字符转换命令</a></h3><ul>
<li><code>tr</code> : 字符串删除与替换,默认是替换,加<code>-d</code>表示删除字符</li>
<li><code>col</code> : 将[TAB]转换为空格键</li>
<li><code>expand</code> : 将[TAB]转换为空格</li>
<li><code>join</code> :  比较两个文件,并将其比较字段相同的行,拼接在一起</li>
<li><code>paste</code> : 将两个文件的每一行对于行号,拼接在一起</li>
</ul>
<h3 id="切割命令"><a href="#切割命令" class="headerlink" title="  切割命令"></a><a name="ch6.5">  切割命令</a></h3><ul>
<li><code>split</code> : 可以将一个文件切割成多个小文件<ul>
<li>格式 : <code>split [bl] file PREFIX</code></li>
<li>参数:<ul>
<li><code>b</code> 切割小文件的大小,单位可是b,k,m</li>
<li><code>l</code>  以行数来切割文件</li>
<li><code>PREFIX</code> 小文件的前缀文件名<ul>
<li>例子:<br>将50M的文件file1切割成10个以a开头的小文件 <code>split -b 5M file1 a</code><br>将这10个小文件复原 <code>cat a* &gt; file1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="参数代换-xargs"><a href="#参数代换-xargs" class="headerlink" title="  参数代换:xargs"></a><a name="ch6.6">  参数代换:xargs</a></h3><ul>
<li><code>xargs</code> : 将stdin流分隔成参数给其他命令执行(使得这些命令可以在管道后处理)<ul>
<li>例子 : 查找/sbin中权限包含7000的文件并以ls -l形式输出<br><code>find /sbin -perm +7000 | xargs ls -l</code></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 事件处理]]></title>
      <url>http://yoursite.com/2016/09/06/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="事件响应优先度"><a href="#事件响应优先度" class="headerlink" title="   事件响应优先度"></a><a name="ch1">   事件响应优先度</a></h2><p>Android事件触发后响应的优先度:监听器&gt;组件本身的回调&gt;Activity的回调,比如下面的例子
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity_2_1_5</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_test_2_1_5);</div><div class="line">        View v=findViewById(R.id.drawView);</div><div class="line">        v.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">                Toast.makeText(TestActivity_2_1_5.<span class="keyword">this</span>,<span class="string">"a"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        Toast.makeText(<span class="keyword">this</span>,<span class="string">"c"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == event) <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">        Toast.makeText(getContext(),<span class="string">"b"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
当点击<code>DrawView</code>时,会依次弹出<code>a</code>,<code>b</code>,<code>c</code>的消息,说明响应事件的顺序是监听器&gt;组件本身的回调&gt;Activity的回调</p>
<p>此外这里有些事件处理返回的是<code>false</code>,它表示此方法未能处理完事件,并将其传递出去处理,返回<code>true</code>则不传递,已处理完.所以上面的响应顺序也可以是传递顺序</p>
<h2 id="Handler消息传递机制"><a href="#Handler消息传递机制" class="headerlink" title="  Handler消息传递机制"></a><a name="ch2">  Handler消息传递机制</a></h2><h3 id="Handler是做什么的"><a href="#Handler是做什么的" class="headerlink" title="  Handler是做什么的?"></a><a name="ch2.1">  Handler是做什么的?</a></h3><p>当程序启动时,Android会启动一条主线程维护该程序,主线程负责处理UI组件,UI组件状态的更新只能在主线程中,所以主线程也称UI线程.</p>
<p>如果我们需要在子线程中更新UI组件,怎么办?
这时我们需要用到Handler,Handler可以在子线程中发送消息,并在主线程接受到这些消息并处理UI组件.(也可说Hanlder通知主线程去如何处理)</p>
<h3 id="Handler发送-接收的消息保存在哪"><a href="#Handler发送-接收的消息保存在哪" class="headerlink" title="  Handler发送/接收的消息保存在哪?"></a><a name="ch2.2">  Handler发送/接收的消息保存在哪?</a></h3><p>Handler发送/接收的消息保存在MessageQueue(消息队列)中,由于它是队列,所以消息是先进先出的</p>
<h3 id="Handler怎么从MessageQueue中发送-接收消息"><a href="#Handler怎么从MessageQueue中发送-接收消息" class="headerlink" title="  Handler怎么从MessageQueue中发送/接收消息?"></a><a name="ch2.3">  Handler怎么从MessageQueue中发送/接收消息?</a></h3><p>MessageQueue由一个Looper对象维护着,一个线程只能拥有一个Looper对象,初始化Looper(<code>Looper.prepare()</code>)时绑定了当前的线程,当Looper调用<code>loop()</code>后,Looper会死循环从MessageQueue中读出消息,而Looper将MessageQueue暴露给Handler,让Handler添加消息</p>
<h3 id="Handler的生存期-作用域"><a href="#Handler的生存期-作用域" class="headerlink" title="  Handler的生存期/作用域"></a><a name="ch2.4">  Handler的生存期/作用域</a></h3><p>Handler的生存期是创建其的线程,而线程会调用Looper.loop()进入一个死循环的状态.</p>
<p>Handler的作用域也是创建其的线程,在2.1情况中的Handler是主线程维护的Handler,所以可以在其中处理UI,<b>而由子线程维护的Handler也是不能处理UI组件</b></p>
<h3 id="怎么使用Handler"><a href="#怎么使用Handler" class="headerlink" title="  怎么使用Handler"></a><a name="ch2.5">  怎么使用Handler</a></h3><p>在主线程中,系统会初始化一个Looper对象,我们可以直接在主线程中创建Handler对象并使用</p>
<p>在子线程中,我们需要自己初始化Looper对象,并创建Handler对象,最后设置Looper.loop死循环</p>
<p>下面是子线程创建Hanlder对象的例子
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">               Looper.prepare();   <span class="comment">//初始化Looper和MessageQueue</span></div><div class="line">               mHandler=<span class="keyword">new</span> Handler()&#123;</div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">                       <span class="keyword">if</span>(msg.what!=<span class="number">0x101</span>) <span class="keyword">return</span>;</div><div class="line">                       <span class="comment">//root.setBackgroundColor(getResources().getColor(holo_red_dark));  //不能更新UI,因为此线程不是UI线程</span></div><div class="line">                       Toast.makeText(TestActivity_3_5_2.<span class="keyword">this</span>,<span class="string">"ChildThread"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">                   &#125;</div><div class="line">               &#125;;</div><div class="line">               mHandler.sendEmptyMessage(<span class="number">0x101</span>);  <span class="comment">//此时消息不是发送到UI线程,而是此线程</span></div><div class="line">               Looper.loop(); <span class="comment">//不断从MessageQueue中取出消息,此线程进入死循环,不能在loop()后做其他事情</span></div><div class="line">           &#125;</div><div class="line">       &#125;).start();</div></pre></td></tr></table></figure></p>
<h2 id="异步任务-AsyncTask"><a href="#异步任务-AsyncTask" class="headerlink" title="  异步任务(AsyncTask)"></a><a name="ch3">  异步任务(AsyncTask)</a></h2><p>使用AsyncTask遵守的规则:</p>
<ol>
<li>必须在主线程中创建AsyncTask实例</li>
<li>必须在主线程调用AsyncTask的execute方法(只能被执行一次)</li>
<li>实现AsyncTask的doInBackground / onProgressUpdate /  onPreExecute / onPostExecute / publishProgress</li>
</ol>
<p>下面例子是异步加载网页HTML的程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">**</div><div class="line"> * 异步加载网页HTML</div><div class="line"> *</div><div class="line"> * <span class="meta">@author</span> Kumho</div><div class="line"> * <span class="meta">@date</span> <span class="number">16</span>-<span class="number">7</span>-<span class="number">26</span></div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity_3_6</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/* 文本组件 .*/</span></div><div class="line">    <span class="keyword">private</span> TextView mTextView;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_test_3_6);</div><div class="line">        mTextView = (TextView) findViewById(R.id.textView_1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        <span class="comment">// "下载"按钮点击</span></div><div class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"preDowning"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">        DownTask mTask = <span class="keyword">new</span> DownTask(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mTask.execute(<span class="keyword">new</span> URL(<span class="string">"http://www.oschina.net"</span>)); <span class="comment">//加载网页  一个异步任务对象只能执行一次</span></div><div class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 异步任务AsyncTask&lt;Params, Progress, Result&gt;</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DownTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">URL</span>, <span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/* 任务结果 .*/</span></div><div class="line">        <span class="keyword">private</span> StringBuffer mResult = <span class="keyword">new</span> StringBuffer();</div><div class="line">        <span class="comment">/* 显示进度对话框 .*/</span></div><div class="line">        <span class="keyword">private</span> ProgressDialog mDialog;</div><div class="line">        <span class="comment">/* 环境 .*/</span></div><div class="line">        <span class="keyword">private</span> Context mContext;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DownTask</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">            mContext = context;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 后台执行的任务</div><div class="line">         * <span class="doctag">@param</span> params 任务参数</div><div class="line">         * <span class="doctag">@return</span></div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(URL... params)</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                URLConnection mConn = params[<span class="number">0</span>].openConnection();</div><div class="line">                <span class="comment">// 打开输入流</span></div><div class="line">                BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(mConn.getInputStream(), <span class="string">"utf-8"</span>));</div><div class="line">                String line = reader.readLine();</div><div class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 已读入的行数</span></div><div class="line">                <span class="keyword">while</span> (<span class="keyword">null</span> != line) &#123;</div><div class="line">                    mResult.append(line + <span class="string">"/n"</span>);</div><div class="line">                    publishProgress(i++);  <span class="comment">//通知当前状态更新</span></div><div class="line">                    line = reader.readLine();</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> mResult.toString();</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 更新当前状态</div><div class="line">         * <span class="doctag">@param</span> values 进度描述</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span> </span>&#123;</div><div class="line">            <span class="comment">//mDialog.setProgress(values[0]);</span></div><div class="line">            mTextView.append(<span class="string">"读入第"</span> + values[<span class="number">0</span>] + <span class="string">"行"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 预处理</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</div><div class="line">            mDialog = <span class="keyword">new</span> ProgressDialog(mContext);</div><div class="line">            mDialog.setTitle(<span class="string">"任务正在执行中"</span>); <span class="comment">//设置标题</span></div><div class="line">            mDialog.setCancelable(<span class="keyword">false</span>); <span class="comment">//设置不能撤销</span></div><div class="line">            mDialog.setMessage(<span class="string">"请稍等.."</span>);</div><div class="line">            mDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER); <span class="comment">//水平进度条</span></div><div class="line">            mDialog.setIndeterminate(<span class="keyword">false</span>); <span class="comment">//不显示进度</span></div><div class="line">            mDialog.show();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 完成后执行</div><div class="line">         * <span class="doctag">@param</span> s 完成结果</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == s) mTextView.setText(<span class="string">"没有获取到数据"</span>);</div><div class="line">            <span class="keyword">else</span> mTextView.setText(s);</div><div class="line">            mDialog.dismiss();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 文件与文件系统的压缩与打包]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85/</url>
      <content type="html"><![CDATA[<h2 id="压缩技术与常见的压缩文件"><a href="#压缩技术与常见的压缩文件" class="headerlink" title="  压缩技术与常见的压缩文件"></a><a name="ch1">  压缩技术与常见的压缩文件</a></h2><ul>
<li>压缩技术说明:<ul>
<li>压缩技术:通过一些算法去将原本文件进行压缩,以减少文件所占用的硬盘空间(比如计算机通常用1byte表示数值1,其实我们用1bit就可以表示,压缩技术将没用到的空间都省去)</li>
<li>压缩比:原文件容量/压缩文件容量</li>
</ul>
</li>
<li>压缩文件好处:<ul>
<li>减少硬盘空间的浪费</li>
<li>网络传送压缩文件,减少网站带宽(单位时间内链路能够通过的数据量)</li>
</ul>
</li>
<li>常见的压缩文件拓展名:<ul>
<li><em>.tar / </em>.tar.gz / <em>.tar.bz2 / </em>.bz2 / <em>.gz / </em>.zip</li>
<li>拓展名:只是方便我们知道此文件是用什么命令压缩出来的</li>
</ul>
</li>
</ul>
<h2 id="常见的压缩或打包命令"><a href="#常见的压缩或打包命令" class="headerlink" title="  常见的压缩或打包命令"></a><a name="ch2">  常见的压缩或打包命令</a></h2><ul>
<li>常见的压缩命令:<ul>
<li><code>gzip</code> : 单一文件压缩,其新建的压缩文件为<code>*.gz</code><ul>
<li>压缩   :  <code>gzip 待压缩文件名</code></li>
<li>解压缩: <code>gzip -d 压缩文件</code></li>
<li>查看纯文本压缩文件内容 :  <code>zcat 压缩文件</code> </li>
</ul>
</li>
<li><code>bzip2</code> : 单一文件压缩,其新建的压缩文件为<code>*.bz2</code>,压缩比较<code>gzip</code>大<ul>
<li>压缩  : <code>bzip2  待压缩文件名</code></li>
<li>解压缩: <code>bzip2 -d 压缩文件</code></li>
<li>查看纯文本压缩文件内容: <code>bzcat 压缩文件</code></li>
</ul>
</li>
</ul>
</li>
<li>常见的打包命令:<ul>
<li>打包:对于多文件压缩处理</li>
<li><code>tar</code>: 其打包的文件拓展名 <code>*.tar</code> <code>*.tar.gz</code> <code>*.tar.bz2</code> 可以不用压缩执行,单纯打包,拓展名为<code>*.tar</code><ul>
<li>格式: <code>tar [-j|-z] [-c|-x] [-v] [-f 压缩文件名] filename1....</code></li>
<li>参数:<code>j</code>-打包时用<code>bzip2</code>压缩 <code>z</code>-打包时用<code>gz</code>压缩   <code>c</code>-压缩  <code>x</code>-解压缩 <code>t</code>-查看压缩文件内容</li>
<li>压缩: <code>tar -jcv -f 压缩文件名.tar.bz2 需压缩的文件/目录名...</code></li>
<li>查看: <code>tar -jtv -f 压缩文件名</code> (<code>j</code>可以用<code>z</code>代替,具体看压缩文件拓展名)</li>
<li>解压缩: <code>tar -jxv -f 压缩文件名 -C 放置解压后文件的目录</code><ul>
<li><code>zip</code>: 其打包的文件拓展名 <code>*.zip</code> </li>
</ul>
</li>
<li>压缩: <code>zip -r 压缩文件 需压缩的文件/目录....</code></li>
<li>解压: <code>unzip 压缩文件</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="备份与恢复命令"><a href="#备份与恢复命令" class="headerlink" title="  备份与恢复命令"></a><a name="ch3">  备份与恢复命令</a></h2><ul>
<li><code>dump</code>:可以备份文件系统或单一目录<ul>
<li>格式 : <code>dump [-Suvj] [-level] [-f 备份文件名] 待备份数据</code></li>
<li>常见参数:<ul>
<li><code>S</code>  计算备份某数据需要多少硬盘空间</li>
<li><code>level</code>  备份等级<code>0</code>完全备份 <code>1</code>相较<code>0</code>更新的部分备份 <code>n</code>相较<code>n-1</code>更新的部分备份,备份单一目录只能使用<code>0</code></li>
<li><code>u</code> 将这次dump时间记录到<code>/etc/dumpdateS</code>文件中, 备份单一目录不能使用</li>
<li><code>j</code> 加入<code>bzip2</code>支持</li>
<li><code>f</code> 后接备份文件名</li>
<li><code>v</code> 显示进度</li>
</ul>
</li>
<li>常用备份命令 <code>dump -0 -u -f 备份文件名 备份数据</code>,比如备份文件名是<code>/root/boot.dump</code> 备份数据是<code>/boot</code></li>
</ul>
</li>
<li><code>restore</code>: 恢复<code>dump</code>压缩的备份<ul>
<li>查看<code>dump</code>后的备份数据内容: <code>restore -t -f 备份文件名</code></li>
<li>完成恢复 <code>restore -r -f 备份文件名</code></li>
<li>部分恢复 <code>restore -i -f 备份文件名</code> 进入部分恢复程序,需将要备份的文件加入队列中,才会解压<ul>
<li>add file : 加入解压队列</li>
<li>delete file : 从解压队列中移除</li>
<li>extract : 执行解压队列</li>
</ul>
</li>
</ul>
</li>
<li><code>dd</code>: 备份文件(不能是目录,可以是整块硬盘,或者一个分区),制作文件<ul>
<li>格式 <code>dd if=inputFile of=outputFile bs=blockSize count=blockNum</code></li>
<li><code>if</code> 输入文件,可以是普通文件/设备文件等</li>
<li><code>of</code> 输出文件,备份文件</li>
<li><code>bs</code> block大小 不标注单位,默认是字节</li>
<li><code>count</code> block数量</li>
<li>例子:<ul>
<li>将自己硬盘的第一个扇区备份 : <code>dd if=/dev/sda of=/tmp/mbr.back bs=512 count=1</code></li>
<li>将<code>/etc/passwd</code>备份 : <code>dd if=/etc/passwd of=/tmp/passwd.back</code></li>
<li>制作一个500M的文件 : <code>dd if=/dev/zero of=/tmp/mfile bs=1M count=500</code></li>
</ul>
</li>
</ul>
</li>
<li><code>cpio</code>: 需要搭配<code>find</code>使用的备份命令<ul>
<li>例子:<ul>
<li>备份: 将/boot目录进行备份输出为/tmp/boot.cpio <code>find /boot | cpio -oBvc &gt; /tmp/boot.cpio</code></li>
<li>查看:查看备份文件的内容 <code>cpio -itvc &lt; /tmp/boot.cpio</code></li>
<li>恢复:<code>cpio -iduvc &lt; /tmp/boot.cpio</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="刻录光盘"><a href="#刻录光盘" class="headerlink" title="  刻录光盘"></a><a name="ch4">  刻录光盘</a></h2><p>刻录光盘的步骤:</p>
<ol>
<li>将数据制作成镜像文件(ISO,一种能被刻录机识别的压缩格式),利用mkisofs命令</li>
<li>将镜像文件刻录至光盘(CD/DVD),利用cdrecord命令</li>
</ol>
<ul>
<li><code>mkisofs</code>: 制作镜像文件<ul>
<li>格式 : <code>mkisofs [-r -v] [-o 镜像文件] [-m file] [-graft-point iso中的文件=Linux系统中的文件] [待备份数据]</code></li>
<li><code>r</code> 记录较多的信息</li>
<li><code>v</code> 显示构建过程</li>
<li><code>m</code> 后接排除的文件</li>
<li><code>graft-point</code>:镜像文件中的目录=实际Linux文件系统的目录,因为多目录数据做成ISO,目录结构会乱,通常指定数据在镜像中的目录(这命令就是往镜像文件中加入数据了)</li>
</ul>
</li>
<li><code>cdrecord</code>:光盘刻录工具<ul>
<li>光盘刻录的步骤<ul>
<li>检查刻录机所在: <code>cdrecord -scanbus</code> 观察<code>CD-ROM</code>所在条目 例如<code>4,0,0 400) &#39;TSSTcorp&#39; &#39;DVD+-RW SU-208CB&#39; &#39;D200&#39; Removable CD-ROM</code>,记录下此条目最前的设备编号<code>4,0,0</code></li>
<li>抹除光盘原始内容: <code>cdrecord -v dev=4,0,0(设备编号) blank=fast</code></li>
<li>刻录CD : <code>cdrecord -v dev=4,0,0 fs=8m -dummy -data 镜像文件</code></li>
<li>刻录DVD : <code>cdrecore -v dev=4,0,0 fs=8m -data -sao driveropts=burnfree 镜像文件</code></li>
<li>测试 : <code>mount /dev/cdrom 挂载点</code></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 磁盘与文件系统管理]]></title>
      <url>http://yoursite.com/2016/09/06/Linux-%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="Linux的文件系统与VFS"><a href="#Linux的文件系统与VFS" class="headerlink" title=" Linux的文件系统与VFS"></a><a name="ch1"> Linux的文件系统与VFS</a></h2><h3 id="Linux支持的文件系统"><a href="#Linux支持的文件系统" class="headerlink" title=" Linux支持的文件系统"></a><a name="ch1.1"> Linux支持的文件系统</a></h3><ul>
<li>目前Linux的标准文件系统是ext4,它支持1EB(=1024^6B)的最大分区以及16TB的最大文件系统容量,向下兼容ext3(增加日志功能),ext2.</li>
<li>Linux常见的支持文件系统有:<ul>
<li>传统文件系统:ext2/minix/MS-DOS/FAT(Windows使用)/iso9660(光盘)等</li>
<li>日志文件系统:ext3/ext4/ReiserFS/Windows’NTFS/IBM’s JFS/SGI’s XFS</li>
<li>网络文件系统:NFS/SMBFS</li>
</ul>
</li>
<li>查看自己的Linux系统支持的文件系统以及目前已加载到内存中的文件系统       <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ls <span class="_">-l</span> /lib/modules/$(uname -r)/kernel/fs</div><div class="line"><span class="comment">#查看系统支持的文件系统</span></div><div class="line"><span class="comment">#$(uname -r):查看系统的内核版本号</span></div><div class="line"></div><div class="line">cat /proc/filesystems </div><div class="line"><span class="comment">#查看目前已加载到内存中的文件系统</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Linux-VFS"><a href="#Linux-VFS" class="headerlink" title=" Linux VFS"></a><a name="ch1.2"> Linux VFS</a></h3><p>虚拟文件系统(Virtual FileSystem Switch,VFS),管理Liunx所支持的各种文件系统,对上提供给系统调用封装好的接口,对下调用各文件系统模块.整个VFS缩略图如下:
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_18_1.gif?raw=true" alt=""></p>
<h3 id="Linux的Ext2文件系统"><a href="#Linux的Ext2文件系统" class="headerlink" title="  Linux的Ext2文件系统"></a><a name="ch1.3">  Linux的Ext2文件系统</a></h3><ul>
<li>Ext2文件系统<ul>
<li>将文件的属性(权限,所有者等)以及文件实际数据存放在不同的块中</li>
<li>文件属性存放在inode中,一个文件对应一个inode,并记录此文件数据所用的block块号</li>
<li>实际数据存放在block块中,一个文件可以有多个block,一个block块只能放一个文件的数据</li>
<li>此外用superblock块来记录整个文件系统的整体信息(如inode,block总量,使用量,剩余量等,<b>这些信息在格式化时就规划好</b>)</li>
<li>其是索引式文件系统,通过先访问文件的inode节点,再一次性从其所指的block中取出数据</li>
<li>而FAT文件系统没有inode存在,每个block都记录着其下一个block号码,需依次访问block</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>Ext2文件系统示意图<br><img src="https://github.com/HiKumho/blog/blob/master/img/blog_18_2.jpg?raw=true" alt=""></li>
</ul>
<p><br></p>
<ul>
<li>块组(block group)  <br> Ext2文件系统格式化时规划好多个块组,每个块组都有独立的superblock/block/inode系统,这样便于管理</li>
</ul>
<p><br></p>
<ul>
<li>超级块(superblock)<ul>
<li>superblock记录整个文件系统相关信息,没有superblock就没有文件系统,记录的信息:<ul>
<li>block与inode的总量与使用情况</li>
<li>block与inode的大小</li>
<li>文件系统的挂载时间/最近写入数据时间等</li>
<li>除了第一个block group含superblock外,其他的block group可以不含</li>
<li>superblock大小为1024bytes</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>超级块与启动扇区(boot sector)<ul>
<li>superblock与boot sector都是占1024bytes</li>
<li>boot sector后存放superblock的信息</li>
<li>如果一个block块&gt; bytes(2k,4k)时,文件系统第一个block块存放boot sector与superblock,否则分两个block来存放</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>文件系统描述说明<ul>
<li>描述每个block group开始与结束的block号</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>块对应表(block bitmap)与inode对应表(inode bitmap)<ul>
<li>使用位示图记录block与inode的使用情况</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>数据块(data block)<ul>
<li>Ext2所支持block大小有1KB,2KB,4KB,其对应的最大单一文件容量与最大文件系统容量都不同</li>
<li>block大小与数量在格式化完就不能够再改变(除非重新格式化)</li>
<li>每个block内最多只能够放置<b>一个文件</b>的数据</li>
<li>如果一个block不足以容纳一个文件,会使用多个block</li>
<li>如文件小于block大小,则此block剩下空间不再使用(硬盘空间浪费)</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>inode table<ul>
<li>inode记录了文件属性及权限</li>
<li>每个inode固定大小128bytes</li>
<li>每个文件仅会使用一个inode</li>
<li>文件系统能创建的文件数量与inode数量有关(在格式化时已规划好inode数量)</li>
<li>系统读取文件时需要先查找indoe,并分析inode所记录的权限是否跟用户符合,满足才会去读取block的内容</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>数据存放区与中间数据(metadata)<ul>
<li>数据存放区:inode table与data block</li>
<li>中间数据:super block,block bitmap,inode bitmap</li>
<li>中间数据经常变动</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>inode怎么记录block号?<br>inode记录一个block号码用4bytes,为了让一个inode能记录下更多的block号,其记录block的区域分为12个直接连接,1个间接连接,1个双间接连接,1个三间接连接,inode结构图如下:
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_18_3.jpg?raw=true" alt=""></li>
</ul>
<p><br></p>
<ul>
<li>inode能记录下多少个block,1KB的block最大单一文件容量?<ul>
<li>12个直接连接:12个block</li>
<li>1个间接连接:以1KB的block为例,其能存放256个block(1KB/4B)</li>
<li>1个双间接连接:256x256个block</li>
<li>1个三间接连接:256^3个block</li>
<li>1KB的block,一个inode能记录的block号数n=12+256+256^2+256^3,最大单一文件容量=nx1KB</li>
</ul>
</li>
</ul>
<h3 id="Ext2文件系统与目录树的关系"><a href="#Ext2文件系统与目录树的关系" class="headerlink" title=" Ext2文件系统与目录树的关系"></a><a name="ch1.4"> Ext2文件系统与目录树的关系</a></h3><ul>
<li>目录<ul>
<li>Ext2会分配一个inode与至少一块的block记录目录</li>
<li>inode记录目录的相关属性与权限,还有对应的block号码</li>
<li>block记录目录下的子文件的文件名与其inode号码</li>
</ul>
</li>
<li>文件<ul>
<li>Ext2会分配一个inode与相对该文件大小的block数量</li>
<li>inode记录文件属性与权限,和对应的block号码</li>
<li>block记录文件的实际数据</li>
</ul>
</li>
<li>系统读取某文件数据的流程<ul>
<li>例子:读取/etc/passwd中数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">kumho@kumho-Inspiron-3421:~$ ls -dil / /etc /etc/passwd</div><div class="line">     2 drwxr-xr-x  22 root root  4096  7月 18 16:49 /</div><div class="line">784897 drwxr-xr-x 135 root root 12288  7月 24 17:16 /etc</div><div class="line">812534 -rw-r--r--   1 root root  1899  7月 18 21:50 /etc/passwd</div><div class="line"></div></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>/的inode<br>通过挂载点信息找到inode为2的根目录inode,判断用户是否具有x,r权限,有则读取/的block</li>
<li>/的block<br>上步骤取得block号码,并找到/etc的inode号码(784897)</li>
<li>/etc的inode<br>访问/etc的inode,判断用户是否具有需要的权限,有则读取/etc的block</li>
<li>/etc的block<br>找到./passwd的inode(812534)</li>
<li>/etc/passwd的inode<br>访问/etc/passwd的inode,判断用户是否具有需要的权限,有则获取其block号</li>
<li>/etc/passwd的block<br>从block中读取数据</li>
</ol>
</li>
</ul>
<h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title=" 日志文件系统"></a><a name="ch1.5"> 日志文件系统</a></h3><p>日志文件系统保护了数据的完整,避免不当的操作或突发情况造成数据的损坏,可以<b>恢复数据</b></p>
<p>写入/修改文件时的流程:</p>
<ul>
<li>预备: 系统会在日志记录区记录某个文件准备要写入的信息</li>
<li>写入阶段:写入文件数据与属性,更新中间数据(inode bitmap,block bitmap,superblock等)</li>
<li>结束:在日志记录区标志此文件写入结束(如果没有此标志,数据就不完整,需要进行恢复)</li>
</ul>
<h3 id="文件系统与内存"><a href="#文件系统与内存" class="headerlink" title=" 文件系统与内存"></a><a name="ch1.6"> 文件系统与内存</a></h3><p>Linux为了解决文件频繁写入硬盘中,效率慢,采用异步处理,将数据先加载至内存中,内存中的某块数据被用户修改后,会设置Dirty标志,系统会不定时将带Dirty标志的数据写回硬盘,用户可以用<code>sync</code>将内存中的数据写回硬盘(关机时,系统会自动调用sync)</p>
<h3 id="挂载点"><a href="#挂载点" class="headerlink" title=" 挂载点"></a><a name="ch1.7"> 挂载点</a></h3><p>一个文件系统的最顶层目录是挂载点,可以知道挂载点一定是目录,其inode编号通常为2.
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mount /dev/sda12 /mnt/usr</span></div><div class="line"><span class="comment"># ls -dil /mnt/usr /</span></div><div class="line">2 drwxr-xr-x 22 root root 4096  7月 18 16:49 /</div><div class="line">2 drwxr-xr-x  3 root root 1024  7月 24 20:56 /mnt/usr</div></pre></td></tr></table></figure>
通常我们判断是否为同一个文件是查看其inode编号</p>
<h2 id="连接文件-ln"><a href="#连接文件-ln" class="headerlink" title=" 连接文件:ln"></a><a name="ch2"> 连接文件:ln</a></h2><p>Linux连接文件有两种,一种是硬连接(hard link),一种是类似Windows的快捷方式,称为符号连接(symbolil link),两种都使用命令<code>ln</code>来实现</p>
<p><br></p>
<ul>
<li>硬连接<ul>
<li>使用命令 <code>ln 源文件名 连接文件名</code></li>
<li>硬连接只是在某个目录下新建一个文件名到某inode号的关联记录,不产生实际文件</li>
<li>当我们查看源文件与硬连接文件的inode,它们是一样的</li>
<li>被硬连接的inode节点,其连接数会+1</li>
<li>硬连接不能跨文件系统</li>
<li>硬连接不能连接目录<br><img src="https://github.com/HiKumho/blog/blob/master/img/blog_18_4.gif?raw=true" alt=""></li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>符号连接<ul>
<li>使用命令 <code>ln -s 源文件名 连接文件名</code></li>
<li>创建一个独立的文件,这文件的数据读取会指向其连接那个文件的文件名</li>
<li>符号连接产生的文件,其容量就是被连接文件的文件名的字符数
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_18_5.gif?raw=true" alt=""></li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>关于删除文件的疑问?<ul>
<li>我们将源文件删除,硬连接仍可以读取到数据(因为指向的是inode),符号连接则不能读取数据(因为指向的是文件名)</li>
<li>那么删除文件只是将目录下其关联记录删除吗?(我倾向Yes)</li>
<li>那么能指定inode编号给某文件吗?(比如我将文件删除后,我知道其inode,是否可以恢复)</li>
<li>还是说系统只会将连接数为0的inode节点对应的数据清除掉</li>
</ul>
</li>
</ul>
<h2 id="查看文件系统及硬盘状况"><a href="#查看文件系统及硬盘状况" class="headerlink" title=" 查看文件系统及硬盘状况"></a><a name="ch3"> 查看文件系统及硬盘状况</a></h2><h3 id="查看某文件系统的超级块"><a href="#查看某文件系统的超级块" class="headerlink" title=" 查看某文件系统的超级块"></a><a name="ch3.1"> 查看某文件系统的超级块</a></h3><ul>
<li>使用命令<code>dumpe2fs [-bh] 设备文件名</code><ul>
<li><code>h</code> 仅列出超级块信息(缺省)</li>
</ul>
</li>
</ul>
<h3 id="查看系统内的文件系统-当前系统挂载情况"><a href="#查看系统内的文件系统-当前系统挂载情况" class="headerlink" title=" 查看系统内的文件系统(当前系统挂载情况)"></a><a name="ch3.2"> 查看系统内的文件系统(当前系统挂载情况)</a></h3><ul>
<li>使用命令<code>df [-ahikHTml] [目录或文件名]</code> 或使用<code>mount -l</code><ul>
<li><code>a</code>:列出所有文件系统hl</li>
<li><code>h</code>:以GB/MB/KB等格式显示文件系统容量</li>
<li><code>i</code>:不用硬盘容量,而以inode数量来显示</li>
<li><code>l</code>:显示本地的所有文件系统</li>
<li>如果带目录/文件参数,则列出其所在文件系统的情况</li>
<li>比较常用<code>df -hl</code></li>
</ul>
</li>
</ul>
<h3 id="查看某文件的容量"><a href="#查看某文件的容量" class="headerlink" title=" 查看某文件的容量"></a><a name="ch3.3"> 查看某文件的容量</a></h3><ul>
<li>使用命令<code>du [-ahskm] 目录/文件名</code><ul>
<li><code>s</code>:列出总量,不细致列出子文件的各占用容量</li>
<li><code>h</code>:以GB/MB/KB等格式显示文件容量</li>
<li><code>m</code>:以MB列出容量显示</li>
</ul>
</li>
</ul>
<h3 id="查看硬盘分区情况"><a href="#查看硬盘分区情况" class="headerlink" title=" 查看硬盘分区情况"></a><a name="ch3.4"> 查看硬盘分区情况</a></h3><ul>
<li>使用命令<code>fdisk -l</code>列出当前硬盘的所有分区</li>
<li><code>fdisk</code>也是我们创建/删除分区的命令</li>
</ul>
<h3 id="查看硬盘某分区的UUID"><a href="#查看硬盘某分区的UUID" class="headerlink" title=" 查看硬盘某分区的UUID"></a><a name="ch3.5"> 查看硬盘某分区的UUID</a></h3><ul>
<li>使用命令 <code>blkid 设备文件名</code></li>
</ul>
<h2 id="硬盘的分区-格式化-检验与挂载"><a href="#硬盘的分区-格式化-检验与挂载" class="headerlink" title=" 硬盘的分区/格式化/检验与挂载"></a><a name="ch4"> 硬盘的分区/格式化/检验与挂载</a></h2><h3 id="硬盘的分区"><a href="#硬盘的分区" class="headerlink" title=" 硬盘的分区"></a><a name="ch4.1"> 硬盘的分区</a></h3><p>使用命令<code>fdisk 文件设备名</code> 比如<code>fdisk /dev/sda</code> 注意<code>/dev/sda</code>代表整块硬盘,不能使用<code>/dev/sda1</code>某分区</p>
<p>使用命令后进入<code>fdisk</code>程序区,相关的子命令:</p>
<ul>
<li><code>n</code> 增加分区</li>
<li><code>d</code> 删除分区</li>
<li><code>p</code> 打印分区表</li>
<li><code>q</code> 不执行前面操作后退出</li>
<li><code>w</code> 执行前面的操作后退出</li>
</ul>
<p>当我们新建完分区后,系统提示我们重启,让内核能重新查找分区表</p>
<p>当然我们可以用<code>partprobe</code>强制让内核查找分区表<strike>(我自己试着不行,格式化还是找不到分区),或者使用<code>mount -o remount,rw,auto /</code>强制让根目录重新挂载</strike></p>
<h3 id="文件系统格式化"><a href="#文件系统格式化" class="headerlink" title=" 文件系统格式化"></a><a name="ch4.2"> 文件系统格式化</a></h3><p>对某分区进行格式化,主要是将文件系统的相关信息写入到分区中(不写入这些信息,系统怎么知道你这块分区是什么类型的文件系统呢)</p>
<p>使用命令<code>mkfs [-t 文件系统格式] 设备文件名</code></p>
<p>如果想知道<code>mkfs</code>支持哪些文件系统的格式化,可以<code>mkfs[TAB][TAB]</code></p>
<h3 id="硬盘检验"><a href="#硬盘检验" class="headerlink" title=" 硬盘检验"></a><a name="ch4.3"> 硬盘检验</a></h3><ul>
<li><code>fsck</code> : 检验文件系统是否出错<ul>
<li>格式: <code>fsck [-t 文件系统] [-Aayc] 设备名称</code></li>
<li>常用参数:<ul>
<li><code>a</code>:自动修复检查到的有问题扇区</li>
<li><code>y</code>:与<code>a</code>类似,某些文件系统仅支持<code>y</code></li>
</ul>
</li>
</ul>
</li>
<li><code>badblocks</code> : 检验硬盘扇区坏轨命令</li>
</ul>
<h3 id="硬盘挂载与卸载"><a href="#硬盘挂载与卸载" class="headerlink" title=" 硬盘挂载与卸载"></a><a name="ch4.4"> 硬盘挂载与卸载</a></h3><ul>
<li>硬盘挂载需注意的地方:<ul>
<li>挂载点应是空目录(首先是目录,而且空,如果不为空,挂载点目录原数据会暂时隐藏,卸载后出现)</li>
<li>单一文件系统不应该挂载到不同目录</li>
<li>单一目录不应该挂载多个文件系统</li>
<li>设备需要卸载后,才能退出</li>
<li>使用命令:
<code>mount [-t 文件系统] [-L label名] [-o 额外选项] 设备文件名 挂载点</code></li>
<li>通常<code>mount /dev/sda6 /mnt/usr</code>这个格式就行        </li>
</ul>
</li>
<li>硬盘卸载<ul>
<li>命令:<code>umount [-fn] 设备文件名/挂载点</code> <code>f</code>强制卸载       </li>
</ul>
</li>
<li>重新挂载根目录<ul>
<li>命令:<code>mount -o remount,rw,auto /</code></li>
</ul>
</li>
<li>挂载目录到另一个目录(做目录的硬连接)<ul>
<li>命令:<code>mount --bind /dir1 /dir2</code> <code>dir1</code>与<code>dir2</code>的inode相同</li>
</ul>
</li>
</ul>
<h3 id="硬盘参数修改"><a href="#硬盘参数修改" class="headerlink" title=" 硬盘参数修改"></a><a name="ch4.5"> 硬盘参数修改</a></h3><ul>
<li><code>mknod</code>  设置不同类型设备文件<ul>
<li>格式 <code>mknod 设备文件名 [bcp] [Major] [Minor]</code></li>
<li>参数:<ul>
<li><code>b</code> 设置设备文件为一个外部存储文件,如硬盘等</li>
<li><code>c</code> 设置设备文件为一个外部输入文件,如鼠标/键盘等</li>
<li><code>p</code> 设置设备文件为管道</li>
<li><code>Major</code> 主设备代码</li>
<li><code>Minor</code> 次设备代码</li>
<li>主设备与次设备代码决定一个设备文件</li>
</ul>
</li>
</ul>
</li>
<li><code>e2label</code>  设置设备文件的卷标名<ul>
<li>格式: <code>e2label 设备文件名 卷标名</code></li>
</ul>
</li>
<li><code>hdparm</code> 测试性能<ul>
<li>使用命令<code>hdparm -Tt 设备文件</code></li>
</ul>
</li>
</ul>
<h3 id="开机挂载"><a href="#开机挂载" class="headerlink" title=" 开机挂载"></a><a name="ch4.6"> 开机挂载</a></h3><p>开机挂载需要将挂载条目添加至<code>/etc/fstab</code>文件中,之后使用<code>mount -a</code>进行测试(按着<code>/etc/fstab</code>重新挂载)</p>
<h3 id="特殊设备loop挂载"><a href="#特殊设备loop挂载" class="headerlink" title=" 特殊设备loop挂载"></a><a name="ch4.7"> 特殊设备loop挂载</a></h3><ul>
<li>挂载镜像文件<br>使用命令:<code>mount -o loop 镜像文件名 挂载点</code><br>挂载好后,就可以直接从挂载点访问到镜像文件中的数据</li>
<li>使用大容量文件作为分区挂载<ul>
<li>新建大容量文件(大约等同于新建分区操作)<ul>
<li>使用命令: <code>dd if=/dev/zero of=文件名 bs=块大小 count=块数量</code></li>
<li>例如:<code>dd if=/dev/zero of=/home/loopdev bs=1M count=512</code><ul>
<li><code>if</code> 输入文件,<code>/dev/zero</code>一直输出00</li>
<li><code>of</code> 输出文件,将数据00写入of中</li>
<li>文件大小=块大小x块数据,这里=512M</li>
</ul>
</li>
</ul>
</li>
<li>格式化文件<ul>
<li>上例 <code>mount -t ext3 /home/loopdev</code></li>
</ul>
</li>
<li>挂载<ul>
<li>上例 <code>mount -o loop /home/loopdev 挂载点</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存交换空间-Swap-的构建"><a href="#内存交换空间-Swap-的构建" class="headerlink" title=" 内存交换空间(Swap)的构建"></a><a name="ch5"> 内存交换空间(Swap)的构建</a></h2><p>Swap:系统物理内存不足时,将数据移到Swap空间</p>
<p>Swap构建分以下两种方式</p>
<ul>
<li>创建一个分区来构建Swap</li>
<li>创建一个大容量文件来构建Swap</li>
</ul>
<p>构建Swap的步骤:</p>
<ol>
<li>创建分区/文件: 创建分区使用<code>fdisk</code>,创建大容量文件使用上节的命令<code>dd if=/dev/zero of=文件名 bs=块大小 count=块数量</code></li>
<li>格式化 : 使用<code>mkswap 文件名</code></li>
<li>加载/卸载 : 加载文件使用<code>swapon 文件名</code> 卸载文件使用<code>swapoff 文件名</code></li>
<li>查看:使用<code>free</code>查看内存使用情况</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android UI组件]]></title>
      <url>http://yoursite.com/2016/09/06/Android-UI%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/HiKumho/blog/blob/master/img/Android_UI_Widget.png?raw=true" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 文件与目录管理]]></title>
      <url>http://yoursite.com/2016/09/05/Linux-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="目录与路径"><a href="#目录与路径" class="headerlink" title="  目录与路径"></a><a name="ch1">  目录与路径</a></h2><h3 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="  相对路径与绝对路径"></a><a name="ch1.1">  相对路径与绝对路径</a></h3><ul>
<li>相对路径：路径一定由根目录／写起</li>
<li>绝对路径：路径不是由根目录／写起</li>
</ul>
<h3 id="特殊的目录符号"><a href="#特殊的目录符号" class="headerlink" title="  特殊的目录符号"></a><a name="ch1.2">  特殊的目录符号</a></h3><ul>
<li><b>.</b>   : 代表当前目录</li>
<li><b>..</b>  :代表上一层目录</li>
<li><b>-</b>  :代表前一个工作目录</li>
<li><b>~</b> :代表当前用户的主目录</li>
<li><b>~username</b>:代表username用户的主目录</li>
</ul>
<p><em>注意</em> : 根目录的上层目录(<b>..</b>)就是其本身</p>
<h3 id="关于执行文件路径的变量"><a href="#关于执行文件路径的变量" class="headerlink" title="  关于执行文件路径的变量"></a><a name="ch1.3">  关于执行文件路径的变量</a></h3><p>1. 环境变量PATH的含义
当我们在执行一个命令时,可以直接输入命令名执行,即使不在此命令的目录下又没有输入命令的绝对路径,为什么?
原因是:当我们直接输入命令名时,系统会去搜索PATH变量下包含的目录,找到第一匹配的命令程序就调用.        </p>
<p>2. PATH的结构
PATH由一堆目录所组成,每个目录中间用:隔开,每个目录有顺序之分.</p>
<p>3.  查看环境变量PATH
首先我们来查看当前用户的环境变量PATH是什么?执行以下命令
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># echo $PATH</span></div><div class="line">/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin</div><div class="line"></div><div class="line">kumho@kumho-Inspiron-3421:~$ <span class="built_in">echo</span> <span class="variable">$PATH</span></div><div class="line">/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin:/usr/<span class="built_in">local</span>/games:/usr/games</div></pre></td></tr></table></figure> 
从上面可以知道,不同用户的PATH可以不一样
echo命令有打印的功能, $代表后面接变量,不然echo PATH直接输出PATH</p>
<p>4. 修改PATH路径中
下面将/root加入到PATH路径中
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PATH=<span class="string">"<span class="variable">$PATH</span>"</span>:/root</div></pre></td></tr></table></figure></p>
<p>5. PATH的总结</p>
<ul>
<li>不同身份用户默认PATH不同,默认能够执行的命令也不同</li>
<li>PATH可以修改</li>
<li>使用绝对路径或相对路径直接执行某个命令,比PATH更准确</li>
<li>命令应该放到正确的目录下,执行较方便</li>
<li>从安全考虑,本目录(.)最好不要加到PATH当中</li>
</ul>
<h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="  文件与目录管理"></a><a name="ch2">  文件与目录管理</a></h2><h3 id="切换目录与显示当前目录"><a href="#切换目录与显示当前目录" class="headerlink" title="  切换目录与显示当前目录"></a><a name="ch2.1">  切换目录与显示当前目录</a></h3><ul>
<li><code>cd</code> : 切换目录</li>
<li><code>pwd</code> : 显示当前目录<br><code>pwd [-P]</code> <code>-P</code>可以获取正确的目录路径,即使目标文件是连接文件,也会显示实际文件的路径</li>
</ul>
<h3 id="新建目录与删除目录"><a href="#新建目录与删除目录" class="headerlink" title="  新建目录与删除目录"></a><a name="ch2.2">  新建目录与删除目录</a></h3><ul>
<li><code>mkdir</code> : 新建一个新目录<br><code>mkdir [-mp] 目录名</code> <code>-m</code>直接设置目录权限 <code>-p</code>级联创建目录</li>
<li><code>rmdir</code> : 删除空目录<br><code>rmdir [-p] 目录名</code> <code>-p</code>级联删除空目录,注意一定是要空目录</li>
</ul>
<h3 id="查看文件与目录"><a href="#查看文件与目录" class="headerlink" title="  查看文件与目录"></a><a name="ch2.3">  查看文件与目录</a></h3><ul>
<li><code>ls</code>: 查看目录与文件信息        <ul>
<li>格式: <code>ls [-aAdfFhilnrRst] [--time={atime,ctime,mtime}] 目录名称</code></li>
<li>常用参数: <ul>
<li><code>-a</code>: 列出全部文件(包含 . , .. , 隐藏文件 , 一般文件/目录)      </li>
<li><code>-d</code>: 仅列出本目录或者本文件的信息</li>
<li><code>-l</code>:  以长数据串形式列出目录/文件信息,包含文件属性与权限等</li>
<li><code>-s</code>: 列出全部隐藏文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="复制文件-目录以及创建连接文件"><a href="#复制文件-目录以及创建连接文件" class="headerlink" title="  复制文件/目录以及创建连接文件"></a><a name="ch2.4">  复制文件/目录以及创建连接文件</a></h3><ul>
<li><code>cp</code>: 复制文件或目录/创建连接文件(快捷方式)<ul>
<li>格式:  <code>cp [options] source1 source2 source3... direcotry</code></li>
<li>常用参数: <ul>
<li><code>-r</code>: 级联复制,用于目录的复制行为</li>
<li><code>-p</code>: 连同文件属性一起复制,而非使用默认属性(常用备份),注意ctime不会复制源文件,ctime会记录当前时间 atime及mtime会复制源文件</li>
<li><code>-d</code>: 若源文件是连接文件,则复制连接文件而不是实际文件</li>
<li><code>-i</code> : 若目标文件已存在,则询问是否复制</li>
<li><code>-a</code>:相当与<code>-pdr</code></li>
<li><code>-s</code>:复制文件成为连接文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="移除文件-目录"><a href="#移除文件-目录" class="headerlink" title="  移除文件/目录"></a><a name="ch2.5">  移除文件/目录</a></h3><ul>
<li><code>rm</code>: 移除文件/目录(不进回收站)<ul>
<li>格式: <code>rm [-fir] 文件/目录名</code></li>
<li>常用参数: <ul>
<li><code>-r</code>: 级联删除</li>
<li><code>-i</code>: 删除前询问用户是否执行</li>
<li><code>-f</code>: 忽略不存在的文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="移动文件-目录或者更名"><a href="#移动文件-目录或者更名" class="headerlink" title="  移动文件/目录或者更名"></a><a name="ch2.6">  移动文件/目录或者更名</a></h3><ul>
<li><code>mv</code>: 移动文件/目录或者更名<ul>
<li>格式: <code>mv [options] source1 source2 source3...direcotry</code>|<code>mv [options] source destiantion</code></li>
<li>常用参数: <ul>
<li><code>-i</code>:若目标文件存在,询问覆盖</li>
<li><code>-u</code>:若目标文件存在,且比目标文件新,才会覆盖</li>
<li><code>-f</code>:直接覆盖,不理会目标文件是否存在</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="取得路径的文件-目录名"><a href="#取得路径的文件-目录名" class="headerlink" title="  取得路径的文件/目录名"></a><a name="ch2.7">  取得路径的文件/目录名</a></h3><ul>
<li><code>basename</code> : 取得路径的文件<ul>
<li>格式 : <code>basename path</code></li>
</ul>
</li>
<li><code>dirname</code>: 取得路径的目录名<ul>
<li>格式 : <code>dirname path</code></li>
</ul>
</li>
</ul>
<h3 id="新建文件与修改文件-目录的时间"><a href="#新建文件与修改文件-目录的时间" class="headerlink" title="  新建文件与修改文件/目录的时间"></a><a name="ch2.8">  新建文件与修改文件/目录的时间</a></h3><ul>
<li>文件/目录时间属性<ul>
<li>mtime: modiricaiton time,表示文件内容更改的时间</li>
<li>ctime: status time,表示文件状态更改的时间(比如属性与权限)</li>
<li>atime: access time,表示文件内容被取用的时间</li>
</ul>
</li>
<li><code>touch</code>:常用与创建一个空文件,修改某个文件/目录时间(只能修改mtime,atime)<ul>
<li>格式: `touch [-acdmt] 文件``</li>
<li>常用参数:<ul>
<li><code>-a</code>:  仅修改atime</li>
<li><code>-m</code>: 仅修改mtime</li>
<li><code>-t</code>: 修改atime和mtime 格式为[YYMMDDhhmm]</li>
</ul>
</li>
<li>例子: 创建一个时间为07-11-22 06:44的文件temp1  命令<code>$ touch -t 0711220644 temp1</code></li>
</ul>
</li>
</ul>
<h3 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="  查看文件类型"></a><a name="ch2.9">  查看文件类型</a></h3><ul>
<li><code>file</code>:可以查看文件的基本类型以及数据描述,比如是属于ASCII或者data文件,二进制文件,有没使用动态函数库等信息<ul>
<li>格式 : <code>file 文件名</code></li>
</ul>
</li>
</ul>
<h2 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="  文件内容查阅"></a><a name="ch3">  文件内容查阅</a></h2><p>文件分为纯文本文件/二进制文件/数据格式文件,当我们查阅文件内容时,需要以合适的命令去查阅,以下分为纯文本与二进制文件查阅</p>
<ul>
<li>纯文本文件查阅 :<ul>
<li><code>cat</code>: concatenate,由第一行开始显示文件内容<ul>
<li>格式: <code>cat [-AbenTv] 文件名</code></li>
<li>常用参数:<ul>
<li><code>-n</code>:打印出行号,连同空白行</li>
</ul>
</li>
</ul>
</li>
<li><code>tac</code>: 从最后一行开始显示</li>
<li><code>nl</code>:  显示时候,顺便输出行号(默认不显示空白行的行号)<ul>
<li>格式: <code>nl [-bnw] 文件</code></li>
</ul>
</li>
<li><code>more</code>:一页一页地显示文件内容,不能向前翻页,上面的<code>cat</code>/<code>tac</code>/<code>nl</code>都是一次性将文件全部内容显示,文件内容多的时候会不便</li>
<li><code>less</code>: 与more类似,但比more好,它可以向前翻页和向前搜索</li>
<li><code>head</code>:只看头几行<ul>
<li>格式: <code>head [-n num] 文件</code><ul>
<li>num不带符号: 表示显示前num行</li>
<li>num带负号:表示文件后面num行的数据不显示</li>
</ul>
</li>
</ul>
</li>
<li><code>tail</code>:只看尾几行<ul>
<li>格式:与<code>head</code>类似<ul>
<li>num不带符号:表示显示后num行</li>
<li>num带正号:表示文件前面num行的数据不显示(不包括第num行)</li>
</ul>
</li>
<li>例子: 显示/etc/man.config的第11到第20行的数据  使用命令<code>head -n 20 /etc/man.config|tail -n 10</code>或者<code>tail -n +11 /etc/man.config|head -n 10</code></li>
</ul>
</li>
</ul>
</li>
<li>二进制文件查阅:<ul>
<li><code>od</code>:读取二进制文件内容</li>
<li>格式: <code>od [-t TYPE] 文件</code></li>
<li>TYPE类型:<ul>
<li><code>a</code>:利用默认的字符输出</li>
<li><code>c</code>:使用ASCII字符输出</li>
<li><code>d</code>:使用十进制来输出</li>
<li><code>f</code>:利用浮点数来输出</li>
<li><code>o</code>:利用八进制来输出</li>
<li><code>x</code>:利用十六进制来输出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件与目录的默认权限-隐藏属性-特殊权限"><a href="#文件与目录的默认权限-隐藏属性-特殊权限" class="headerlink" title="文件与目录的默认权限/隐藏属性/特殊权限"></a><a name="ch4">文件与目录的默认权限/隐藏属性/特殊权限</a></h2><h3 id="文件默认权限：umask"><a href="#文件默认权限：umask" class="headerlink" title="文件默认权限：umask"></a><a name="ch4.1">文件默认权限：umask</a></h3><p>当我们新建一个新的文件/目录时,其默认权限是怎么指定的,这与<code>umask</code>有关
<code>umask</code>:指定目前用户在新建文件/目录时的权限默认值(不同用户的权限默认值不同)</p>
<ul>
<li>用户创建文件/目录时的最大权限默认值<ul>
<li>用户创建文件最大权限默认值是666<ul>
<li>用户创建文件时系统默认不分配[x]权限,最大值是666,即<code>-rw-rw-rw-</code></li>
</ul>
</li>
<li>用户创建目录最大权限默认值是777<ul>
<li>默认开放全部权限</li>
</ul>
</li>
<li>注意,这里不同用户创建文件/目录最大权限默认值都是一样的,文件666,目录777
<br>
<br>
<br></li>
</ul>
</li>
<li><p>查看目前用户权限默认值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># umask</span></div><div class="line">0022</div><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># umask -S</span></div><div class="line">u=rwx,g=rx,o=rx</div></pre></td></tr></table></figure>
<ol>
<li>第一种方式:是分数查询,第1个数字表示特殊权限,第2-4个数字一般权限,这组分值表示最大权限默认值需要减掉的权限,比如root用户的umask是0022,那么root新建文件时的默认权限是666去掉022,即644(不要认为是单纯的相减)</li>
<li>第二种方式:是字符查询,这里的每组分值就是当前用户新建<b>目录</b>时的默认权限值</li>
</ol>
</li>
<li><p>设置目前用户的权限默认值
执行<code>umask 默认分值</code></p>
</li>
<li><p>例子
假设某用户的umask是003,请问该用户新建文件/目录的权限是什么?
1) 新建文件的权限是664
2) 新建目录的权限是774</p>
</li>
</ul>
<h3 id="文件隐藏属性-chattr-lsattr"><a href="#文件隐藏属性-chattr-lsattr" class="headerlink" title="文件隐藏属性 : chattr/lsattr"></a><a name="ch4.2">文件隐藏属性 : chattr/lsattr</a></h3><ul>
<li><p><code>chattr</code>:设置文件隐藏属性,<code>chattr</code>只能在Ext2/Ext3以上的文件系统生效</p>
<ul>
<li>格式: <code>chattr [+-=][ASacdistu] 文件/目录名</code></li>
<li>常用参数:<ul>
<li><code>+</code>   增加属性</li>
<li><code>-</code>   删除属性</li>
<li><code>=</code>  设置属性</li>
<li><code>A</code>  文件/目录的访问时间atime不会被修改</li>
<li><code>S</code>   对文件任何的修改,都会同步写入磁盘中(原本是异步写入磁盘的)</li>
<li><code>a</code>   只能添加数据,不能修改/删除数据,只有root才能设置此属性</li>
<li><code>i</code>    不能删除/改名/不能读写数据,只有root才能设置此属性(连root用户也无法对文件/目录进行操作)</li>
</ul>
</li>
</ul>
</li>
<li><p><code>lsattr</code> : 显示文件隐藏属性</p>
<ul>
<li>格式 : <code>lsattr [-adR] 文件/目录</code></li>
<li>常用参数: <ul>
<li><code>a</code>  将隐藏文件属性也显示出来</li>
<li><code>d</code>  如果是目录,仅列出目录本身属性</li>
<li><code>R</code> 连同子目录/文件也一并列出 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文件特殊权限：SUID-SGID-SBIT"><a href="#文件特殊权限：SUID-SGID-SBIT" class="headerlink" title="文件特殊权限：SUID/SGID/SBIT"></a><a name="ch4.3">文件特殊权限：SUID/SGID/SBIT</a></h3><p>请先观察下面3个文件属性
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-rwsr-xr-x 1 root root 45420  1月 27 08:51 /usr/bin/passwd</div><div class="line">-rwxr-sr-x 1 root mlocate 34452  6月 20  2013 /usr/bin/mlocate</div><div class="line">drwxrwxrwt 6 root root 20480  7月 19 16:31 /tmp</div></pre></td></tr></table></figure>
发现了吗?
<code>/usr/bin/passwd</code>的user权限是<code>rws</code>
<code>/usr/bin/mlocate</code>的group权限是<code>r-s</code>
<code>/tmp</code>的others权限是<code>rwt</code>
这里的<code>s</code>以及<code>t</code>就是特殊权限,每个身份对应的特殊权限是固定的,不可能出现<code>rwt</code>这情况.</p>
<ul>
<li>SUID :  setUID,<code>s</code>出现在user的<code>x</code>权限上,代表当用户执行此二进制程序时,在执行过程中用户会暂时具有程序所有者的权限.(只能是二进制程序)<ul>
<li>例子:        <ol>
<li>一般用户对于/usr/bin/passwd这个程序是具有<code>x</code>,表示一般用户可以执行passwd,passwd会去修改<code>/etc/shadow</code>这个文件对应的密码,但<code>/etc/shadow</code>这个文件的权限是<code>-rw-r----- 1 root shadow 1292  7月 18 22:03 /etc/shadow</code>,这代表一般用户无权修改密码,可实际上每个用户都可以修改自己的密码</li>
<li>passwd的所有者是root</li>
<li>由于这个程序具有SUID的特权权限,一般用户执行程序时暂时获得root的权限</li>
<li>所有<code>/etc/shadow</code>可以被一般用户所执行的passwd修改
<br>
<br>
<br></li>
</ol>
</li>
</ul>
</li>
<li>SGID: setGID,<code>s</code>出现在group的<code>x</code>权限上.<ul>
<li>含义:<ul>
<li>当SGID是文件时,代表当用户执行此二进制程序时,在执行过程中用户暂时获得用户组的权限</li>
<li>当SGID是目录时,代表用户在这个目录下新建的文件/目录,用户组都会与该目录的用户组相同
<br>
<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>SBIT: sticky Bit,SBIT只针对目录,<code>t</code>出现在others的<code>x</code>权限上<ul>
<li>含义: 一个目录具有SBIT的权限后,某用户在此目录上具有<code>wx</code>权限,此用户创建的文件/目录,只有此用户与root才能删除,目录所有者也不能删除
<br>
<br>
<br></li>
</ul>
</li>
<li>SUID/SGID/SBIT权限设置<br>只要在我们一般权限数值前加上一个代表特殊权限的数值(这是分值设置法,符号设置法跟一般权限类似,在之前加上<code>s</code>/<code>t</code>)<br>其中 SUID:4 SGID:2 SBIT:1<ul>
<li>例子 : 将某文件权限改为<code>-rwsr-xr-x</code>,设置命令是<code>chmod 4755 filename</code></li>
<li>问题: 如果文件或目录没有<code>x</code>权限,相应的特殊权限即使设置了,也无效,而且会有大写<code>S</code>或<code>T</code>标明为<code>x</code>为空</li>
</ul>
</li>
</ul>
<h2 id="命令与文件查找"><a href="#命令与文件查找" class="headerlink" title="命令与文件查找"></a><a name="ch5">命令与文件查找</a></h2><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a><a name="ch5.1">查找命令</a></h3><p>查找命令完整的文件名可用which或type,这两个命令都是通过PATH变量来查找文件名.(正是通过PATH,不同的用户可能找到的结果不一样)</p>
<h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a><a name="ch5.2">查找文件</a></h3><p>查找文件的完整文件名可以使用whereis/locate/find,其中whereis/locate会到数据库文件去查找(所有查找文件前,最好更新下数据库<code>updatedb</code>),find会直接查找文件系统(在硬盘中查找,较慢)</p>
<ul>
<li>whereis/locate的区别<ul>
<li>whereis会根据文件/目录名去查找,并不是关键字查找,需要输入完整的名称</li>
<li>locate是关键字查找,只要查找的完整文件名上有这个关键字就会被列出</li>
</ul>
</li>
</ul>
<h3 id="find的使用"><a href="#find的使用" class="headerlink" title="find的使用"></a><a name="ch5.3">find的使用</a></h3><ul>
<li>基本格式:<code>find [path] [opt] [action]</code> 其中每组[opt]和[action]可以用[-a][-o][-not]连接词来连接,组成复合选项</li>
<li>根据时间查找<ul>
<li>格式: <code>find [path] {-mtime,-ctime,-atime} [+,-]n</code> 其中n为数字,表示天数</li>
<li>find时间参数说明<br><img src="https://github.com/HiKumho/blog/blob/master/img/blog_16_1.gif?raw=true" alt=""><br>  n:在n天之前的”24小时内”被改过的文件<br> +n:n天之前(不包含n天)被改动的文件<br>  -n:n天之内(含n天)被改动的文件     <ul>
<li>例子:列出过去系统上面24小时内改动过的文件:<code>find / -mtime 0</code>        </li>
</ul>
</li>
</ul>
</li>
<li>根据用户/用户组信息查找<ul>
<li>参数:<ul>
<li><code>-uid n</code> 根据用户ID,n代表用户ID</li>
<li><code>-gid n</code> 根据用户组ID,n代表用户组ID</li>
<li><code>-user name</code>  指定用户名</li>
<li><code>-group name</code> 指定用户组名</li>
<li><code>-nouser</code> 无用户文件</li>
</ul>
</li>
</ul>
</li>
<li>根据文件属性查找<ul>
<li><code>-name filename</code> 指定文件名 可以使用通配符<code>*</code>表示任意 如<code>*httpd*</code>指文件名包含httpd</li>
<li><code>-size [+-]SIZE</code> 指定文件大小 比如小于50k大于10k的文件 <code>- size -50k+10k</code></li>
<li><code>-type TYPE</code> 指定文件类型 TYPE:一般文件(f),设备文件(b,c)等文件类型</li>
<li><code>-perm mode</code> 指定文件权限是mode的文件 比如<code>-perm 777</code>指定查找文件权限为777的文件</li>
<li><code>-perm -mode</code> 指定文件权限包含mode全部属性的文件</li>
<li><code>-perm +mode</code> 指定文件权限包含mode任一属性的文件 <ul>
<li>并行命令:在查找结果后并接上其他命令,执行</li>
<li>格式 :<code>-exec command \;</code></li>
<li>例子: 查找文件当中包含SGID或SUID或SBIT的文件,并以列表输出<br>命令<code>find / -perm +7000 -exec ls -l {} \;</code>   其中<code>{}</code>表示查找的结果集</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="权限与命令间关系"><a href="#权限与命令间关系" class="headerlink" title="权限与命令间关系"></a><a name="ch6">权限与命令间关系</a></h2><ul>
<li>让用户能进入某目录成为”可工作目录”的基本权限<ul>
<li>可使用命令:<code>cd</code>切换目录</li>
<li>目录所需权限:用户对这目录至少需要<code>x</code>权限</li>
<li>额外需求:如果用户想要在这目录利用<code>ls</code>查阅文件名,这目录还需要<code>r</code>权限</li>
</ul>
</li>
<li>用户在某个目录内读取一个文件的基本权限是什么<ul>
<li>可使用命令:<code>cat</code>/<code>more</code>/<code>less</code>等</li>
<li>目录所需权限: 用户对这个目录至少需要<code>x</code>权限</li>
<li>文件所需权限: 用户对文件至少需要有<code>r</code>权限</li>
</ul>
</li>
<li>让用户可以修改一个文件的基本权限<ul>
<li>可使用命令:nano编辑器/vi编辑其</li>
<li>目录所需权限:用户对该文件所在目录至少需要<code>x</code>权限</li>
<li>文件所需权限:用户对该文件至少需要<code>rw</code>权限</li>
</ul>
</li>
<li>让一个用户可以创建一个文件的基本权限<ul>
<li>目录所需权限:用户在该目录要具有<code>wx</code>权限</li>
</ul>
</li>
<li>让用户进入某目录并执行该目录下的某个命令的基本权限<ul>
<li>目录所需权限:用户在该目录至少需要有<code>x</code>权限</li>
<li>文件所需权限:用户对该文件至少需要<code>x</code>权限</li>
</ul>
</li>
<li>例子:让一个一般用户能够进行<code>cp dir1/file1 dir2</code>的命令是,请说明dir1,file1,dir2的最小所需权限<ul>
<li>dir1 : 至少需要<code>x</code>权限</li>
<li>dir2 : 至少需要<code>wx</code>权限</li>
<li>file1: 至少需要<code>r</code>权限 </li>
</ul>
</li>
</ul>
<h2 id="情景模拟"><a href="#情景模拟" class="headerlink" title="情景模拟"></a><a name="ch7">情景模拟</a></h2><p>假设系统有两个账号,分别是kumho与jinhu,这两个人除了自己用户组之外还共同支持一个名为project的用户组.假设这两个用户共同拥有/home/project目录的开发权,而且该目录不许其他人进入查阅.请问该目录权限应设置为什么?</p>
<p>1. 新建用户及用户组
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># groupadd project</span></div><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># useradd -G project jinhu</span></div><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># id jinhu</span></div><div class="line">uid=1001(jinhu) gid=1002(jinhu) 组=1002(jinhu),1001(project)</div><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># id kumho</span></div><div class="line">uid=1000(kumho) gid=1000(kumho) 组=1000(kumho),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare)</div><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># user</span></div><div class="line">useradd  userdel  usermod  users    </div><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># man usermod</span></div><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># usermod -aG project kumho</span></div><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># id kumho</span></div><div class="line">uid=1000(kumho) gid=1000(kumho) 组=1000(kumho),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare),1001(project)</div></pre></td></tr></table></figure></p>
<p>2. 创建目录及修改权限
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># mkdir /home/project</span></div><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># ls -dl /home/project/</span></div><div class="line">drwxr-xr-x 2 root root 4096  7月 18 21:53 /home/project/</div><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># chgrp project /home/project</span></div><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># ls -dl /home/project/</span></div><div class="line">drwxr-xr-x 2 root project 4096  7月 18 21:53 /home/project/</div><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># chmod 2770 /home/project</span></div><div class="line">root@kumho-Inspiron-3421:~<span class="comment"># ls -dl /home/project</span></div><div class="line">drwxrws--- 2 root project 4096  7月 18 21:53 /home/project</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android AdapterView与Adapter]]></title>
      <url>http://yoursite.com/2016/09/05/Android-AdapterView%E4%B8%8EAdapter/</url>
      <content type="html"><![CDATA[<h2 id="MVC"><a href="#MVC" class="headerlink" title="  MVC"></a><a name="ch1">  MVC</a></h2><p> MVC(Model–view–controller)是一种软件工程中常用的设计模式,在J2EE中也提供了MVC框架,其实现原理是:数据模型M(Model)存放数据,利用控制器C(Controller)将数据显示在视图V(View)上.Android上也存在着这样的组件,它们就是AdapterView(V)与Adapter(C)</p>
<h2 id="AdapterView及子类"><a href="#AdapterView及子类" class="headerlink" title="  AdapterView及子类"></a><a name="ch2">  AdapterView及子类</a></h2><p>AdapterView具有以下特征:</p>
<ul>
<li>AdapterView继承了ViewGroup,它的本质是容器</li>
<li>AdapterView可以包括多个”列表项”,并将多个”列表项”以合适的形式显示</li>
<li>AdapterView显示的多个”列表项”由Adapter提供,调用AdapterView的setAdapter(Adapter)</li>
</ul>
<p>AdapterView及其子类继承关系图如下
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_15_1.jpg?raw=true" alt=""></p>
<p>AdapterView派生出三个子类:AbsListView/AbsSpinner/AdapterViewAnimator,实际往往使用它们的子类</p>
<h2 id="Adapter接口及实现类"><a href="#Adapter接口及实现类" class="headerlink" title="  Adapter接口及实现类"></a><a name="ch3">  Adapter接口及实现类</a></h2><p>Adapter接口及其实现类的继承关系图如下:
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_15_2.png?raw=true" alt=""></p>
<p>实际使用Adapter时,采用以下两种方法:</p>
<ul>
<li>使用高层次封装好的实现类,如ArrayAdapter/SimpleAdapter/SimpleCursorAdapter等</li>
<li><p>扩展BaseAdapter等类,这样可以对子视图进行最大限度的定制</p>
<ul>
<li>需要重写getCount()/getItem(int)/getItemId(int)/getView(int,View,ViewGroup)方法</li>
</ul>
<h2 id="AdapterView与Adapter具体使用"><a href="#AdapterView与Adapter具体使用" class="headerlink" title="  AdapterView与Adapter具体使用"></a><a name="ch4">  AdapterView与Adapter具体使用</a></h2></li>
</ul>
<p>具体使用流程:</p>
<ol>
<li>编写包含ApdaterView组件的layout.xml以及AdapterView的子项.xml</li>
<li>定义数据/获取数据,然后根据想使用的Adapter的结构组织好数据</li>
<li>声明Adapter对象,创建Adapter对象可以使用库封装好的实现类或扩展BaseAdapter</li>
<li>数据与Adapter对象的映射</li>
<li>AdapterView设置Adapter</li>
<li>AdapterView监听子项状态,使用setOnItemClickListener/setOnItemSelectedListener</li>
</ol>
<p>以下是使用ListView与Apdater的一个例子:</p>
<ol>
<li>首先编写本例子的布局文件activity_2_5_2.xml</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">  <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">  <span class="attr">android:padding</span>=<span class="string">"5dp"</span></div><div class="line">  <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">ListView</span> <span class="attr">android:id</span>=<span class="string">"@id/listView_1"</span></span></div><div class="line">      <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">      <span class="attr">android:scrollbars</span>=<span class="string">"none"</span></div><div class="line">      <span class="attr">android:layout_height</span>=<span class="string">"300dp"</span></div><div class="line">      <span class="attr">android:background</span>=<span class="string">"@drawable/backgroup_border_2_5_2_1"</span>/&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">ListView</span> <span class="attr">android:id</span>=<span class="string">"@id/listView_2"</span></span></div><div class="line">      <span class="attr">android:layout_below</span>=<span class="string">"@id/listView_1"</span></div><div class="line">      <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">      <span class="attr">android:layout_height</span>=<span class="string">"300dp"</span></div><div class="line">      <span class="attr">android:layout_marginTop</span>=<span class="string">"2dp"</span></div><div class="line">      <span class="attr">android:scrollbars</span>=<span class="string">"none"</span></div><div class="line">      <span class="attr">android:background</span>=<span class="string">"@drawable/backgroup_border_2_5_2_2"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>backgroup_border_2_5_2_1</code>与<code>backgroup_border_2_5_2_2</code>是一个边框UI         </p>
<ol>
<li>然后编写ListView的子项文件item_listview_2_5_2.xml<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">  android:layout_width="match_parent"</div><div class="line">  android:layout_height="match_parent"</div><div class="line">  android:gravity="center_vertical"</div><div class="line">  android:orientation="horizontal"</div><div class="line">  android:padding="5dp"&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">ImageView</span></span></div><div class="line">      <span class="attr">android:id</span>=<span class="string">"@id/imgView_1"</span></div><div class="line">      <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">      <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">      <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_main_bus"</span> /&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">      <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">      <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">      <span class="attr">android:gravity</span>=<span class="string">"center_vertical|left"</span></div><div class="line">      <span class="attr">android:padding</span>=<span class="string">"5dp"</span></div><div class="line">      <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</div><div class="line"></div><div class="line">      <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">          <span class="attr">android:id</span>=<span class="string">"@id/textView_1"</span></div><div class="line">          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">          <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">          <span class="attr">android:textSize</span>=<span class="string">"20sp"</span></div><div class="line">          <span class="attr">android:text</span>=<span class="string">"巴士站"</span>/&gt;</div><div class="line"></div><div class="line">      <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">          <span class="attr">android:id</span>=<span class="string">"@id/textView_2"</span></div><div class="line">          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">          <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">          <span class="attr">android:textSize</span>=<span class="string">"15sp"</span></div><div class="line">          <span class="attr">android:text</span>=<span class="string">"交通"</span>/&gt;</div><div class="line">  <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>子项布局文件很简单,就是左边一张图片,右边两行文字     </p>
<ol>
<li>最后编写Acitivity</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line"> * 使用simpleAdapter和扩展BaseAdapter实现ListView</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Kumho</div><div class="line"> * <span class="doctag">@date</span> 16-7-15</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity_2_5_2</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/* 数据存取的键值 .*/</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String KEY_LABEL_IMG = <span class="string">"LImg"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String KEY_LABEL_NAME = <span class="string">"LName"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String KEY_LABEL_TYPE = <span class="string">"LType"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 标签图片 .*/</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] labelImgs = &#123;</div><div class="line">            R.mipmap.ic_main_bus, <span class="comment">//</span></div><div class="line">            R.mipmap.ic_main_hotel,<span class="comment">//</span></div><div class="line">            R.mipmap.ic_main_ktv,<span class="comment">//</span></div><div class="line">            R.mipmap.ic_main_market</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">/* 标签名 .*/</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] labelNames = &#123;<span class="string">"巴士站"</span>, <span class="string">"酒店"</span>, <span class="string">"KTV"</span>, <span class="string">"超市"</span>&#125;;</div><div class="line">    <span class="comment">/* 标签分类 .*/</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] labelTypes = &#123;<span class="string">"交通"</span>, <span class="string">"住宿"</span>, <span class="string">"娱乐"</span>, <span class="string">"购物"</span>&#125;;</div><div class="line"></div><div class="line">    <span class="comment">/* 标签数组 .*/</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Map&lt;String, Object&gt;&gt; labelList = <span class="keyword">new</span> ArrayList&lt;Map&lt;String, Object&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/* 列表组件 .*/</span></div><div class="line">    <span class="keyword">private</span> ListView mListView1;</div><div class="line">    <span class="keyword">private</span> ListView mListView2;</div><div class="line"></div><div class="line">    <span class="comment">/* Simple适配器 .*/</span></div><div class="line">    <span class="keyword">private</span> SimpleAdapter mSimpleAdapter;</div><div class="line">    <span class="comment">/* 自定义适配器 .*/</span></div><div class="line">    <span class="keyword">private</span> MyListAdpater mMListAdapter;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_test_2_5_2);</div><div class="line"></div><div class="line">        initData();</div><div class="line"></div><div class="line">        mListView1 = (ListView) findViewById(R.id.listView_1);</div><div class="line">        mListView2 = (ListView) findViewById(R.id.listView_2);</div><div class="line"></div><div class="line">        mSimpleAdapter = <span class="keyword">new</span> SimpleAdapter(<span class="keyword">this</span>, labelList, R.layout.item_listview_2_5_2,</div><div class="line">                <span class="keyword">new</span> String[]&#123;KEY_LABEL_IMG, KEY_LABEL_NAME, KEY_LABEL_TYPE&#125;,</div><div class="line">                <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;R.id.imgView_1, R.id.textView_1, R.id.textView_2&#125;);</div><div class="line">        mListView1.setAdapter(mSimpleAdapter);</div><div class="line"></div><div class="line">        mMListAdapter = <span class="keyword">new</span> MyListAdpater();</div><div class="line">        mListView2.setAdapter(mMListAdapter);</div><div class="line"></div><div class="line">        registerListener();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onBackPressed();</div><div class="line">        <span class="keyword">this</span>.finish();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 组织数据</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; labelNames.length; i++) &#123;</div><div class="line">            Map&lt;String, Object&gt; dataMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line">            dataMap.put(KEY_LABEL_IMG, labelImgs[i]);</div><div class="line">            dataMap.put(KEY_LABEL_NAME, labelNames[i]);</div><div class="line">            dataMap.put(KEY_LABEL_TYPE, labelTypes[i]);</div><div class="line">            labelList.add(dataMap);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注册监听器</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerListener</span><span class="params">()</span> </span>&#123;</div><div class="line">        mListView1.setOnItemClickListener(<span class="keyword">new</span> AdapterView.OnItemClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View view, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">                TextView labelName = (TextView) view.findViewById(R.id.textView_1);</div><div class="line">                Toast.makeText(TestActivity_2_5_2.<span class="keyword">this</span>, <span class="string">"你选择了"</span> + labelName.getText(), Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        mListView2.setOnItemClickListener(<span class="keyword">new</span> AdapterView.OnItemClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View view, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">                TextView labelName = (TextView) view.findViewById(R.id.textView_1);</div><div class="line">                Toast.makeText(TestActivity_2_5_2.<span class="keyword">this</span>, <span class="string">"你选择了"</span> + labelName.getText(), Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自定义适配器的实现,想了解列表项中子组件事件监听的方法</div><div class="line">     * <span class="doctag">@author</span> Kumho</div><div class="line">     * <span class="doctag">@date</span> 16-7-15</div><div class="line">     */</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyListAdpater</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> labelList.size();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> labelList.get(position);</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> position;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</div><div class="line">            ViewGroup mVGroup = (ViewGroup) LayoutInflater.from(TestActivity_2_5_2.<span class="keyword">this</span>).<span class="comment">//</span></div><div class="line">                    inflate(R.layout.item_listview_2_5_2, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">            ImageView mLabelImg = (ImageView) mVGroup.findViewById(R.id.imgView_1);</div><div class="line">            <span class="keyword">final</span> TextView mLabelName = (TextView) mVGroup.findViewById(R.id.textView_1);</div><div class="line">            TextView mLabelType = (TextView) mVGroup.findViewById(R.id.textView_2);</div><div class="line"></div><div class="line">            mLabelImg.setImageResource((Integer) labelList.get(position).get(KEY_LABEL_IMG));</div><div class="line">            mLabelName.setText(labelList.get(position).get(KEY_LABEL_NAME) + <span class="string">""</span>);</div><div class="line">            mLabelType.setText(labelList.get(position).get(KEY_LABEL_TYPE) + <span class="string">""</span>);</div><div class="line"></div><div class="line"></div><div class="line">            <span class="comment">// mLabelImg设置监听</span></div><div class="line">            mLabelImg.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                    Toast.makeText(TestActivity_2_5_2.<span class="keyword">this</span>, <span class="string">"你点击了"</span> + mLabelName.getText() + <span class="string">"的图片"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> mVGroup;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>注意:<code>listView1</code>与<code>listView2</code>分开来看,更清晰,<code>listView1</code>直接使用simpleAdapter作适配器,而<code>listView2</code>自定义了一个扩展至BaseAdapter的适配器,这里我们可以在BaseAdapter的getView方法中,为其子组件设置监听事件,比较灵活            </p>
<ol>
<li>程序运行
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_15_3.jpg?raw=true" width="50%"></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 文件权限与目录配置]]></title>
      <url>http://yoursite.com/2016/09/05/Linux-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="Linux中的文件"><a href="#Linux中的文件" class="headerlink" title=" Linux中的文件 "></a><a name="ch1"> Linux中的文件 </a></h2><p> Linux中，文件有特别重要的意义，他们为操作系统和设备提供了一个简单而统一的接口。在Linux中,一切都可以看做是文件 。</p>
<h3 id="Linux文件属性"><a href="#Linux文件属性" class="headerlink" title=" Linux文件属性"></a><a name="ch1.1"> Linux文件属性</a></h3><p>我们执行<code>ls -al</code>查看当前目录下的文件信息.输出的信息部分如下.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">总用量 132</div><div class="line">-rw-r--r--  1 root root  3106  2月 20  2014 .bashrc</div><div class="line">drwx------  6 root root  4096  7月 13 22:35 .cache</div><div class="line">drwx------ 11 root root  4096  7月 12 21:59 .config</div><div class="line">drwx------  3 root root  4096  6月 28 20:43 .dbus</div><div class="line">drwxr-xr-x  2 root root  4096  6月 30 09:45 Desktop</div><div class="line">drwx------  2 root root  4096  7月 12 21:57 .gconf</div><div class="line">-rw-r--r--  1 root root    57  6月 30 09:50 .gitconfig</div><div class="line">drwxrwxrwx  6 root root  4096  7月 10 23:39 .gradle</div><div class="line">drwx------  2 root root  4096  6月 30 09:46 .gvfs</div><div class="line">drwxr-xr-x  4 root root  4096  7月 10 22:19 .java</div></pre></td></tr></table></figure>
我们观察以下一行
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">drwxr-xr-x    2    root   root    4096 6月 30 09:45  Desktop</div><div class="line">[类型与权限][连接数][所有者][用户组][文件容量][修改日期][文件名]</div></pre></td></tr></table></figure>
其每一列描述如下:</p>
<ul>
<li>第一列:代表文件类型与权限(共有10个字符)<ul>
<li>第1个字符:代表文件类型,[d]是目录,[-]是文件,更多请看<a href="#ch1.4">Linux文件类型</a></li>
<li>第2-4个字符:代表文件所有者的权限,权限分为[r]可读,[w]可编辑,[x]可执行,三者顺序固定,无某项权限用”-“表示.关于”rwx”的具体意义请看<a href="#ch1.3">目录与文件权限的意义</a></li>
<li>第5-7个字符:代表文件所属用户组的权限</li>
<li>第8-10个字符:代表其他人对文件的权限</li>
</ul>
</li>
<li>第二列:代表文件连接数<ul>
<li>含义:就是指在目录树中,当前文件节点所直接连接的其他节点数+自身节点(1)就是连接数,若文件不是目录,则连接数是1</li>
<li>例子:上面的”Desktop”目录连接是2,在ls后刚好输出两个文件信息<code>drwxr-xr-x  2 root root 4096  6月 30 09:45 .
drwx------ 24 root root 4096  7月 14 10:02 ..</code>,这两个文件分别表示当前目录与其父级目录.</li>
</ul>
</li>
<li>第三列:代表文件所有者</li>
<li>第四列:代表文件所属用户组</li>
<li>第五列:代表文件容量,默认单位是字节</li>
<li>第六列:代表文件修改时间</li>
<li>第七列:代表文件名,以’.’开头的文件名代表隐藏文件(查看隐藏文件可以使用<code>ls -sl</code>)</li>
</ul>
<h3 id="改变文件权限与其所属"><a href="#改变文件权限与其所属" class="headerlink" title=" 改变文件权限与其所属"></a><a name="ch1.2"> 改变文件权限与其所属</a></h3><p>这里介绍几个常用于改变文件权限与其所属的命令:</p>
<ul>
<li>chmod:改变文件权限</li>
<li>chgrp:改变文件所属用户组</li>
<li>chown:改变文件所有者(也可以改变用户组)</li>
</ul>
<p>详细介绍</p>
<blockquote>
<p> chmod:改变文件权限</p>
<ul>
<li>方法1(数字类型): <ul>
<li>描述:用数字来代表各项权限[r]:4,[w]:2,[x]:1,[-]:0每种身份(owner/group/others)都有各自的权限值要累加.</li>
<li>例子:要改变为[-rwxr-xr–]这种权限,分数则是owner=rwx=7,group=r-x=5,others=r–=4,即权限数字是754</li>
<li>命令:这种方法改变权限使用<code>chmod [-R] 权限数字 文件或目录名</code>,其中[-R]表示修改连同子目录下的所有目录,文件</li>
</ul>
</li>
<li>方法2(符号类型): <ul>
<li>描述:用字符’r’,’w’,’x’代表相应的权限,用’u’,’g’,’o’代表3种身份以及用’a’代表所有身份,用符号’=’,’+’,’-‘分别代表”设置”,”添加”,”减去”权限操作<ul>
<li>例子:要改变[-rwxr-xr–]这种权限,权限字符可以是”u=rwx,g=rx,o=r”或”a+r,u+wx,g+x”等</li>
<li>命令:这种方法改变权限使用<code>chmod [-R] 权限字符 文件或目录名</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>.</p>
<blockquote>
<p>chgrp:改变文件所属用户组</p>
<ul>
<li>命令:<code>chgrp [-R] 修改的用户组名 文件/目录名</code>(注意修改的用户组名需在/etc/group文件内存在)</li>
</ul>
</blockquote>
<p>.</p>
<blockquote>
<p>chown:改变文件所有者</p>
<pre><code>- 命令:`chown [-R] 用户名[:用户组名] 文件/目录名`(注意修改的用户名需在/etc/passwd文件内存在)
- 例子:将install.log的所有者与用户组都改成root `chown root:root install.log`
</code></pre></blockquote>
<h3 id="目录与文件权限的意义"><a href="#目录与文件权限的意义" class="headerlink" title=" 目录与文件权限的意义"></a><a name="ch1.3"> 目录与文件权限的意义</a></h3><ul>
<li>权限对文件的意义<ul>
<li>r(Read):可读取此文件的实际内容<b>(文件读操作并不指执行操作,这里要分清)</b></li>
<li>w(Write):可编辑此文件的内容 <b>(但不含删除该文件)</b></li>
<li>x(eXecute):此文件具有可被系统执行的权限</li>
<li>x的一些说明:<br>文件能否可执行由[x]权限决定,能否成功执行取决与文件是否是执行类型的文件,这些都与文件”扩展名”无关,Liunx的”扩展名”只是给用户区别文件类型<ul>
<li>执行文件:<em>.sh(脚本/批处理文件),</em>Z/<em>.tar/</em>.tar.gz等经打包的压缩文件,<em>.html/</em>.php等网页相关文件</li>
</ul>
</li>
</ul>
</li>
<li>权限对目录的意义<ul>
<li>r(Read contents in directory):可读取目录的结构列表</li>
<li>w(modify contents of direcotry):可修改目录结构(对目录或文件的增加/删除/重命名/转移等),这些操作无视了子文件的权限</li>
<li>x(access directory):表示用户能否进入该目录,将其作为工作目录(比如<code>cd</code>不能作用)</li>
<li>关于可访问的目录:至少需指定目录[rx]权限,<b>只有[r]权限用户只能获取目录的文件名列表,其子文件/目录都变成二进制文件隐藏数据,只有再加上[x]权限才能正常访问</b></li>
</ul>
</li>
<li>其他:新建目录使用<code>mkdir</code>,新建文件使用<code>touch</code></li>
</ul>
<p><b>注意: root用户有无上的权利,无视文件权限</b></p>
<h3 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title=" Linux文件类型"></a><a name="ch1.4"> Linux文件类型</a></h3><p>Linux文件类型有以下:</p>
<ul>
<li>普通文件[-]:<ul>
<li>纯文本文件(ASCII)</li>
<li>二进制文件(binary): 可执行文件</li>
<li>数据格式文件(data):某些程序运行需要的特定格式文件,不能执行</li>
</ul>
</li>
<li>目录[d]</li>
<li>连接文件[l]:类似Windows下的快捷方式</li>
<li>设备文件<ul>
<li>块设备文件[b]:可存取的接口设备,如硬盘,U盘等</li>
<li>字符设备文件[c]:串行接口设备,如键盘,鼠标等(为什么是串行?一次性读取,不能截断输出)</li>
</ul>
</li>
<li>套接字[s]:数据接口文件,网络数据连接</li>
<li>管道[p]:解决进程同步通信</li>
</ul>
<h2 id="Linux目录配置"><a href="#Linux目录配置" class="headerlink" title=" Linux目录配置"></a><a name="ch2"> Linux目录配置</a></h2><h3 id="Linux目录配置标准-FHS"><a href="#Linux目录配置标准-FHS" class="headerlink" title=" Linux目录配置标准:FHS"></a><a name="ch2.1"> Linux目录配置标准:FHS</a></h3><p>文件系统层次结构标准(Filesytem Hierachy Standard,FHS)重点在于规范每个特定目录下应该放置什么样的数据</p>
<p><b>FHS制定出4种目录特征:可分享的(shareable),不可分享的(unshareble),不变的(static),可变动的(variable)</b>.</p>
<ul>
<li>可分享:   可以分享给其他系统挂载使用的目录,比如分享给网络上其他主机使用的.</li>
<li>不可分享的:    与自身机器有关,比如设备文件/程序有关的socket文件等,不适合分享给其他主机.</li>
<li>不变的:    有些数据不会经常变动,比如函数库,文件说明,主机服务配置文件等</li>
<li>可变动的:   经常变动的数据,比如登录文件等</li>
</ul>
<p>举例说明如下表</p>
<table>
    <th></th><th>可分享</th><th>不可分享</th>
    <tr>
       <td rowspan="2"><b>不变的</b></td>
       <td>/usr(软件放置处)</td>
       <td>/etc(配置文件)</td>
    </tr>
    <tr>
       <td>/opt(第三方软件)</td>
       <td>/boot(开机与内核文件)</td>
    </tr>
    <tr>
       <td rowspan="2"><b>可变动的</b></td>
       <td>/var/mail(用户邮件信箱)</td>
       <td>/var/run(程序相关)</td>
    </tr>
    <tr>
       <td>/var/spool/news(新闻组)</td>
       <td>/var/lock(程序相关)</td>
    </tr>
</table>

<h3 id="FHS三层主目录"><a href="#FHS三层主目录" class="headerlink" title=" FHS三层主目录"></a><a name="ch2.2"> FHS三层主目录</a></h3><p>事实上,FHS对目录树架构仅定义初三层目录下面应该放置什么数据,分别是下面三个目录的定义:</p>
<ul>
<li>/ : 根目录,与开机系统有关</li>
<li>/usr:Unix software resouce,与软件安装/执行有关</li>
<li>/var:variable,与系统运作过程有关</li>
</ul>
<h4 id="根目录的意义"><a href="#根目录的意义" class="headerlink" title="  根目录的意义"></a><a name="ch2.2.1">  根目录的意义</a></h4><ul>
<li>根目录是整个系统最重要的一个目录,不仅目录树上的文件节点由根目录衍生出来,同时根目录也与开机/还原/系统修复等操作有关.</li>
<li>FHS标准建议:根目录所在分区应越小越好,且软件最好不要与根目录放在同一个分区内.这样根目录性能较好,文件系统也不容易发生问题(分区越大,软件越多,根目录所在分区出错机率也越大)</li>
<li>根目录与开机有关,开机过程中仅有根目录会被挂载,其他分区是在完成开机后才持续进行挂载.因此有些与开机有关的目录须与根目录同分区,有以下这些:<ul>
<li>/etc:系统配置文件,如人员账号密码,各种服务起始文件等</li>
<li>/bin:重要执行文件(可以被root与一般用户使用)</li>
<li>/dev:任何设备文件都存放在此</li>
<li>/lib:在开机时会用到的函数库,/bin或/sbin下面命令调用的函数库以及内核所需的模块(/lib/modules)</li>
<li>/sbin:开机过程所需要的,包括开机/修复/还原系统所需的执行文件</li>
</ul>
</li>
<li>其他一些子目录:<ul>
<li>/boot:开机引导程序/内核文件所需的配置文件/开机配置文件</li>
<li>/home:用户主文件夹,每个一般用户都会在此目录下有一个对应的目录</li>
<li>/root:root的主目录,最好与根目录同分区(单用户维护模式下可使用root文件夹)</li>
<li>/mnt:暂时挂载额外设备用</li>
</ul>
</li>
</ul>
<h4 id="usr的意义"><a href="#usr的意义" class="headerlink" title="  /usr的意义"></a><a name="ch2.2.2">  /usr的意义</a></h4><ul>
<li>管理员存放安装程序相关目录</li>
<li>/usr会占用较大的硬盘容量</li>
<li>/usr的子目录<ul>
<li>/usr/X11R6:存放X Window的数据目录(X Window最后版本是11,第6次释出)</li>
<li>/usr/bin:平时用户可使用命令(与/bin区别是:/bin与开机有关)</li>
<li>/usr/include:C/C++程序语言的头文件(header)与包含文件(include)</li>
<li>/usr/local:系统管理员安装的软件</li>
<li>/usr/sbin:非系统正常运行所需的命令,比如网络服务器的命令等</li>
<li>/usr/share:放置共享文件的地方</li>
<li>/usr/src:源码放置,<b>内核源码在/usr/src/linux下</b></li>
</ul>
</li>
</ul>
<h4 id="var的意义"><a href="#var的意义" class="headerlink" title="  /var的意义"></a><a name="ch2.2.3">  /var的意义</a></h4><ul>
<li>/var针对常态性变动文件,如缓存,登录文件以及某些软件运行产生的文件</li>
<li>/var随系统运行bianda后逐渐变大</li>
<li>/var的子目录<ul>
<li>/var/cache:程序运行时暂存文件</li>
<li>/var/lib:程序运行时使用的数据文件</li>
<li>/var/lock:设备/文件资源锁</li>
<li>/var/log:登录文件,比如/var/log/messages,/var/log/wtmp(记录登录者信息)</li>
<li>/var/mail:个人email目录</li>
<li>/var/run:某些程序或服务启动后,会将其PID放置在此目录</li>
<li>/var/spool:放置队列数据</li>
</ul>
</li>
</ul>
<h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a><a name="ch3">目录树</a></h2><p>所有文件/目录由根目录开启,再往下分支扩展,呈树状,故称”目录树”</p>
<p>目录树特性:</p>
<ul>
<li>目录树起始点是根目录(/)</li>
<li>每个目录不只能使用本地的文件系统,也可以是网络的文件系统</li>
<li>目录树文件节点名称唯一</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 像素单位说明(dp/px/sp)]]></title>
      <url>http://yoursite.com/2016/09/05/Android-%E5%83%8F%E7%B4%A0%E5%8D%95%E4%BD%8D%E8%AF%B4%E6%98%8E-dp-px-sp/</url>
      <content type="html"><![CDATA[<h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p>px,pixels（像素）  屏幕上的点，不同设备不同的显示屏显示效果相同，这是绝对像素，是多少就永远是多少不会改变。一般我们HVGA代表320×480像素</p>
<h2 id="sp"><a href="#sp" class="headerlink" title="sp"></a>sp</h2><p>sp,scaled pixels — best for text size (放大像素)（与刻度无关的像素）：主要处理字体的大小。可以根据用户的字体大小进行缩放。主要用于字体显示best for textsize。</p>
<h2 id="dp-dip"><a href="#dp-dip" class="headerlink" title="dp(dip)"></a>dp(dip)</h2><p>1.  什么是屏幕点密度(每英寸像素值)及计算公式?
概念:ppi是 Pixel per inch，每英寸像素数,用来表示显示设备的点密度.除此之外还有用来表示印刷品点密度(dpi,每英寸多少点)
计算公式:要计算屏幕点密度首先要确定屏幕的尺寸和分辨率
<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d30ee099bd8351610c8746eeb1128aba5e786b86" alt="">
其中</p>
<ul>
<li><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/58a3efb685b5e6d0fa5be00ba01cf4e30a5641ce" alt="">为屏幕对角线的分辨率</li>
<li><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/084eacf2cbc45853ac169255e6233f7988ae9160" alt="">为屏幕横向分辨率</li>
<li><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0bfca0659973ce00bd30199829099f3332e580d6" alt="">为屏幕纵向分辨率</li>
<li><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/abe3154db7d4f92fb42dd1f80f52f528c6312e4a" alt="">为屏幕对角线的长度(单位为英寸)</li>
</ul>
<p>以屏幕尺寸为4寸的iPhone 5为例，分辨率为1136x640，像素密度为326PPI。而分辨率为1920x1080的家用21.5寸显示器，像素密度为103PP</p>
<p>2. 什么是dp及计算公式?
概念:dp一种基于屏幕密度的抽象单位。在每英寸160点(即屏幕点密度为160ppi)的显示器上，1dp = 1px。 是安卓为了方便适配不同屏幕而设置的单位.
计算公式:要计算某设备1dp等于多少px,需要知道设备的ppi
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">px=1dp*(ppi/160)</div></pre></td></tr></table></figure></p>
<p>以一4.3寸屏幕手机为例,其分辨率480x800,那么其ppi=217,1dp=217/160=1.4px
以一4.3寸屏幕手机为例,其分辨率720x1280,那么其ppi=342,1dp=2.1px
以一5.5寸屏幕手机为例,其分辨率720x1280,那么其ppi=267,1dp=1.7px</p>
<p>如果同一张的图片,在上面3部手机上显示,其效果是这样的.</p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/blog_13_1.jpg?raw=true" alt="">
可以想象一下我们不同的手机打开同一个应用，按钮的尺寸相差很大。
图片显示大小是由什么决定的呢，屏幕尺寸？上图第1和第2个屏都是4.3英寸。像素数？第2和第3个屏都是720x1280的像素。其实是由ppi决定的,对比上图可以知道，ppi越低图片显示的越大，ppi越高图片显示的越小。</p>
<p>要让不同屏幕显示图片的大小相同，就需要对图片进行缩放，给高ppi屏提供更大的图片。(<b>也就是说在低ppi屏我用10像素显示的线,在高ppi屏可能用20像素来显示这条线,才使这条线在两个屏幕看起来一样</b>)
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_13_2.jpg?raw=true" alt=""></p>
<p>高ppi屏幕需要更大的图片才能得到同样的显示效果，反之亦然。ppi和图片px的关系如下
px1/px2=ppi1/ppi2
选定一个ppi值作为基础绘制图片，用ppi的比值计算出图片缩放比例就可以适配各种屏幕,安卓选定的这个基础值就是160ppi
我们需要一个统一的单位来描述这个比值,这就是dp,高ppi下1dp表示的像素也越大</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.zhihu.com/question/21220154/answer/18584739" target="_blank" rel="external">DPI、PPI、DP、PX 的详细计算方法及算法来源是什么？</a></li>
<li><a href="http://www.imyukin.com/?p=277" target="_blank" rel="external">Android上dip、dp、px、sp等单位说明</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0" target="_blank" rel="external">每英寸像素</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 帮助手册(man/info/doc)]]></title>
      <url>http://yoursite.com/2016/09/05/Linux-%E5%B8%AE%E5%8A%A9%E6%89%8B%E5%86%8C-man-info-doc/</url>
      <content type="html"><![CDATA[<h2 id="Man-Page"><a href="#Man-Page" class="headerlink" title=" Man Page"></a><a name="ch1"> Man Page</a></h2><p>man手册页（manual pages，“手册”），是类UNIX系统最重要的手册工具。多数类UNIX都预装了它。使用man手册页的命令是：man。</p>
<p>所有Man Page的文件默认放在/usr/share/man目录下.</p>
<h3 id="使用Man手册"><a href="#使用Man手册" class="headerlink" title=" 使用Man手册"></a><a name="ch1.1"> 使用Man手册</a></h3><p>通过执行以下命令打开相应手册页
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ man 手册名(可以是命令名也可以是文件名)</div></pre></td></tr></table></figure>
man手册页通过<b>命令名和所属分类标识ID</b>来划分的,有些不同分类的man手册页名字可能相同，比如 man(1) 和 man(7)，这时需要额外指明分类以访问需要的手册。例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ man 5 passwd</div></pre></td></tr></table></figure>
会显示有关文件<code>/etc/passwd</code>，而非命令 <code>passwd</code>的内容。</p>
<p>man手册页分类标识及含义说明如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">分类标识ID</th>
<th style="text-align:center">含义说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">用户在shell环境中可以操作的命令或可执行文件</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">系统内核可调用的函数与工具等</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">一些常用的函数与函数库,大部分为C的函数库(libc)</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">设备文件的说明,通常在/dev下的文件</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">配置文件或者是某些文件的格式</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">游戏</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">惯例与协议等,例如Linux文件系统,网络协议,ASCII code等说明</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">系统管理员可用的管理命令(通常需要root权限)和守护进程</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">跟内核有关的文件</td>
</tr>
</tbody>
</table>
<h3 id="Man手册页格式"><a href="#Man手册页格式" class="headerlink" title=" Man手册页格式"></a><a name="ch1.2"> Man手册页格式</a></h3><p>所有man手册页都按照以下标准格式组织：</p>
<ul>
<li>NAME - 手册叙述对象名称，及简要描述。</li>
<li>SYNOPSIS - 命令参数格式，或者函数调用格式等。</li>
<li>DESCRIPTION - 对叙述对象更加详细的描述。</li>
<li>EXAMPLES - 由浅入深的使用示例。</li>
<li>OPTIONS - 命令行或者函数调用参数的意义。</li>
<li>EXIT STATUS - 不同返回（退出）代码的含义。</li>
<li>FILES - 与叙述对象相关的文件。</li>
<li>BUGS - 已知的bug。</li>
<li>SEE ALSO - 相关内容列表。</li>
<li>AUTHOR, HISTORY, COPYRIGHT, LICENSE, WARRANTY - 历史、版权、编者信息。</li>
</ul>
<h3 id="搜索手册页"><a href="#搜索手册页" class="headerlink" title=" 搜索手册页"></a><a name="ch1.3"> 搜索手册页</a></h3><p>如果用户压根儿不知道要查阅的手册的名称，该怎么办呢？没事，通过 <code>-k</code> 参数就可以按给定关键词搜索相关手册。
关键词搜索特性是从一个专用的缓存生成的。默认情况下你没有这个缓存，所以无论你搜什么，都会提示你nothing appropriate。你可以通过下面的命令来生成这个缓存：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># mandb</div></pre></td></tr></table></figure>
<i>每当你安装新的manpage之后都需要运行这个命令，缓存才会更新。</i>
现在你可以开始搜索了。 例如，要查阅手册说明有关”password”的手册页：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ man -k password(如果你想全文搜索的话，你可以用-K选项)</div></pre></td></tr></table></figure></p>
<p>通过<code>whatis</code>或<code>-f</code>命令，可以只显示需要的man手册页的简要信息。如果只是想获取对命令 ls 的简要说明，使用以下命令：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ whatis ls</div></pre></td></tr></table></figure>
或
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ man -f ls</div></pre></td></tr></table></figure>
然后会得到输出：“list directory contents.”（“列目录内容”）。</p>
<h2 id="Info-Page"><a href="#Info-Page" class="headerlink" title=" Info Page"></a><a name="ch2"> Info Page</a></h2><p>所有UNIX LIKE系统当中,都可以利用man来查询相关手册页,但Linux额外提供了一种帮助手册,这就是Info.
Info page其实就是命令行模式下的网页数据,其将文件数据拆成一个个段落,每个段落用自己页面撰写,页面与页面间用”超链接”跳转,故每个页面也称为节点.</p>
<p>所有Info Page的文件默认放在/usr/share/info目录下.</p>
<h3 id="使用Info手册"><a href="#使用Info手册" class="headerlink" title=" 使用Info手册"></a><a name="ch2.1"> 使用Info手册</a></h3><p>通过执行以下命令打开相应的手册
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ info 手册名</div></pre></td></tr></table></figure></p>
<h3 id="Info手册页格式"><a href="#Info手册页格式" class="headerlink" title=" Info手册页格式"></a><a name="ch2.2"> Info手册页格式</a></h3><p>Info手册页一般格式:</p>
<ul>
<li>File:当前页面由哪个文件提供</li>
<li>Node:当前页面所属节点</li>
<li>Next:当前页面的下一个节点</li>
<li>Up:回到上一层的节点总揽界面</li>
<li>Prev:前一个节点</li>
<li>Info:当前页面的详细描述</li>
<li>Menu:下级节点的菜单</li>
</ul>
<h2 id="Doc"><a href="#Doc" class="headerlink" title=" Doc"></a><a name="ch3"> Doc</a></h2><p>一般而言,命令或软件的说明都会制作成”帮助文件夹”.但是有一些情况需要额外的文件,这些文件可能要告诉你”如何做”,还有一些原理说明.
这些帮助文件会放在/usr/share/doc目录下,这目录下面有好多的说明文件文档.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux Android环境搭建]]></title>
      <url>http://yoursite.com/2016/09/05/Linux-Android%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title=" 前言 "></a><a name="ch0"> 前言 </a></h2><p> 想深入学习Android的底层知识,于是在Linux上搭建起Android开发环境,便于日后学习工作.我的搭建环境是Ubuntu14.04</p>
<h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title=" 安装JDK"></a><a name="ch1"> 安装JDK</a></h2><p>安装JDK的步骤请查看<a href="/2016/09/05/Linux-安装JDK/">Linux 学习之安装JDK</a>.安装好的朋友直接跳过:)</p>
<h2 id="安装Android-Stuido"><a href="#安装Android-Stuido" class="headerlink" title=" 安装Android Stuido"></a><a name="ch2"> 安装Android Stuido</a></h2><p>1. 下载Android Studio
 <a href="https://developer.android.com/studio/index.html" target="_blank" rel="external">点击进入下载页面</a></p>
<p>2. 解压安装包           </p>
<blockquote>
<pre><code>unzip <i><b> android-studio-ide-143.2915827-linux.zip</b></i></code></pre>

</blockquote>
<p>（注意斜体部分为你下载的Android Studio压缩包名）</p>
<p> 3. 进入android-studio/bin，执行Android Studio</p>
<blockquote>
<pre><code>./studio.sh</code></pre>

</blockquote>
<p>4. 安装Android SDK</p>
<ul>
<li>在线安装<br>启动Android Stuido，其第一次启动时会要求安装SDK。(如果没挂代理,可能会卡在下载gradle的步骤)</li>
<li>离线安装<br><a href="https://dl.google.com/android/android-sdk_r24.4.1-linux.tgz" target="_blank" rel="external">请点击进入下载页面</a></li>
</ul>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title=" 一些问题"></a><a name="ch3"> 一些问题</a></h2><h3 id="AS一直停在构建项目的状态"><a href="#AS一直停在构建项目的状态" class="headerlink" title=" AS一直停在构建项目的状态"></a><a name="ch3.1"> AS一直停在构建项目的状态</a></h3><p><strong>特征：</strong>
一直处于<strong>Grable Build Running</strong>的状态。(不是慢，我遇到的情况是卡死。你问我为什么知道，我让机器运行了一晚上TT，起来还是看到Grable Build Running) </p>
<hr>
<p><strong>解决：</strong>
1.  查看Grable Console是否出现异常<br>我碰到的是以下异常,这是我AS一直Build Running的原因
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;png-cruncher_17&quot; java.lang.RuntimeException: Timed out while waiting for slave aapt process, make sure the aapt execute at /usr/local/share/android-sdk-linux/build-tools/24.0.1/aapt can run successfully (some anti-virus may block it) or try setting environment variable SLAVE_AAPT_TIMEOUT to a value bigger than 5 seconds</div><div class="line">    at com.android.builder.png.AaptProcess.waitForReady(AaptProcess.java:108)</div><div class="line">    at com.android.builder.png.QueuedCruncher$1.creation(QueuedCruncher.java:110)</div><div class="line">    at com.android.builder.tasks.WorkQueue.run(WorkQueue.java:203)</div><div class="line">    at java.lang.Thread.run(Thread.java:745)</div></pre></td></tr></table></figure>
网上解决方法先尝试更新32位库文件<code>apt-get install libncurses5:i386 libstdc++6:i386 zlib1g:i386</code>
如果不行,请卸装SDK的build-tools,并安装低版本的build-tools(这是我遇到问题的解决方案,原本是build-tools/24,卸装后重新安装了build-tools/23)
问题描述及解决链接：<a href="https://code.google.com/p/android/issues/detail?id=188627" target="_blank" rel="external">https://code.google.com/p/android/issues/detail?id=188627</a></p>
<p>2. gradle需要更新某些文件
打开项目目录Gradle Scripts下找到gradle-wrapper.properties
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#Thu Apr 28 12:36:03 CST 2016</div><div class="line">distributionBase=GRADLE_USER_HOME</div><div class="line">distributionPath=wrapper/dists</div><div class="line">zipStoreBase=GRADLE_USER_HOME</div><div class="line">zipStorePath=wrapper/dists</div><div class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip</div></pre></td></tr></table></figure>
将最后一行网址部分即 
<a href="http://services.gradle.org/distributions/gradle-2.10-all.zip" target="_blank" rel="external">http://services.gradle.org/distributions/gradle-2.10-all.zip</a> 
输入浏览器手动进行下载。 
然后打开Android Studio 
设置use default gradle wrapper 
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_11_1?raw=true" alt="">
此时可能提示找不到指定的目录或文件
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_11_2?raw=true" alt="">
提示则创建对应的目录，然后将下载的zip文件移动到对应的目录下。(注意该目录是在图1的Service directory path下的)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv /home/perrin/Desktop/gradle-2.10-all.zip  /home/perrin/.gradle/wrapper/dists/gradle-2.10-all/a4w5fzrkeut1ox71xslb49gst/</div></pre></td></tr></table></figure>
然后更改目录的权限为所有用户可读可写。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod a+w /home/perrin/.gradle/ -R</div></pre></td></tr></table></figure>
如果没有其他问题，此时就可以顺利通过gradle build了。</p>
<p>详细的问题描述及解决链接：<a href="http://blog.csdn.net/junbujianwpl/article/details/51587977" target="_blank" rel="external">http://blog.csdn.net/junbujianwpl/article/details/51587977</a></p>
<h3 id="真机调试"><a href="#真机调试" class="headerlink" title=" 真机调试"></a><a name="ch3.2"> 真机调试</a></h3><p>Ubuntu下真机调试的方法</p>
<ol>
<li>首先查看手机连接的usb端口信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">root@kumho-Inspiron-3421:~# lsusb</div><div class="line">Bus 004 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub</div><div class="line">Bus 004 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</div><div class="line">Bus 003 Device 005: ID 064e:812c Suyin Corp. </div><div class="line">Bus 003 Device 006: ID 0cf3:0036 Atheros Communications, Inc. </div><div class="line">Bus 003 Device 003: ID 0bda:0129 Realtek Semiconductor Corp. RTS5129 Card Reader Controller</div><div class="line">Bus 003 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub</div><div class="line">Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</div><div class="line">Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</div><div class="line">Bus 001 Device 003: ID 093a:2510 Pixart Imaging, Inc. Optical Mouse</div><div class="line">Bus 001 Device 002: ID 2a45:0c02 Meizu Corp. MX Phone (MTP &amp; ADB)</div><div class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</div></pre></td></tr></table></figure>
这里可以清楚看到我手机的usb端口信息是Bus 001 Device 002: ID 2a45:0c02 Meizu Corp. MX Phone (MTP &amp; ADB),记下端口的ID:2a45
如果不清楚你手机的端口信息,请拔掉手机usb线,对比缺少的信息.      </li>
<li>在超级用户下打开root目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@kumho-Inspiron-3421:~# sudo nautilus</div></pre></td></tr></table></figure> 
Ctrl+H查看隐藏文件       </li>
<li>查看是否存在目录.android(不存在则创建)
在超级用户的root目录上创建文件”.android/adb_usb.ini”,此文件一定要创建,不然根本列不出设备.<br><s>注意:一定要在root用户上新建.虽然当前用户运行adb,可以连接上设备,但android studio是看root用户有没连接上的</s></li>
</ol>
<p>在adb_usb.ini写入数据
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0x2a45</div></pre></td></tr></table></figure>
2a45是你设备Usb端口ID      </p>
<ol>
<li>进入Android SDK下的platform-tools目录运行adb devices 查看是否有设备信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">root@kumho-Inspiron-3421:~# cd /root/Android/Sdk/platform-tools</div><div class="line">root@kumho-Inspiron-3421:~/Android/Sdk/platform-tools# sudo ./adb devices</div><div class="line">List of devices attached</div><div class="line">* daemon not running. starting it now on port 5037 *</div><div class="line">* daemon started successfully *</div><div class="line">88MFBMA2VP5D  device</div></pre></td></tr></table></figure>
如果没有请先运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ./adb kill-server</div></pre></td></tr></table></figure>  这些操作都是在超级用户上运行
<strong>注意</strong>执行adb操作时,可能会出现错误,如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unable to detect adb version, adb output: /home/hamid/Android/Sdk/platform-tools/adb: 1: /home/hamid/Android/Sdk/platform-tools/adb: Syntax error: &quot;)&quot;</div></pre></td></tr></table></figure>
解决方法:重新下载覆盖platform-tools<ol>
<li>下载platform-tools:<a href="https://dl-ssl.google.com/android/repository/platform-tools_r23.0.1-linux.zip" target="_blank" rel="external">点击此下载</a></li>
<li>进入Android SDK文件夹</li>
<li>删除旧的platform-tools文件夹</li>
<li>添加下载好的platform-tools<br><a href="http://askubuntu.com/questions/714653/adb-android-studio-ubuntu-error-unable-to-detect-adb-version-adb-output-hom" target="_blank" rel="external">问题详细说明</a>       </li>
</ol>
</li>
</ol>
<p>5.运行Android Stuido
同样的,在超级用户上运行Android Stuido,点击run查看是否有设备信息出现</p>
<h3 id="Android-Studio不能输入中文"><a href="#Android-Studio不能输入中文" class="headerlink" title=" Android Studio不能输入中文"></a><a name="ch3.3"> Android Studio不能输入中文</a></h3><p>1. 先确保键盘输入方式是fcitx
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">系统设置-&gt;语言支持-&gt;设置键盘输入方式-&gt;fcitx</div></pre></td></tr></table></figure>
2. 修改studio.sh
在studio.sh里函数外添加
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#Solve the problem can not enter the Chinese</div><div class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</div><div class="line">export GTK_IM_MODULE=&quot;fcitx&quot;</div><div class="line">export QT_IM_MODULE=&quot;fcitx&quot;</div><div class="line">#</div></pre></td></tr></table></figure></p>
<h3 id="Android-Studio添加注释模板"><a href="#Android-Studio添加注释模板" class="headerlink" title=" Android Studio添加注释模板"></a><a name="ch3.4"> Android Studio添加注释模板</a></h3><p>在Android Stuido中添加注释模板的方法</p>
<p>1. 打开Live Templates设置面板
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">File-&gt;Setting-&gt;Editor-&gt;Live Templates</div></pre></td></tr></table></figure></p>
<p>2. 添加自定义模板组
点击面板右边的<code>+</code>,添加<code>Templates Group</code>,输入模板组名称(这里我输入的是”Custom”),如下图
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_11_3.png?raw=true" alt="">
注:”cma”是我之前生成的注释模板</p>
<p>3. 配置注释模板</p>
<ol>
<li>选中自定义模板组, 点击面板右边的<code>+</code>,添加<code>Live Templates</code>,输入模板名称</li>
<li>配置模板:<ul>
<li><code>Abbreviation</code>:输入模板名(这里入的是”cmc”,给类信息生成注释模板),注意<strong>模板名</strong>也就是我们在代码需输入模板名后才能生成模板,不建议太长.</li>
<li><code>Description</code>:描述信息.</li>
<li><code>Template text</code>:模板,这里我们输入模板文本,变量用<code>$变量名$</code>表示.</li>
<li><code>Define</code>:起作用的环境,这里选择<code>java-&gt;declaration</code></li>
<li><code>Expand with</code>:展开模板键,这里我选择[Enter]<br>如下配置完模板信息
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_11_4.png?raw=true" alt=""></li>
</ul>
</li>
<li>配置变量信息
点击<code>Edit variables</code>,弹出变量设置面板如下,并做相应设置
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_11_5.png?raw=true" alt=""></li>
<li>使用模板信息
在java代码中,输入模板名再按[Enter]就会生成注释模板(这里我是输入”cmc”+[Enter]),生成如下图的模板信息.<br><img src="https://github.com/HiKumho/blog/blob/master/img/blog_11_6.png?raw=true" alt=""></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 磁盘分区]]></title>
      <url>http://yoursite.com/2016/09/05/Linux-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/</url>
      <content type="html"><![CDATA[<h2 id="Linux与硬件"><a href="#Linux与硬件" class="headerlink" title=" Linux与硬件"></a><a name="ch1"> Linux与硬件</a></h2><h3 id="各硬件设备在Linux中的文件名"><a href="#各硬件设备在Linux中的文件名" class="headerlink" title=" 各硬件设备在Linux中的文件名"></a><a name="ch1.1"> 各硬件设备在Linux中的文件名</a></h3><p>在Linux系统中，每个设备都被当成一个文件来对待。举例说，IDE接口连接的硬盘的文件名即为/dev/hd[a-d],其中，括号内的字母为a-d当中的任意一个。</p>
<p>下面列出几个常见设备与其在Linux当中的文件名，更多Linux内核支持的硬件与文件名，可以参考<a href="https://www.kernel.org/pub/linux/docs/lanana/device-list/devices-2.6.txt" target="_blank" rel="external">Linux内核支持硬件列表</a>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">设备</th>
<th style="text-align:center">Liunx中的文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IDE硬盘</td>
<td style="text-align:center">/dev/hd[a-d]</td>
</tr>
<tr>
<td style="text-align:center">SCSI/SATA/USB硬盘</td>
<td style="text-align:center">/dev/sd[a-p]</td>
</tr>
<tr>
<td style="text-align:center">U盘</td>
<td style="text-align:center">/dev/sd[a-p](与SATA相同)</td>
</tr>
<tr>
<td style="text-align:center">软驱</td>
<td style="text-align:center">/dev/fd[0-1]</td>
</tr>
<tr>
<td style="text-align:center">打印机</td>
<td style="text-align:center">25针:/dev/lp[0-2]  ;  USB:/dev/usb/lp[0-15]</td>
</tr>
<tr>
<td style="text-align:center">鼠标</td>
<td style="text-align:center">USB:/dev/usb/mouse[0-15] ;  PS2:/de/pxaux</td>
</tr>
<tr>
<td style="text-align:center">当前CD ROM/DVD ROM</td>
<td style="text-align:center">/dev/cdrom</td>
</tr>
<tr>
<td style="text-align:center">当前鼠标</td>
<td style="text-align:center">/dev/mouse</td>
</tr>
<tr>
<td style="text-align:center">磁带机</td>
<td style="text-align:center">IDE:/dev/ht0  ;  SCSI:/dev/st0</td>
</tr>
</tbody>
</table>
<p>需要特别留意的是硬盘(IDE,SCSI,USB,SATA都一样)，每个磁盘驱动器的磁盘分区不同时,其磁盘文件名还会改变。以SATA/USB接口的磁盘为例，Linux内核会根据检测到磁盘的顺序来决定磁盘的设备文件名。</p>
<p>比如:
如果你的PC上面有两个SATA磁盘以及一个USB磁盘，而主板上面有六个SATA的插槽，这两个SATA磁盘分别安插在主板上的SATA1,SATA5插槽上，请问这三个磁盘在Linux中的设备文件名是什么？</p>
<ol>
<li>SATA1插槽上的文件名是:/dev/sda</li>
<li>SATA5插槽上的文件名是:/dev/sdb</li>
<li>USB磁盘(开机完成后才被系统识别):/dev/sdc</li>
</ol>
<h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title=" 磁盘分区"></a><a name="ch2"> 磁盘分区</a></h2><h3 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title=" 磁盘的物理结构"></a><a name="ch2.1"> 磁盘的物理结构</a></h3><p>磁盘主要由盘片、机械手臂、磁头与主轴马达所组成。</p>
<ul>
<li>盘片：数据存储的物理结构,可以理解成光盘,磁盘由多个盘片叠加而成。</li>
<li>磁道：磁盘旋转时，磁头保持不动，在磁盘上划出的圆形轨道。</li>
<li>柱面：不同盘片的面，处于同一半径源的多个磁道组成的一个圆柱面。</li>
<li>扇区：将每个磁道等分为若干个弧段，这些弧段为扇区。每个扇区占512字节。<strong>其中磁盘的第一个扇区主要记录了两个重要的信息:</strong><ul>
<li>主引导分区(Master Boot Recode,MBR):可以安装引导加载程序的地方,有446字节。</li>
<li>分区表(Partition table):记录整块磁盘的分区状况，有64字节。</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/blog_10_1.png?raw=true" alt=""></p>
<hr>
<h3 id="磁盘分区表"><a href="#磁盘分区表" class="headerlink" title=" 磁盘分区表"></a><a name="ch2.2"> 磁盘分区表</a></h3><p>所谓“分区”是指对分区表进行设置，在分区表所在的64字节容量中,最多只能容纳4个分区，这4个分区被称为主或扩展分区，每个分区以其的起始、结束的柱面号码为划分，一组的分区柱面号码占16字节，即<strong>一个分区信息用16字节表示</strong>，所在分区表最多只能容纳4个分区。而分区的最小单位是柱面。总结下：</p>
<ul>
<li>其实所谓的“”分区”只是针对那个64字节的分区表进行设置</li>
<li>磁盘的默认分区表最多能写入4组分区信息</li>
<li>这4组分区信息称为主或扩展分区</li>
<li>分区的最小单位是柱面</li>
</ul>
<p>为了记录更多的分区信息，我们可以利用扩展分区来建立逻辑分区，扩展分区的目的是使用额外的扇区来记录分区信息。注意<strong>逻辑分区的设备名称号码由5号开始</strong>，前面4个号码保留给主分区或扩展分区使用。总结下：</p>
<ul>
<li>主分区与扩展分区最多可以有4个(磁盘的限制)</li>
<li>扩展分区最多只能有一个(操作系统的限制)</li>
<li>逻辑分区是由扩展分区连续切割出来的分区</li>
<li>能够被格式化后作为数据访问的分区为主分区与逻辑分区，扩展分区无法格式化</li>
<li>逻辑分区的数量依操作系统而不同,Linux下，IDE硬盘最多有59个逻辑分区(5号到63号)，SATA硬盘则有11个逻辑分区(5号到15号)</li>
</ul>
<hr>
<h3 id="开机流程与主引导分区-MBR"><a href="#开机流程与主引导分区-MBR" class="headerlink" title=" 开机流程与主引导分区(MBR)"></a><a name="ch2.3"> 开机流程与主引导分区(MBR)</a></h3><p>整个开机流程到操作系统之前的动作如下：</p>
<ol>
<li>BIOS：开机主动执行的固件,会到硬盘中读取第一扇区的MBR。(硬件支持)</li>
<li>MBR：MBR包含引导加载程序。（硬件支持，安装操作系统时，操作系统会修改MBR）</li>
<li>引导加载程序(Boot loader)：一个读取操作系统内核文件来执行的软件。（操作系统在安装时提供）</li>
<li>内核文件：开始操作系统的功能。</li>
</ol>
<p>引导加载程序主要任务有以下：</p>
<ul>
<li>提供菜单：用户可以选择不同的开机选项，这也是多重引导的重要功能。</li>
<li>载入内核文件：直接指向可开机的程序区段来开始操作系统。</li>
<li>转交其他loader：将引导加载功能转交给其他loader负责。</li>
</ul>
<p>当你的计算机系统有两个以上的引导加载程序，我们可以使用多重引导。引导加载程序除了可以安装在MBR之外，还可以安装在每个分区的引导扇区。</p>
<p>举个例子：
假设你的计算机只有一块硬盘,里面分成4个分区，其中第1,2分区分别安装了Windows及Linux，你要如何在开机的时候选择用Windows还是Linux开机呢？假设MBR内安装的是同时识别Windows/Linux操作系统的引导加载程序，那么整个流程如下:</p>
<p><img src="https://github.com/HiKumho/blog/blob/master/img/blog_10_2.gif?raw=true" alt=""></p>
<hr>
<h3 id="文件系统与目录树"><a href="#文件系统与目录树" class="headerlink" title=" 文件系统与目录树"></a><a name="ch2.4"> 文件系统与目录树</a></h3><ul>
<li>目录树结构<br>Linux所有数据都是以文件形态来呈现的，整个Linux系统重要的地方就是在于目录树结构，所谓目录树结构就是以根目录(表示方法为‘’/‘’)为主，然后向下呈现分支状的目录结构的一种文件结构。整个系统只有一个目录树。<br><strong>我们文件数据其实是放置在磁盘分区当中的</strong>，现在的问题是如何结合目录树的架构与磁盘内数据，这就是<strong>挂载</strong>的概念了</li>
<li>文件系统与目录树的关系(挂载)<br>挂载就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下。进入点的目录我们称为<strong>挂载点</strong>。Linux最重要的是根目录，因此根目录一定要挂载到某个分区。</li>
</ul>
<h2 id="主机硬盘的规划"><a href="#主机硬盘的规划" class="headerlink" title=" 主机硬盘的规划"></a><a name="ch3"> 主机硬盘的规划</a></h2><h3 id="基本硬盘分区模式"><a href="#基本硬盘分区模式" class="headerlink" title=" 基本硬盘分区模式"></a><a name="ch3.1"> 基本硬盘分区模式</a></h3><ul>
<li>最简单的分区方法<br>仅分出根目录与内存交换空间(Swap)，然后再预留一些剩余磁盘以供后续练习之用。</li>
<li>稍微麻烦一点的方式<ul>
<li>/</li>
<li>/usr (程序安装)</li>
<li>/home (用户主目录基点)</li>
<li>/var (经常变动的数据)</li>
<li>Swap</li>
</ul>
</li>
</ul>
<p>详细请查看<a href="https://github.com/HiKumho/blog/blob/master/Liunx%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%9C%E7%94%A8(%E8%BD%AC%E8%BD%BD.md" target="_blank" rel="external">Liunx各目录作用</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 安装JDK]]></title>
      <url>http://yoursite.com/2016/09/05/Linux-%E5%AE%89%E8%A3%85JDK/</url>
      <content type="html"><![CDATA[<h2 id="直接下载jdk压缩包方式安装"><a href="#直接下载jdk压缩包方式安装" class="headerlink" title="直接下载jdk压缩包方式安装"></a>直接下载jdk压缩包方式安装</h2><p>分为下面5个步骤</p>
<ol>
<li>官网下载JDK</li>
<li>解压缩,放到指定目录</li>
<li>配置环境变量</li>
<li>设置系统默认JDK</li>
<li>测试JDK</li>
</ol>
<h3 id="官网下载JDK"><a href="#官网下载JDK" class="headerlink" title="官网下载JDK"></a>官网下载JDK</h3><p>网址: <a href="http://www.oracle.com/technetwork/articles/javase/index-jsp-138363.html" target="_blank" rel="external">http://www.oracle.com/technetwork/articles/javase/index-jsp-138363.html</a>
选择相应的 .gz包下载  (这里我选择了”jdk-8u92-linux-i586.tar.gz”)</p>
<h3 id="解压缩-放到指定目录-以jdk-8u92-linux-i586-tar-gz为例"><a href="#解压缩-放到指定目录-以jdk-8u92-linux-i586-tar-gz为例" class="headerlink" title="解压缩,放到指定目录(以jdk-8u92-linux-i586.tar.gz为例)"></a>解压缩,放到指定目录(以jdk-8u92-linux-i586.tar.gz为例)</h3><ol>
<li><p>创建目录
<code>sudo mkdir /home/kumho/usr/lib/jvm</code>    </p>
</li>
<li><p>解压文件至目录
<code>sudo tar -zxvf jdk-8u92-linux-i586.tar.gz -C  /home/kumho/usr/lib/jvm</code>      </p>
</li>
</ol>
<h3 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h3><p><code>sudo vim ~/.bashrc</code> 
文件的末尾追加下面内容: 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#set oracle jdk environment </div><div class="line">export JAVA_HOME=/home/kumho/usr/lib/jvm/jdk1.8.0_92  ##这里要注意目录要换成自己解压的jdk 目录</div><div class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre </div><div class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</div><div class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</div></pre></td></tr></table></figure></p>
<p>使环境变量马上生效<code>source ~/.bashrc</code>    </p>
<h3 id="设置系统默认jdk-版本"><a href="#设置系统默认jdk-版本" class="headerlink" title="设置系统默认jdk 版本"></a>设置系统默认jdk 版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo update-alternatives --install /usr/bin/java java /home/kumho/usr/lib/jvm/jdk1.8.0_92/bin/java 300</div><div class="line">sudo update-alternatives --install /usr/bin/javac javac /home/kumho/usr/lib/jvm/jdk1.8.0_92/bin/javac 300</div><div class="line">sudo update-alternatives --install /usr/bin/jar jar /home/kumho/usr/lib/jvm/jdk1.8.0_92/bin/jar 300</div><div class="line">sudo update-alternatives --install /usr/bin/javah javah /home/kumho/usr/lib/jvm/jdk1.8.0_92/bin/javah 300</div><div class="line">sudo update-alternatives --install /usr/bin/javap javap /home/kumho/usr/lib/jvm/jdk1.8.0_92/bin/javap 300</div></pre></td></tr></table></figure>
<p>然后执行:
<code>sudo update-alternatives --config java</code>
若是初次安装jdk,会有下面的提示
 There is only one alternative in link group java (providing /usr/bin/java): 
 /home/kumho/usr/lib/jvm/jdk1.8.0_92/bin/java<br>否则,选择合适的jdk</p>
<h3 id="测试jdk"><a href="#测试jdk" class="headerlink" title="测试jdk"></a>测试jdk</h3><p><img src="https://github.com/HiKumho/blog/blob/master/img/blog_9_1.png?raw=true" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android FQA]]></title>
      <url>http://yoursite.com/2016/09/05/Android-FQA/</url>
      <content type="html"><![CDATA[<!--
## Index
- <a href="#q1"> Android:id设置的三种方式区别?</a>
- <a href="#q2"> Android程序级权限与组件级权限的区别</a>
- <a href="#q3"> Activity、Window、View的关系</a>
- <a href="#q4"> 关于9-patch的使用</a>
- <a href="#q5"> ListView怎么隐藏滚动条?</a>
- <a href="#q6"> 关于同区域两个组件设置了类似的监听器,哪个作用?</a>
- <a href="#q7"> 怎么引用当前主题的属性值</a>
-->
<h3 id="Android-id设置的三种方式区别"><a href="#Android-id设置的三种方式区别" class="headerlink" title=" Android:id设置的三种方式区别?"></a><a name="q1"> Android:id设置的三种方式区别?</a></h3><p>对Android控制设置id,通常有以下三种方式:</p>
<blockquote>
<ul>
<li>android:id=”@+id/btn”</li>
<li>android:id=”@id/btn”</li>
<li>android:id=”@android:id/button1”         </li>
</ul>
</blockquote>
<h4 id="android-id-”-id-btn”"><a href="#android-id-”-id-btn”" class="headerlink" title="android:id=”@+id/btn”"></a>android:id=”@+id/btn”</h4><p>表示在R.java资源文件中新增一个id为btn的控件索引</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">id</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> btn =<span class="number">0x7f0b0056</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码获取方式:findViewById(R.id.btn);</p>
<h4 id="android-id-”-id-btn”-1"><a href="#android-id-”-id-btn”-1" class="headerlink" title="android:id=”@id/btn”"></a>android:id=”@id/btn”</h4><p>表示使用R.java资源文件中已存在的id为btn的索引
代码获取方式:跟1一样</p>
<h4 id="android-id-”-android-id-button1”"><a href="#android-id-”-android-id-button1”" class="headerlink" title="android:id=”@android:id/button1”"></a>android:id=”@android:id/button1”</h4><p>表示使用的是系统已有的ID，在对应的sdk目录下的ids.xml里面(如Sdk/platforms/android-21/data/res/values/ids.xml) ,一般只去引用其ID,不直接使用其ID作为自己App控件索引
代码中获取方式:android.R.id.button1</p>
<h4 id="在ids-xml中添加自己的Id组"><a href="#在ids-xml中添加自己的Id组" class="headerlink" title="在ids.xml中添加自己的Id组"></a>在ids.xml中添加自己的Id组</h4><p> 我们可以在values下新建ids.xml,然后写入id项,便于方式2使用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;resources&gt;</div><div class="line">    &lt;item name=&quot;btn_1&quot; type=&quot;id&quot;&gt;&lt;/item&gt;</div><div class="line">    &lt;item name=&quot;btn_2&quot; type=&quot;id&quot;&gt;&lt;/item&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<h4 id="当同个layout布局文件中-多个组件使用同一个id的问题"><a href="#当同个layout布局文件中-多个组件使用同一个id的问题" class="headerlink" title="当同个layout布局文件中,多个组件使用同一个id的问题"></a>当同个layout布局文件中,多个组件使用同一个id的问题</h4><p>当我们调用<code>findViewById(int id)</code>被引用的是第一个使用此id的控件</p>
<h3 id="Android程序级权限与组件级权限的区别"><a href="#Android程序级权限与组件级权限的区别" class="headerlink" title=" Android程序级权限与组件级权限的区别"></a><a name="q2"> Android程序级权限与组件级权限的区别</a></h3><h4 id="程序组权限"><a href="#程序组权限" class="headerlink" title="程序组权限"></a>程序组权限</h4><p>程序运行时所需要的权限 通过在<code>&lt;manifest&gt;</code>元素下添加<code>&lt;usespermission&gt;</code>为程序本身声明权限       </p>
<h4 id="组件级权限"><a href="#组件级权限" class="headerlink" title="组件级权限"></a>组件级权限</h4><p>程序各组件可以被其他程序调用,此时该组件声明所需的权限.通过在<code>&lt;activity&gt;``&lt;service&gt;</code>等元素下添加<code>&lt;usespermission&gt;</code>为组件声明权限.</p>
<h3 id="Activity、Window、View的关系"><a href="#Activity、Window、View的关系" class="headerlink" title=" Activity、Window、View的关系"></a><a name="q3"> Activity、Window、View的关系</a></h3><p>详细问题描述:<a href="http://www.cnblogs.com/loulijun/archive/2012/02/09/2344681.html" target="_blank" rel="external">原文链接</a>        </p>
<h4 id="View和ViewGroup"><a href="#View和ViewGroup" class="headerlink" title="View和ViewGroup"></a>View和ViewGroup</h4><p>Android系统中的所有UI类都是建立在View和ViewGroup这两个类的基础上的。所有View的子类成为”Widget”，所有ViewGroup的子类成为”Layout”。View和ViewGroup之间采用了组合设计模式，可以使得“部分-整体”同等对待。ViewGroup作为布局容器类的最上层，布局容器里面又可以有View和ViewGroup。         </p>
<h4 id="LayoutInflater，LayoutInflater-inflate"><a href="#LayoutInflater，LayoutInflater-inflate" class="headerlink" title="LayoutInflater，LayoutInflater.inflate()"></a>LayoutInflater，LayoutInflater.inflate()</h4><p>LayoutInflater是一个用来实例化XML布局文件为View对象的类</p>
<p>LayoutInflater.infalte(R.layout.test,null)用来从指定的XML资源中填充一个新的View</p>
<h4 id="Activity、Window、View之间的关系"><a href="#Activity、Window、View之间的关系" class="headerlink" title="Activity、Window、View之间的关系"></a>Activity、Window、View之间的关系</h4><p>而当我们运行程序的时候，有一个setContentView()方法，Activity其实不是显示视图（直观上感觉是它），实际上Activity调用了PhoneWindow的setContentView()方法，然后加载视图，将视图放到这个Window上，而Activity其实构造的时候初始化的是Window（PhoneWindow），Activity其实是个控制单元，即可视的人机交互界面。</p>
<p>打个比喻：</p>
<p>Activity是一个工人，它来控制Window；Window是一面显示屏，用来显示信息；View就是要显示在显示屏上的信息，这些View都是层层重叠在一起（通过infalte()和addView()）放到Window显示屏上的。而LayoutInfalter就是用来生成View的一个工具，XML布局文件就是用来生成View的原料</p>
<p>再来说说代码中具体的执行流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setContentView(R.layout.main)其实就是下面内容。</div><div class="line">getWindow().setContentView(LayoutInflater.from(this).inflate(R.layout.main, null))</div></pre></td></tr></table></figure>
<p>即运行程序后，Activity会调用PhoneWindow的setContentView()来生成一个Window，而此时的setContentView就是那个最底层的View。然后通过LayoutInflater.infalte()方法加载布局生成View对象并通过addView()方法添加到Window上，（一层一层的叠加到Window上）</p>
<p>所以，Activity其实不是显示视图，View才是真正的显示视图</p>
<p>注：一个Activity构造的时候只能初始化一个Window(PhoneWindow)，另外这个PhoneWindow有一个”ViewRoot”，这个”ViewRoot”是一个ViewGroup，是最初始的根视图，然后通过addView方法将View一个个层叠到ViewRoot上，这些层叠的View最终放在Window这个载体上面</p>
<h3 id="关于9-patch的使用"><a href="#关于9-patch的使用" class="headerlink" title=" 关于9-patch的使用"></a><a name="q4"> 关于9-patch的使用</a></h3><p>学习<a href="http://leoray.leanote.com/post/android-9-patch" target="_blank" rel="external">9-pathch笔记</a>
从上面的文章,我们可以知道Android显示9-patch的内容区域是在图片上设置padding,如果我们在引用这张图片的组件上再设置padding的话,9-patch的padding就会失效,达不到需要的效果.</p>
<p>注意:Android Studio使用minmap代替drawable目录,9-patch图片在minmap目录,引用9-patch图片时会报错(AS支持问题)
解决方法1:9-patch图片放在drawable
解决方法2:修复9-patch的bad-patches区域(show bad patches出来的红色线区)</p>
<h3 id="ListView怎么隐藏滚动条"><a href="#ListView怎么隐藏滚动条" class="headerlink" title=" ListView怎么隐藏滚动条?"></a><a name="q5"> ListView怎么隐藏滚动条?</a></h3><p>设置andriod:scrollbars=”none”即可</p>
<h3 id="关于同区域两个组件设置了类似的监听器-哪个作用"><a href="#关于同区域两个组件设置了类似的监听器-哪个作用" class="headerlink" title=" 关于同区域两个组件设置了类似的监听器,哪个作用?"></a><a name="q6"> 关于同区域两个组件设置了类似的监听器,哪个作用?</a></h3><p>是最上层的组件的监听器响应.
比方说,父组件设置点击监听,子组件也设置了点击监听,在子组件的区域里,点击是子组件响应,在子组件外的区域里,点击是父组件响应</p>
<h3 id="怎么引用当前主题的属性值"><a href="#怎么引用当前主题的属性值" class="headerlink" title=" 怎么引用当前主题的属性值"></a><a name="q7"> 怎么引用当前主题的属性值</a></h3><p>要引用样式属性，名称语法几乎与普通资源格式完全相同，只不过将 at 符号 (@) 改为问号 (?)，资源类型部分为可选项。比如,下面例子中,Android将会使用当前主题的android:textColorSecondary的属性值设置组件的textColor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:textColor=&quot;?android:textColorSecondary&quot;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux FQA]]></title>
      <url>http://yoursite.com/2016/09/05/Linux-FQA/</url>
      <content type="html"><![CDATA[<!--
### Index
1. <a href="#q1">查看主机内核版本</a>
2. <a href="#q2">进入root文件夹</a>
3. <a href="#q3">终端显示乱码</a>
4. <a href="#q4">重启X Window的方法</a>
5. <a href="#q5">图形界面与终端界面切换</a>
6. <a href="#q6">命令基本格式</a>
7. <a href="#q7">nano文本编辑器</a>
8. <a href="#q8">shutdown</a>
9. <a href="#q9">修改终端模式欢迎信息</a>
10. <a href="#q10">设置环境变量LANG</a>
11. <a href="#q11"> 关于cp的一个疑问?(待解决)</a>
12. <a href="#q12">删除了用户的主目录,进入不了该用户的图形界面环境</a>
13. <a href="#q13">Vim解决中文乱码的问题</a>
14. <a href="#q14">Shell 中判断符号[]使用的问题</a>
15. <a href="#q15">grub > unknow filesystem的解决方法</a>
16. <a href="#q16">忘记root密码的解决方法</a>
17. <a href="#q17">init的配置文件错误,无法启动系统</a>
18. <a href="#q18">如何切换操作系统(不能重启)</a>
19. <a href="#q19">查看打印机是否支持Linux</a>
20. <a href="#q20">修改主机名</a>
21. <a href="#q21">Ubuntu14.04下SublimeText3不能输中文</a>
-->
<h3 id="查看主机内核版本"><a href="#查看主机内核版本" class="headerlink" title=" 查看主机内核版本"></a><a name="q1"> 查看主机内核版本</a></h3><p>使用命令: 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat  /proc/version</div></pre></td></tr></table></figure></p>
<h3 id="进入root文件夹"><a href="#进入root文件夹" class="headerlink" title=" 进入root文件夹"></a><a name="q2"> 进入root文件夹</a></h3><p>使用命令: 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nautilus</div></pre></td></tr></table></figure></p>
<h3 id="终端显示乱码"><a href="#终端显示乱码" class="headerlink" title=" 终端显示乱码"></a><a name="q3"> 终端显示乱码</a></h3><p>终端默认情况下不能显示中文,刚好我们终端最优先是显示zh.CN的话,那么显示英文也会乱码,解决方法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 查看目前支持的语言</div><div class="line">$ echo &amp;LANG</div><div class="line">zh_CN.UTF-8</div><div class="line"></div><div class="line">2. 修改语言为UTF-8和en_US</div><div class="line">$ LANG=UTF-8.en_US</div></pre></td></tr></table></figure></p>
<h3 id="重启X-Window的方法"><a href="#重启X-Window的方法" class="headerlink" title=" 重启X Window的方法"></a><a name="q4"> 重启X Window的方法</a></h3><ul>
<li>直接注销,然后再重新登陆</li>
<li>X Window界面中按下[Ctrl]+[Alt]+[Backspace]</li>
</ul>
<h3 id="图形界面与终端界面切换"><a href="#图形界面与终端界面切换" class="headerlink" title=" 图形界面与终端界面切换"></a><a name="q5"> 图形界面与终端界面切换</a></h3><p>终端可以理解成独立设备,Linux会提供5到6个的虚拟终端界面给用户.其与图形界面的切换方式如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[Ctrl]+[Alt]+[F1]~[F6]:登录tty1~tty6终端;(通常情况下是F1~F6,可是我的CentOS6.8是F2~F6)</div><div class="line">[Ctrl]+[Alt]+[F7]:登录图形界面(我的CentOS6.8是F1)</div></pre></td></tr></table></figure></p>
<h3 id="命令基本格式"><a href="#命令基本格式" class="headerlink" title=" 命令基本格式"></a><a name="q6"> 命令基本格式</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$      command      [-opt|--options]    parmeter1   parameter2 ...</div><div class="line"> 命令/可执行文件         -选项|--完整选项名       参数1       参数2</div></pre></td></tr></table></figure>
<ul>
<li>如果命令太长,可以用\来转义[Enter]</li>
<li>[TAB]:补齐命令或文件名</li>
<li>[Ctrl]+C:命令执行中断(通常中断程序级命令)</li>
<li>[Ctrl]+D:键盘输入结束/退出程序/命令行模式注销用户~exit</li>
<li>[TAB][TAB]:可以查看系统所有命令</li>
</ul>
<h3 id="nano文本编辑器"><a href="#nano文本编辑器" class="headerlink" title=" nano文本编辑器"></a><a name="q7"> nano文本编辑器</a></h3><p>nano编辑器可以用在命令行模式下,执行命令<code>$ nano</code>启动nano,根据提示操作</p>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title=" shutdown"></a><a name="q8"> shutdown</a></h3><p>通常我们关机前会使用多次<code>sync</code>命令将数据同步写入硬盘中(Linux
为了加速数据读取,某些已加载内存中的数据不直接写会硬盘,而是暂存内存中)</p>
<p><strong>关机命令:shutdown</strong>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ shutdown [-arkhncfF] 时间 [警告信息]</div></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>-k:只发送警告信息,不是真关机</li>
<li>-r:在将系统服务停掉后重启(常用)</li>
<li>-h:将系统服务停掉后关机(常用)</li>
<li>-n:不经过init程序,直接以shutdown功能来关机</li>
<li>-f:关机并开机后,强制略过fsck的磁盘检查</li>
<li>-F:系统重启之后,强制你行fsck磁盘检查</li>
<li>-c:取消计划</li>
</ul>
</blockquote>
<p>例子:</p>
<blockquote>
<ul>
<li>shutdown -h 0                      //立刻关机</li>
<li>shutdown -h 20:25              //今天的20:25会关机</li>
<li>shutdown -h 10                   //10分钟后关机</li>
<li>shutdown -r 30 ‘The system will reboot’   //30分钟后重启</li>
</ul>
</blockquote>
<h3 id="修改终端模式欢迎信息"><a href="#修改终端模式欢迎信息" class="headerlink" title=" 修改终端模式欢迎信息"></a><a name="q9"> 修改终端模式欢迎信息</a></h3><p>1.  打开终端欢迎信息文件<code>/etc/issue</code>
在终端模式下可以使用nano/vim文本编辑器打开
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># nano /etc/issue</div></pre></td></tr></table></figure></p>
<p>2. /etc/issue中的占位符
如果需要使用占位符,可以man查询下agetty的<code>ISSUE ESCAPES</code>项的各参数</p>
<h3 id="设置环境变量LANG"><a href="#设置环境变量LANG" class="headerlink" title="  设置环境变量LANG"></a><a name="q10">  设置环境变量LANG</a></h3><p>在终端上使用<code>ls -al</code>,发现中文目录都出现”???”,参考<a href="#q3">问题3. 终端显示乱码</a>还是没有解决,而且设置的LANG还是一关机后或者切换到其他终端就不用作用的,于是设置环境变量LANG</p>
<p>1.  设置环境变量LANG
在/etc/sysconfig/i18n上修改或添加LANG=“UTF-8.en_US”
注:上面是CentOS的locale环境变量设置,Ubuntu在/etc/default/locale中设置</p>
<p>2.  设置环境变量LANG=“UTF-8.en_US”时
遇到以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">warning: setlocale: LC_CTYPE: cannot change locale (UTF-8.en_US) </div><div class="line">warning: Setting locale failed.</div></pre></td></tr></table></figure>
<p>解决方法：这里我将环境变量LANG中的UTF-8去掉了。</p>
<p>3. 之后修改系统语系为English,并将中文目录更新为英文</p>
<h3 id="关于cp的一个疑问-待解决"><a href="#关于cp的一个疑问-待解决" class="headerlink" title=" 关于cp的一个疑问?(待解决)"></a><a name="q11"> 关于cp的一个疑问?(待解决)</a></h3><p>遇到的问题:<br>今天将<code>/root/AndroidStudioProjects/TextProject</code>项目复制到 <code>/media/kumho/文档/Github/</code><br>root使用命令<code>cp -a ~/AndroidStudioProjects/TextProject /media/kumho/文档/Github/</code>,发现目标目录的用户/用户组全部更改成kumho,权限也被修改成700,这里好奇怪原目录的用户/用户组是root,权限是755</p>
<p>明明 <code>cp -a</code>会将目录及子文件的属性都进行复制,为什么目标目录会被修改?</p>
<p>这里查看了<code>/media/kumho</code>的文件属性<code>drwxr-x---+ 4 root root 4096  7月 19 17:27 /media/kumho</code> 发现文件权限后有个<code>+</code>,表示不解(貌似是ACL权限控制)</p>
<h3 id="删除了用户的主目录-进入不了该用户的图形界面环境"><a href="#删除了用户的主目录-进入不了该用户的图形界面环境" class="headerlink" title=" 删除了用户的主目录,进入不了该用户的图形界面环境"></a><a name="q12"> 删除了用户的主目录,进入不了该用户的图形界面环境</a></h3><p>今天不小心将/home目录删除了(自打100下…..),之后发觉进入不了相关用户的图形界面环境
解决方法:进入终端,使用root,创建用户的主目录/home/用户名,并修改此文件的所有者与用户组为该用户</p>
<h3 id="Vim解决中文乱码的问题"><a href="#Vim解决中文乱码的问题" class="headerlink" title=" Vim解决中文乱码的问题"></a><a name="q13"> Vim解决中文乱码的问题</a></h3><p>我将vim的编码都设置成utf8,可以解决中文乱码
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">set encoding=utf-8             &quot;Vim内部使用的字符编码,比如脚本中的字符串,buffer,寄存器等</div><div class="line">set termencoding=utf-8     &quot;Vim用于屏幕显示的编码,显示时Vim将内部编码转出屏幕编码</div><div class="line">set fileencoding=utf-8     &quot;Vim保存文件时的编码格式</div><div class="line">set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1 &quot;Vim识别文件编码格式的识别序列，应当按照从严格到宽松的角度来摆放</div></pre></td></tr></table></figure></p>
<p>参考学习
<a href="http://edyfox.codecarver.org/html/vim_fileencodings_detection.html" target="_blank" rel="external">Vim文件编码识别与乱码处理</a></p>
<h3 id="Shell-中判断符号-使用的问题"><a href="#Shell-中判断符号-使用的问题" class="headerlink" title=" Shell 中判断符号[]使用的问题"></a><a name="q14"> Shell 中判断符号[]使用的问题</a></h3><p>判断符号[]使用有些麻烦,必须在几个地方插入空格(□)才行,比如下面的例子
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[□&quot;Hello World&quot;□==□&quot;Hello&quot;□-o□&quot;$Test&quot;□!=□&quot;Test&quot;□]</div></pre></td></tr></table></figure></p>
<p>就是要在变量/常量/判断符两边加上空格(□)
如果确认编写无误后,还报出”unexpected operator” 可能是shell的原因
比如 ubuntu中的sh -&gt; /bin/dash ,其中 /bin/dash不支持 <code>==</code>
解决方法:</p>
<ol>
<li>将sh -&gt; /bin/bash : sudo dpkg-reconfigure dash   选NO</li>
<li>使用/bin/dash : 用<code>=</code>代替<code>==</code></li>
</ol>
<h3 id="grub-gt-unknow-filesystem的解决方法"><a href="#grub-gt-unknow-filesystem的解决方法" class="headerlink" title=" grub &gt; unknow filesystem的解决方法"></a><a name="q15"> grub &gt; unknow filesystem的解决方法</a></h3><p>Linux安装时分配的空间过少,而且还乱分区,所以今天想整合下分区,把没弄的分区删去.</p>
<p>我的根目录挂载了/dev/sda9,前面还有个/dev/sda8没有使用(df -hl 中并没有挂载/dev/sda8).于是将其删除,
但重启系统时,遇到 <code>grub &gt; unknow filesystem</code> 的问题</p>
<p>我想是系统找不到/boot了(我的/boot没有独立分区),可能是因为根目录挂载变成/dev/sda8的原因.</p>
<p>这样查到了网上的解决方法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">grub rescue &gt; ls   # 查看系统分区情况</div><div class="line">我这里列出了(hd0,msdos9),(hd0,msdos8)等</div><div class="line"></div><div class="line">grub rescue &gt; set root=(hd0,msdos8)  # 指向根目录</div><div class="line"></div><div class="line">grub rescue &gt; set prefix=(hd0,msdos8)/boot/grub  # 指定boot位置</div><div class="line"></div><div class="line">grub rescue &gt; insmod normal # 这命令不太懂</div><div class="line"></div><div class="line">grub rrescue &gt; normal #进入了平常的grub</div></pre></td></tr></table></figure></p>
<p>这里进入系统后, 下次重启时还会出现这种情况(治标不治本),于是用了boot-repair工具修复
下面是安装并启动boot-repair
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add-apt-repository ppa:yannubuntu/boot-repair &amp;&amp; apt-get update</div><div class="line">apt-get install -y boot-repair &amp;&amp; boot-repair</div></pre></td></tr></table></figure></p>
<p>问题解决. 
其实也可以直接用LIVE-CD启动系统,再用boot-repair解决(今天U盘刚好找不到了)</p>
<h3 id="忘记root密码的解决方法"><a href="#忘记root密码的解决方法" class="headerlink" title=" 忘记root密码的解决方法"></a><a name="q16"> 忘记root密码的解决方法</a></h3><ol>
<li>启动系统,进入boot loader启动菜单编辑,在内核项最后添加single</li>
<li>进入单用户维护模式,取得了root的shell</li>
<li>利用passwd修改密码</li>
</ol>
<p>或者用启动盘启动系统,再挂载其原系统,利用chroot来改变工作中的系统,切换到原系统,利用passwd修改</p>
<h3 id="init的配置文件错误-无法启动系统"><a href="#init的配置文件错误-无法启动系统" class="headerlink" title=" init的配置文件错误,无法启动系统"></a><a name="q17"> init的配置文件错误,无法启动系统</a></h3><ol>
<li>启动系统,进入boot loader启动菜单编辑,在内核项最后添加init=/bin/bash</li>
<li>启动root的shell后再去修改init的配置文件(可能要重新挂载根目录,使其成可读写状态)</li>
</ol>
<h3 id="如何切换操作系统-不能重启"><a href="#如何切换操作系统-不能重启" class="headerlink" title=" 如何切换操作系统(不能重启)"></a><a name="q18"> 如何切换操作系统(不能重启)</a></h3><ol>
<li>先在原先的操作系统中新建一个目录,比如/croot</li>
<li>将目标操作系统的各个分区先挂载起来,需要建立各分区对应的文件,如/croot/usr /croot/home等</li>
<li>使用chroot切换操作系统 <code>chroot /croot</code></li>
</ol>
<h3 id="查看打印机是否支持Linux"><a href="#查看打印机是否支持Linux" class="headerlink" title=" 查看打印机是否支持Linux"></a><a name="q19"> 查看打印机是否支持Linux</a></h3><p><a href="https://wiki.linuxfoundation.org/" target="_blank" rel="external">https://wiki.linuxfoundation.org/</a> 下的openprinting条目</p>
<h3 id="修改主机名"><a href="#修改主机名" class="headerlink" title=" 修改主机名"></a><a name="q20"> 修改主机名</a></h3><p>修改<code>/etc/hostname(Ubuntu)</code>或<code>/etc/sysconfig/network</code> 之后还有修改<code>/etc/hosts</code>相应的条目</p>
<h3 id="Ubuntu14-04下SublimeText3不能输中文"><a href="#Ubuntu14-04下SublimeText3不能输中文" class="headerlink" title=" Ubuntu14.04下SublimeText3不能输中文"></a><a name="q21"> Ubuntu14.04下SublimeText3不能输中文</a></h3><p>我是查找了此网友的方法<a href="http://www.jianshu.com/p/bf05fb3a4709" target="_blank" rel="external">解决Ubuntu下Sublime Text 3无法输入中文</a></p>
<p>但是不能解决,继续折腾后</p>
<p>解决方法：</p>
<ol>
<li>在sublimeText3官网下*.deb包,源码编译出来的sublimeText解决有点绕</li>
<li>下载此网友的github库<a href="https://github.com/lyfeyaj/sublime-text-imfix" target="_blank" rel="external">sublime-text-imfix</a>,安装其步骤来</li>
<li>最后遇到问题<code>ERROR: ld.so: object &#39;/opt/sublime_text/libsublime-imfix.so&#39; from LD_PRELOAD cannot be preloaded (wrong ELF class: ELFCLASS64): ignored.</code></li>
<li>这里要重新编译出<code>libsublime-imfix.so</code>库,放到<code>/opt/sublime_text/</code>下,编译步骤<ol>
<li>先在下好的github库目录下找到<code>src/sublime-imfix.c</code>,对其进行编译</li>
<li>确认安装了C/C++ 的编译环境和 gtk libgtk2.0-dev,<code>sudo apt-get install build-essential&amp;&amp;sudo apt-get install libgtk2.0-dev</code><ul>
<li>发现<code>libgtk2.0-dev</code>依赖有问题(啊！！你还玩我) 解决方法是用<code>aptitude install ibgtk2.0-dev</code>,其会提供依赖解决方法,我选择的是将依赖包降级安装</li>
</ul>
</li>
<li><code>gcc -shared -o libsublime-imfix.so sublime_imfix.c</code>pkg-config –libs –cflags gtk+-2.0<code>-fPIC</code> 编译出<code>libsublime-imfix.so</code></li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 卸载多系统中的linux]]></title>
      <url>http://yoursite.com/2016/09/05/Linux-%E5%8D%B8%E8%BD%BD%E5%A4%9A%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84linux/</url>
      <content type="html"><![CDATA[<p>前段时间决定要系统学习Linux，于是想把很久前安装在电脑上的ubuntu卸装再安装linux mint(这也是ubuntu冏rz)，当安装完linux mint 17的64位系统时它将原本的ubuntu覆盖掉了，在编译C程序时发觉少了库文件，再安装发觉问题没有解决，于是再安装了mint的32位系统，于是产生mint 32位、64位系统和win7共存的情况，最后决定卸装mint 64位系统。
教程<a href="http://www.cnblogs.com/woshijpf/p/3835659.html" target="_blank" rel="external">一台电脑上含有多个ubuntu系统的卸载方法</a>
<a id="more"></a></p>
<h2 id="查看linux系统的分区情况"><a href="#查看linux系统的分区情况" class="headerlink" title="查看linux系统的分区情况"></a>查看linux系统的分区情况</h2><p>分别进入两个linux系统，进入控制台，输入命令“sudo df -hl”查看文件系统的挂在情况，之前我操作时没有截图，现在使用教程中的截图。
例如：原作者的32位系统的文件系统的挂载情况是这样的：
<img src="https://raw.githubusercontent.com/HiKumho/blog/master/img/blog_5_1.jpg" alt=""></p>
<p>我的32系统没有/boot和/home分区，应该是安装系统时没有设置好。先继续往下走</p>
<p>我们可以看到原作者这个系统的挂载情况是：
/ （根文件目录）                             挂载在了/dev/sda10上面
/boot  （启动文件目录）                 挂载在了/dev/sda8上面
/home  (用户主目录)                       挂载在了/dev/sda11上面
安装系统时还分配了一个swap（交换分区），在这里我们并没有看到啊，但是，我们可以输入命令“sudo  fdisk   -l”查看整个硬盘的分区情况
在这里我们看到的/dev/sda9 就是我这个32位系统对应的交换分区。
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_5_2.jpg?raw=true" alt=""></p>
<p>我们记下根目录、/boot、/home、/swap内存块(Blocks)大小。这里要换算单位，Blocks里单位是字节，需要换算成GB，方便我们下面比较。换算公式：1GB=1024*1024B。64位系统也要这样记录。</p>
<p>同理我们进入64位的系统的文件系统的挂载情况是：
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_5_3.jpg?raw=true" alt=""></p>
<h2 id="删除GRUB-恢复Window引导"><a href="#删除GRUB-恢复Window引导" class="headerlink" title="删除GRUB 恢复Window引导"></a>删除GRUB 恢复Window引导</h2><p>接下来，我们就重启电脑，进入windows系统。由于我安装的三系统是由Ubuntu系统的GRUB来引导的，它把启动信息写入到了磁盘的MBR（磁盘中的一小块区域负责引导系统启动用的）中。（如果你的电脑一开机就进入到了GRUB菜单，说明的GRUB的确写入到了MBR中）</p>
<p>接下来主要进行的就是删除GRUB的操作</p>
<ol>
<li>进入windows 7系统，下载一个MbrFix的修复软件，放在、C:\windows\System32文件夹中。</li>
<li>按“windows键+R”，然后输入cmd回车，就可以进入了命令行提示符界面。</li>
<li>在命令行提示符界面中我们输入 MbrFix      /drive  0  fixmbr  回车(这里你可能需要进入MbfFix所在的文件夹内)
这时候，屏幕上会提示你是否进行修复的询问？你输入 y或者yes回车确认就可以了。如果什么也不出现了，只是显示命令行的提示符而已时，说明你的MBR修复好了。</li>
<li>重启电脑，如果你的电脑没有出现GRUB菜单，直接进入windows系统则说明你真正地修复成功了。</li>
</ol>
<h2 id="删除Linux分区"><a href="#删除Linux分区" class="headerlink" title="删除Linux分区"></a>删除Linux分区</h2><p>接下来我们就该删除我们不想要linux系统的分区了，我这儿的例子是删除我电脑了不想要的的64位的Ubuntu系统。</p>
<ol>
<li>计算机右键单击–&gt;&gt;管理–&gt;&gt;存储–&gt;&gt;磁盘管理，这样我们就进入了磁盘管理的界面</li>
<li>我们可以在下面的磁盘管理图中看到，没有C,D,E,F,卷标之类的区域，没错，我们终于找到了linux的磁盘空间。下图就是我电脑的情况：
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_5_4.png?raw=true" alt=""></li>
</ol>
<p>其中画红线的区域就是两个Ubuntu系统所占的空间。</p>
<p>但是哪一个才是64位Ubuntu系统所占的磁盘空间呢。我们得看第一步中的几个图了。通过第一步中的第二、第三个图我们可以知道，64的Ubuntu系统就占的是设备块/dev/sda12/（14.9GB）,/dev/sda13/（1.86GB）,/dev/sda14/（190MB）,/dev/sda15/（13.32GB）。。有木有发现，我下图绿色圈起来的区域就是要删除的区域。
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_5_5.png?raw=true" alt=""></p>
<p>接下来，我们就在上面的磁盘空间中找到每个对应大小的磁盘空间，右键删除即可。删除完后，我们会发现，删除后的空就会变成绿色（这就表示这块空间空闲可用）。如果你想把这块区域分配给windows用的话，你可以右键这块绿色的区域，进行“新建简单卷”，按照提示来操作即可。到此我们真的就把64位的ubuntu给删了，真的没有啦。</p>
<p>但是你重启下电脑会发现，它还是会直接进入windows系统，那你的另外一个系统怎么办呢？它跑哪里去啦？</p>
<h2 id="修复GRUB"><a href="#修复GRUB" class="headerlink" title="修复GRUB"></a>修复GRUB</h2><p>首先，你得制作一个Ubuntu系统的启动盘，这是用来修复GRUB用的。进入Ubuntu试用模式</p>
<ol>
<li><p>进入root 用户模式，输入“sudo -i”
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_5_6.jpg?raw=true" alt=""></p>
</li>
<li><p>使用命令“fdisk -l”查看现在的磁盘使用情况，我们可以清楚地看到我们现在只有4个linux相关的分区了。
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_5_7.jpg?raw=true" alt=""></p>
</li>
<li><p>现在我们就将GRUB安装到MBR中。按照图中命令敲吧。（如果你安装的Ubuntu系统中没有将/boot/挂载到具体的某一个磁盘上的话，mount /dev/sda8 /mnt/boot/  这个命令你就跳过吧）
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_5_8.jpg?raw=true" alt=""></p>
</li>
<li><p>上面的运行结果显示无错误。我们现在已经基本大功告成,如果上面运行结果有错误，可以是使用boot-repair来修复，教程<a href="http://jingyan.baidu.com/article/5553fa82cd48a765a23934ae.html" target="_blank" rel="external">用Boot-repair修复双系统引导</a></p>
</li>
<li><p>最后更新的GRUB,输入命令“sudo update -grub”
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_5_9.jpg?raw=true" alt=""></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 查看主机硬件信息]]></title>
      <url>http://yoursite.com/2016/09/05/Linux-%E6%9F%A5%E7%9C%8B%E4%B8%BB%E6%9C%BA%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/</url>
      <content type="html"><![CDATA[<p>最近在学习Linux,看的资料是鸟哥的.书上有道习题是查看自己主机的硬件信息,现在在这里总结下.
<a id="more"></a></p>
<h3 id="查看CPU的厂商-型号-最高频率"><a href="#查看CPU的厂商-型号-最高频率" class="headerlink" title="查看CPU的厂商/型号/最高频率"></a>查看CPU的厂商/型号/最高频率</h3><ul>
<li>查看CPU信息  使用命令   <code>cat  /proc/cpuinfo</code><br>MyCpu 厂商:Intel  型号:Celeron 1017U 最高频率:1.60GHz(准确的是1587.625MHz)
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_6_1.png?raw=true" alt=""></li>
</ul>
<h3 id="查看内存的容量-接口-DDR-DDRII等"><a href="#查看内存的容量-接口-DDR-DDRII等" class="headerlink" title="查看内存的容量/接口(DDR/DDRII等)"></a>查看内存的容量/接口(DDR/DDRII等)</h3><ul>
<li><p>查看内存容量   使用命令   <code>cat  /proc/meminfo</code>
My 内存总容量:5.79GB(6075060KB)
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_6_2.png?raw=true" alt=""></p>
</li>
<li><p>查看内存接口   使用命令   <code>dmidecode | grep -A16 &quot;Memory Device$&quot;</code>
My 内存接口:DDR3
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_6_3.png?raw=true" alt=""></p>
</li>
</ul>
<h3 id="查看显卡的接口-AGP-PCIe内置-与容量"><a href="#查看显卡的接口-AGP-PCIe内置-与容量" class="headerlink" title="查看显卡的接口(AGP/PCIe内置)与容量"></a>查看显卡的接口(AGP/PCIe内置)与容量</h3><ul>
<li><p>查看显卡型号  使用命令   <code>lshw -C display</code>
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_6_4.png?raw=true" alt=""></p>
</li>
<li><p>查看显存     使用命令   <code>lspci -vnn | grep VGA -A 12</code>
观察memory at d0000000
My 显存:256MB
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_6_5.png?raw=true" alt=""></p>
</li>
</ul>
<h3 id="查看主板的型号-南北桥的芯片型号-BIOS的版本-网卡声卡的型号"><a href="#查看主板的型号-南北桥的芯片型号-BIOS的版本-网卡声卡的型号" class="headerlink" title="查看主板的型号/南北桥的芯片型号/BIOS的版本/网卡声卡的型号"></a>查看主板的型号/南北桥的芯片型号/BIOS的版本/网卡声卡的型号</h3><ul>
<li><p>查看主板型号  使用命令 <code>dmidecode | grep -A16 &quot;System Information$&quot;</code>
My 主板型号 03N858
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_6_6.png?raw=true" alt=""></p>
</li>
<li><p>查看南北桥芯片型号</p>
<ul>
<li>北桥芯片型号  使用命令  <code>dmesg | grep Chipset</code><br>My 北桥芯片型号 GF117
<code>[   15.436587] nouveau  [  DEVICE][0000:02:00.0] Chipset: GF117 (NVD7)</code></li>
<li>南桥芯片型号  没有查到</li>
</ul>
</li>
</ul>
<ul>
<li><p>查看BIOS版本   使用命令 <code>dmidecode --type Bios</code>
My BIOS版本: A05</p>
</li>
<li><p>查看声卡  使用命令 <code>lspci |grep -i audio</code>
My 声卡: Inter 7 Series /C210</p>
</li>
<li><p>查看网卡  使用命令  <code>lspci | grep - i eth</code>
My 网卡:Realtek RTL8101/2/6E</p>
</li>
</ul>
<h3 id="查看硬盘的连接接口-IDE-SATA等-硬盘容量-转速-缓冲存储器容量等"><a href="#查看硬盘的连接接口-IDE-SATA等-硬盘容量-转速-缓冲存储器容量等" class="headerlink" title="查看硬盘的连接接口(IDE/SATA等)/硬盘容量/转速/缓冲存储器容量等"></a>查看硬盘的连接接口(IDE/SATA等)/硬盘容量/转速/缓冲存储器容量等</h3><ul>
<li><p>查看硬盘的连接接口 使用命令 <code>lspci | grep 00:1f.2</code>
My的硬盘连接接口:SATA
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_6_8.png?raw=true" alt=""></p>
</li>
<li><p>查看硬盘容量 使用命令 <code>lsblk</code> 
My硬盘容量:465.8G
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_6_9.png?raw=true" alt=""></p>
</li>
<li><p>查看硬盘转速 使用命令 <code>hdparm -I /dev/sda</code>  观察Nominal Media Rotation Rate行
My硬盘转速:5400
<img src="https://github.com/HiKumho/blog/blob/master/img/blog_6_10.png?raw=true" alt=""></p>
</li>
<li>查看缓冲存储器容量  没有找到命令</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据库管理 Excel数据导入Mysql]]></title>
      <url>http://yoursite.com/2016/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86-Excel%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5Mysql/</url>
      <content type="html"><![CDATA[<h2 id="EXCEL筛选数据"><a href="#EXCEL筛选数据" class="headerlink" title="EXCEL筛选数据"></a>EXCEL筛选数据</h2><p> EXCEL中的数据可能有很多重复项，需要删除。<br>方法：    </p>
<ul>
<li>确认重复行，并在数据内容外的列设置公式形如=IF(A2=A1,1,2) // A2如果=A1 则当前单元格=1  并运行此公式至所有列（光标指向当前单元格右下角出现黑十字往拉下）</li>
<li>对上述所得的列进行选择性粘贴，粘贴为数据</li>
<li>然后对上所得的列进行“筛选”，选择数据为1（可能为2，要实际处理）的行全部删除
参考<a href="http://jingyan.baidu.com/article/eae078278fbdd81fec54853c.html" target="_blank" rel="external">WPS表格（或EXCEL）如何方便删除重复行</a></li>
</ul>
<h2 id="EXCEL导入数据"><a href="#EXCEL导入数据" class="headerlink" title="EXCEL导入数据"></a>EXCEL导入数据</h2><p>我是将EXCEL数据转成TXT文本格式(UTF8编码)
方法：</p>
<ul>
<li>直接将EXEL数据另存为TXT，这里WPS会有制表符还分割数据项。</li>
<li>我将数据项间的制表符用,替换</li>
<li>注意要删除TXT中每行最后的空格</li>
</ul>
<h2 id="MySQL中文字符的处理"><a href="#MySQL中文字符的处理" class="headerlink" title="MySQL中文字符的处理"></a>MySQL中文字符的处理</h2><p>如果想MySql导入中文字符，可能会出现乱码、报错等<br>之前在5.1报违反字符的错误，但当将数据库所有字符集设置成utf8后仍出现错误<br>这里原因可能是低版本的MySql不支持多字节的中文字符<br>于是将MySql升级到最新版本<br>关于设置Mysql字符集的方法可以在My.ini中设置Default-characters-set和 sever-characters-set
<a href="http://my.oschina.net/5365437/blog/142312?fromerr=n6DQp3A3" target="_blank" rel="external">Mysql 插入数据里有中文字符出现 Incorrect string value 的错误</a>;</p>
<h3 id="MySql卸装处理"><a href="#MySql卸装处理" class="headerlink" title="MySql卸装处理"></a>MySql卸装处理</h3><ul>
<li>在Window中”服务”中停止Mysql</li>
<li>然后在”程序”中卸装Mysql</li>
<li>最后清除注册表
参考<a href="http://materliu.github.io/all/web/database/mysql/2014/04/24/uninstall-mysql-totaly.cm.html" target="_blank" rel="external">windows如何彻底卸载mysql</a></li>
</ul>
<h2 id="MySql数据文件导入"><a href="#MySql数据文件导入" class="headerlink" title="MySql数据文件导入"></a>MySql数据文件导入</h2><p>这里导入的是文本文件 </p>
<p>使用命令：<br>load data local infile ‘文件路径’ into table 表名<br>fields terminated by ‘,’<br>lines terminated by ‘\r\n’;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Web 前端技术介绍]]></title>
      <url>http://yoursite.com/2016/09/05/Web-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="HTML的概念"><a href="#HTML的概念" class="headerlink" title="HTML的概念"></a>HTML的概念</h2><p> 超文本标记语言（HyperText Markup Language，HTML）是一种用于创建网页的标准标记语言。HTML是一种基础技术，常与CSS，JS一起被众多网站用于设计令人赏心悦目的网页、网页应用程序以及移动应用程序的用户界面。以上摘抄着wiki<br>我的理解，HTML一种标记语言，不同一般文本(超越233)。Markdown也是标记语言，Markdown的文本会转成HTML或XHTML。</p>
<h3 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h3><ul>
<li>div标签：页面布局 我理解成div~Android.RelativeLayout      </li>
<li>h1~h6, p, span, strong, em等标签： 设置文本格式 （span标签之间有空格）</li>
<li>ul, li, ol, dl, dt, dd标签：此类标签用于设置带有列表内容的，比如导航栏的下拉菜单，多视频的缩略图等</li>
<li>form标签：form标签在UI显示上可以理解成div，透明的，用于提交数据</li>
<li>table标签：表格结构，尽量用div代替</li>
<li>img, canvas标签：图像容器，但是通常不直接操作，而是在其外层嵌套div，span标签（你问span是什么？span 用来组合元素，没有固定的格式表现。当对它应用样式时，它才会产生视觉上的变化。）</li>
<li>a标签：链接跳转<br>详细请看~<a href="https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/common-tag.html" target="_blank" rel="external">前端工程师手册</a></li>
</ul>
<h3 id="HTML低保真图设计"><a href="#HTML低保真图设计" class="headerlink" title="HTML低保真图设计"></a>HTML低保真图设计</h3><p>低保真图便于用户了解整个项目的前端设计，快速开发出HTML页面原型图。<br><strong>使用工具：Axure</strong></p>
<h2 id="CSS的概念"><a href="#CSS的概念" class="headerlink" title="CSS的概念"></a>CSS的概念</h2><p>一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、间距和颜色等）的计算机语言，由W3C定义和维护。摘自Wiki<br>我理解成控制html标签的属性</p>
<h3 id="常用CSS属性"><a href="#常用CSS属性" class="headerlink" title="常用CSS属性"></a>常用CSS属性</h3><ul>
<li>定位Position: 属性值 relative 相对定位（相对与元素正常显示状态的偏离定位 其正常显示的区域空间仍然占据）<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;属性值absolute 绝对定位（元素脱离整个文档，相对与最近的已定位祖先元素，可以定位到其任何位置，并显示在最上层，其不占据原本显示的空间）<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;属性值 fixed 效果与absolute相同</li>
<li>元素居中： 布局容器内元素水平居中 容器的text-align:center;  容器内垂直居中容器的line-height=容器的height</li>
<li>列表水平： float：left</li>
<li>浮动float：可以定位元素 脱离文档流 当元素因为被浮动的元素影响其的布局时，该元素使用clear:both 清除浮动 显示该元素的原本位置</li>
</ul>
<h2 id="JavaScript的概念"><a href="#JavaScript的概念" class="headerlink" title="JavaScript的概念"></a>JavaScript的概念</h2><p>我的理解是前端脚本语言，实现一些用户交互功能，如弹出对话框，修改html、css属性等</p>
<h3 id="JS中构造对象"><a href="#JS中构造对象" class="headerlink" title="JS中构造对象"></a>JS中构造对象</h3><p>在JS中可以这样构造对象<br>funcation Persion(name,age){this.name=name;this.age=age;};<br>Persion Jack=new Persion(“Jack”,20);</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Github 基本操作]]></title>
      <url>http://yoursite.com/2016/09/05/Github-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="什么是Github？"><a href="#什么是Github？" class="headerlink" title="什么是Github？"></a>什么是Github？</h2><p>Github，要了解什么是Git，Git最初是linus为了管理Linux内核开发的代码版本控制器,当然还有多人异地协作开发的能力。Github是Git的网站平台。 总之就是分布式版本控制管理软件（笑），现在已经是重要的社交平台了2333</p>
<h2 id="注册安装"><a href="#注册安装" class="headerlink" title="注册安装"></a>注册安装</h2><p>注册不介绍了，请前往<a href="http://www.github.com" target="_blank" rel="external">Github</a>  安装可以使用Desktop版，但在线下载十分麻烦，可以Google下离线版，我是在<a href="http://download.csdn.net/download/nevinblog/9031049" target="_blank" rel="external">CSDN</a>上下载</p>
<h2 id="创建仓库（New-repository）"><a href="#创建仓库（New-repository）" class="headerlink" title="创建仓库（New repository）"></a>创建仓库（New repository）</h2><p>仓库就是管理项目的空间，在Github网站上创建的是在线版 Desktop创建的是本地版，当然通过Push及Pull（稍后解释）可以及时推送更新本地仓库</p>
<p><img src="https://pic3.zhimg.com/fa17ad7322545d236198a206063f378e_b.png" alt=""></p>
<h2 id="删除仓库"><a href="#删除仓库" class="headerlink" title="删除仓库"></a>删除仓库</h2><p>在仓库首页的settings中最下方有一个Danger Zone删除仓库,删除仓库需要输入仓库名确认
<img src="http://static.oschina.net/uploads/space/2013/0331/140629_56aS_580112.png" alt=""></p>
<h2 id="关于Watch、Star、Fork、Clone"><a href="#关于Watch、Star、Fork、Clone" class="headerlink" title="关于Watch、Star、Fork、Clone"></a>关于Watch、Star、Fork、Clone</h2><p>Watch是关注，等作者更新时，会收到通知； Star是收藏，方便以后查找，不会收到作者更新通知fork就是拷贝作者的项目至我们git中了，可以理解成你想要参与此项目; Clone就是拷贝项目至本地，之前我就是把Github当成找源码的地方，现在好好学学:)</p>
<h2 id="上传Commit"><a href="#上传Commit" class="headerlink" title="上传Commit"></a>上传Commit</h2><p>仓库里有一条叫master的主线，当我们没有创建分支branch时，我们上传的文件是提交到master中，我们一个提交动作会有描述信息，方便我们日后查找此提交的信息，或者回滚提交~ 回滚历史版本请找小齿轮按钮（Roll Back to this Commit）
<img src="https://pic4.zhimg.com/2e2d2a0da0662f65fb969ef8005ee01f_b.png" alt=""></p>
<h2 id="关于分支Branch"><a href="#关于分支Branch" class="headerlink" title="关于分支Branch"></a>关于分支Branch</h2><p>分支可以理解成我们项目的发行号，或者调试版本等等等</p>
<h2 id="有分支，当然有合并"><a href="#有分支，当然有合并" class="headerlink" title="有分支，当然有合并"></a>有分支，当然有合并</h2><p>合并Pull，当我们和一个大牛正在进行同一个项目的开发，一个大牛手上的branch或者master写的很多跟我们手上的branch或者master没有的功能，我们就会发送一个pull request给大牛，如果我们写的代码和大牛写的代码没有冲突，就可以自行合并大牛的代码至我们项目，如果有冲突，可以在pull request的空间上给大牛商量解决。 pull requestsh是双向的，即分支可以请求主线合并代码至主线，分支可以请求主线合并代码至分支，当然主线也是可以请求分支的。</p>
<h2 id="Github的基本操作图"><a href="#Github的基本操作图" class="headerlink" title="Github的基本操作图"></a>Github的基本操作图</h2><p><img src="https://pic4.zhimg.com/6c22d708def21094956b76bc7df2240b_b.png" alt=""></p>
<h2 id="关于MarkDown"><a href="#关于MarkDown" class="headerlink" title="关于MarkDown"></a>关于MarkDown</h2><p>MarkDown是一种标记的文本格式，可以转换成HTML或XML很方便~~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.zhihu.com/question/20070065" target="_blank" rel="external">怎样使用 GitHub？</a> </li>
<li><a href="http://www.oschina.net/question/256591_103418" target="_blank" rel="external">怎么删除github上的仓库</a> </li>
<li><a href="https://www.zhihu.com/question/20406847" target="_blank" rel="external">GitHub 中为什么有了 Watch 又增加了一个 Star 呢？</a> </li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
